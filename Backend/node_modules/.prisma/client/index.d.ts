
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Eps
 * 
 */
export type Eps = $Result.DefaultSelection<Prisma.$EpsPayload>
/**
 * Model Tipo_Procedimiento
 * 
 */
export type Tipo_Procedimiento = $Result.DefaultSelection<Prisma.$Tipo_ProcedimientoPayload>
/**
 * Model Procedimiento
 * 
 */
export type Procedimiento = $Result.DefaultSelection<Prisma.$ProcedimientoPayload>
/**
 * Model Estudio
 * 
 */
export type Estudio = $Result.DefaultSelection<Prisma.$EstudioPayload>
/**
 * Model Departamento
 * 
 */
export type Departamento = $Result.DefaultSelection<Prisma.$DepartamentoPayload>
/**
 * Model Municipio
 * 
 */
export type Municipio = $Result.DefaultSelection<Prisma.$MunicipioPayload>
/**
 * Model Tipo_Servicio
 * 
 */
export type Tipo_Servicio = $Result.DefaultSelection<Prisma.$Tipo_ServicioPayload>
/**
 * Model Servicio
 * 
 */
export type Servicio = $Result.DefaultSelection<Prisma.$ServicioPayload>
/**
 * Model Examen
 * 
 */
export type Examen = $Result.DefaultSelection<Prisma.$ExamenPayload>
/**
 * Model Tipo_Resultado
 * 
 */
export type Tipo_Resultado = $Result.DefaultSelection<Prisma.$Tipo_ResultadoPayload>
/**
 * Model Tipo_Examen
 * 
 */
export type Tipo_Examen = $Result.DefaultSelection<Prisma.$Tipo_ExamenPayload>
/**
 * Model Prestador
 * 
 */
export type Prestador = $Result.DefaultSelection<Prisma.$PrestadorPayload>
/**
 * Model Profesional
 * 
 */
export type Profesional = $Result.DefaultSelection<Prisma.$ProfesionalPayload>
/**
 * Model Empresa
 * 
 */
export type Empresa = $Result.DefaultSelection<Prisma.$EmpresaPayload>
/**
 * Model Contrato
 * 
 */
export type Contrato = $Result.DefaultSelection<Prisma.$ContratoPayload>
/**
 * Model Tarifa
 * 
 */
export type Tarifa = $Result.DefaultSelection<Prisma.$TarifaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Tipo_Ident: {
  AS: 'AS',
  CC: 'CC',
  CE: 'CE',
  MV: 'MV',
  RC: 'RC',
  TI: 'TI'
};

export type Tipo_Ident = (typeof Tipo_Ident)[keyof typeof Tipo_Ident]


export const Sex: {
  Femenino: 'Femenino',
  Masculino: 'Masculino',
  Indetermidado: 'Indetermidado'
};

export type Sex = (typeof Sex)[keyof typeof Sex]


export const Tipo_Usuario: {
  Contributivo: 'Contributivo',
  Subsidiado: 'Subsidiado',
  Vinculado: 'Vinculado',
  Particular: 'Particular',
  Otro: 'Otro'
};

export type Tipo_Usuario = (typeof Tipo_Usuario)[keyof typeof Tipo_Usuario]


export const Estado: {
  Activo: 'Activo',
  Inactivo: 'Inactivo'
};

export type Estado = (typeof Estado)[keyof typeof Estado]


export const Rol: {
  Administrador: 'Administrador',
  Facturacion: 'Facturacion',
  Bacteriologo: 'Bacteriologo'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const Tipo_Empresa: {
  Particular: 'Particular',
  Empresa: 'Empresa',
  Eps: 'Eps',
  Esess: 'Esess'
};

export type Tipo_Empresa = (typeof Tipo_Empresa)[keyof typeof Tipo_Empresa]

}

export type Tipo_Ident = $Enums.Tipo_Ident

export const Tipo_Ident: typeof $Enums.Tipo_Ident

export type Sex = $Enums.Sex

export const Sex: typeof $Enums.Sex

export type Tipo_Usuario = $Enums.Tipo_Usuario

export const Tipo_Usuario: typeof $Enums.Tipo_Usuario

export type Estado = $Enums.Estado

export const Estado: typeof $Enums.Estado

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type Tipo_Empresa = $Enums.Tipo_Empresa

export const Tipo_Empresa: typeof $Enums.Tipo_Empresa

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.eps`: Exposes CRUD operations for the **Eps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eps
    * const eps = await prisma.eps.findMany()
    * ```
    */
  get eps(): Prisma.EpsDelegate<ExtArgs>;

  /**
   * `prisma.tipo_Procedimiento`: Exposes CRUD operations for the **Tipo_Procedimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_Procedimientos
    * const tipo_Procedimientos = await prisma.tipo_Procedimiento.findMany()
    * ```
    */
  get tipo_Procedimiento(): Prisma.Tipo_ProcedimientoDelegate<ExtArgs>;

  /**
   * `prisma.procedimiento`: Exposes CRUD operations for the **Procedimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedimientos
    * const procedimientos = await prisma.procedimiento.findMany()
    * ```
    */
  get procedimiento(): Prisma.ProcedimientoDelegate<ExtArgs>;

  /**
   * `prisma.estudio`: Exposes CRUD operations for the **Estudio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudios
    * const estudios = await prisma.estudio.findMany()
    * ```
    */
  get estudio(): Prisma.EstudioDelegate<ExtArgs>;

  /**
   * `prisma.departamento`: Exposes CRUD operations for the **Departamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departamentos
    * const departamentos = await prisma.departamento.findMany()
    * ```
    */
  get departamento(): Prisma.DepartamentoDelegate<ExtArgs>;

  /**
   * `prisma.municipio`: Exposes CRUD operations for the **Municipio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipios
    * const municipios = await prisma.municipio.findMany()
    * ```
    */
  get municipio(): Prisma.MunicipioDelegate<ExtArgs>;

  /**
   * `prisma.tipo_Servicio`: Exposes CRUD operations for the **Tipo_Servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_Servicios
    * const tipo_Servicios = await prisma.tipo_Servicio.findMany()
    * ```
    */
  get tipo_Servicio(): Prisma.Tipo_ServicioDelegate<ExtArgs>;

  /**
   * `prisma.servicio`: Exposes CRUD operations for the **Servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicio.findMany()
    * ```
    */
  get servicio(): Prisma.ServicioDelegate<ExtArgs>;

  /**
   * `prisma.examen`: Exposes CRUD operations for the **Examen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Examen
    * const examen = await prisma.examen.findMany()
    * ```
    */
  get examen(): Prisma.ExamenDelegate<ExtArgs>;

  /**
   * `prisma.tipo_Resultado`: Exposes CRUD operations for the **Tipo_Resultado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_Resultados
    * const tipo_Resultados = await prisma.tipo_Resultado.findMany()
    * ```
    */
  get tipo_Resultado(): Prisma.Tipo_ResultadoDelegate<ExtArgs>;

  /**
   * `prisma.tipo_Examen`: Exposes CRUD operations for the **Tipo_Examen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_Examen
    * const tipo_Examen = await prisma.tipo_Examen.findMany()
    * ```
    */
  get tipo_Examen(): Prisma.Tipo_ExamenDelegate<ExtArgs>;

  /**
   * `prisma.prestador`: Exposes CRUD operations for the **Prestador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prestadors
    * const prestadors = await prisma.prestador.findMany()
    * ```
    */
  get prestador(): Prisma.PrestadorDelegate<ExtArgs>;

  /**
   * `prisma.profesional`: Exposes CRUD operations for the **Profesional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profesionals
    * const profesionals = await prisma.profesional.findMany()
    * ```
    */
  get profesional(): Prisma.ProfesionalDelegate<ExtArgs>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **Empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.EmpresaDelegate<ExtArgs>;

  /**
   * `prisma.contrato`: Exposes CRUD operations for the **Contrato** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contratoes
    * const contratoes = await prisma.contrato.findMany()
    * ```
    */
  get contrato(): Prisma.ContratoDelegate<ExtArgs>;

  /**
   * `prisma.tarifa`: Exposes CRUD operations for the **Tarifa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tarifas
    * const tarifas = await prisma.tarifa.findMany()
    * ```
    */
  get tarifa(): Prisma.TarifaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Eps: 'Eps',
    Tipo_Procedimiento: 'Tipo_Procedimiento',
    Procedimiento: 'Procedimiento',
    Estudio: 'Estudio',
    Departamento: 'Departamento',
    Municipio: 'Municipio',
    Tipo_Servicio: 'Tipo_Servicio',
    Servicio: 'Servicio',
    Examen: 'Examen',
    Tipo_Resultado: 'Tipo_Resultado',
    Tipo_Examen: 'Tipo_Examen',
    Prestador: 'Prestador',
    Profesional: 'Profesional',
    Empresa: 'Empresa',
    Contrato: 'Contrato',
    Tarifa: 'Tarifa'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "eps" | "tipo_Procedimiento" | "procedimiento" | "estudio" | "departamento" | "municipio" | "tipo_Servicio" | "servicio" | "examen" | "tipo_Resultado" | "tipo_Examen" | "prestador" | "profesional" | "empresa" | "contrato" | "tarifa"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Eps: {
        payload: Prisma.$EpsPayload<ExtArgs>
        fields: Prisma.EpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EpsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EpsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          findFirst: {
            args: Prisma.EpsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EpsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          findMany: {
            args: Prisma.EpsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>[]
          }
          create: {
            args: Prisma.EpsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          createMany: {
            args: Prisma.EpsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EpsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          update: {
            args: Prisma.EpsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          deleteMany: {
            args: Prisma.EpsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EpsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EpsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          aggregate: {
            args: Prisma.EpsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEps>
          }
          groupBy: {
            args: Prisma.EpsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EpsCountArgs<ExtArgs>
            result: $Utils.Optional<EpsCountAggregateOutputType> | number
          }
        }
      }
      Tipo_Procedimiento: {
        payload: Prisma.$Tipo_ProcedimientoPayload<ExtArgs>
        fields: Prisma.Tipo_ProcedimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tipo_ProcedimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tipo_ProcedimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          findFirst: {
            args: Prisma.Tipo_ProcedimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tipo_ProcedimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          findMany: {
            args: Prisma.Tipo_ProcedimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>[]
          }
          create: {
            args: Prisma.Tipo_ProcedimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          createMany: {
            args: Prisma.Tipo_ProcedimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Tipo_ProcedimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          update: {
            args: Prisma.Tipo_ProcedimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          deleteMany: {
            args: Prisma.Tipo_ProcedimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tipo_ProcedimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Tipo_ProcedimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          aggregate: {
            args: Prisma.Tipo_ProcedimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_Procedimiento>
          }
          groupBy: {
            args: Prisma.Tipo_ProcedimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ProcedimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tipo_ProcedimientoCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ProcedimientoCountAggregateOutputType> | number
          }
        }
      }
      Procedimiento: {
        payload: Prisma.$ProcedimientoPayload<ExtArgs>
        fields: Prisma.ProcedimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          findFirst: {
            args: Prisma.ProcedimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          findMany: {
            args: Prisma.ProcedimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>[]
          }
          create: {
            args: Prisma.ProcedimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          createMany: {
            args: Prisma.ProcedimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcedimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          update: {
            args: Prisma.ProcedimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          deleteMany: {
            args: Prisma.ProcedimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcedimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          aggregate: {
            args: Prisma.ProcedimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedimiento>
          }
          groupBy: {
            args: Prisma.ProcedimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedimientoCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedimientoCountAggregateOutputType> | number
          }
        }
      }
      Estudio: {
        payload: Prisma.$EstudioPayload<ExtArgs>
        fields: Prisma.EstudioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          findFirst: {
            args: Prisma.EstudioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          findMany: {
            args: Prisma.EstudioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>[]
          }
          create: {
            args: Prisma.EstudioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          createMany: {
            args: Prisma.EstudioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EstudioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          update: {
            args: Prisma.EstudioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          deleteMany: {
            args: Prisma.EstudioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EstudioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          aggregate: {
            args: Prisma.EstudioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudio>
          }
          groupBy: {
            args: Prisma.EstudioGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudioGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudioCountArgs<ExtArgs>
            result: $Utils.Optional<EstudioCountAggregateOutputType> | number
          }
        }
      }
      Departamento: {
        payload: Prisma.$DepartamentoPayload<ExtArgs>
        fields: Prisma.DepartamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          findFirst: {
            args: Prisma.DepartamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          findMany: {
            args: Prisma.DepartamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>[]
          }
          create: {
            args: Prisma.DepartamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          createMany: {
            args: Prisma.DepartamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          update: {
            args: Prisma.DepartamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          deleteMany: {
            args: Prisma.DepartamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          aggregate: {
            args: Prisma.DepartamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartamento>
          }
          groupBy: {
            args: Prisma.DepartamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartamentoCountArgs<ExtArgs>
            result: $Utils.Optional<DepartamentoCountAggregateOutputType> | number
          }
        }
      }
      Municipio: {
        payload: Prisma.$MunicipioPayload<ExtArgs>
        fields: Prisma.MunicipioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          findFirst: {
            args: Prisma.MunicipioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          findMany: {
            args: Prisma.MunicipioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>[]
          }
          create: {
            args: Prisma.MunicipioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          createMany: {
            args: Prisma.MunicipioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MunicipioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          update: {
            args: Prisma.MunicipioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          deleteMany: {
            args: Prisma.MunicipioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MunicipioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          aggregate: {
            args: Prisma.MunicipioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipio>
          }
          groupBy: {
            args: Prisma.MunicipioGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipioGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipioCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipioCountAggregateOutputType> | number
          }
        }
      }
      Tipo_Servicio: {
        payload: Prisma.$Tipo_ServicioPayload<ExtArgs>
        fields: Prisma.Tipo_ServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tipo_ServicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tipo_ServicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          findFirst: {
            args: Prisma.Tipo_ServicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tipo_ServicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          findMany: {
            args: Prisma.Tipo_ServicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>[]
          }
          create: {
            args: Prisma.Tipo_ServicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          createMany: {
            args: Prisma.Tipo_ServicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Tipo_ServicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          update: {
            args: Prisma.Tipo_ServicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          deleteMany: {
            args: Prisma.Tipo_ServicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tipo_ServicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Tipo_ServicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          aggregate: {
            args: Prisma.Tipo_ServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_Servicio>
          }
          groupBy: {
            args: Prisma.Tipo_ServicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tipo_ServicioCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ServicioCountAggregateOutputType> | number
          }
        }
      }
      Servicio: {
        payload: Prisma.$ServicioPayload<ExtArgs>
        fields: Prisma.ServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          findFirst: {
            args: Prisma.ServicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          findMany: {
            args: Prisma.ServicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>[]
          }
          create: {
            args: Prisma.ServicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          createMany: {
            args: Prisma.ServicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          update: {
            args: Prisma.ServicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          deleteMany: {
            args: Prisma.ServicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          aggregate: {
            args: Prisma.ServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicio>
          }
          groupBy: {
            args: Prisma.ServicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicioCountArgs<ExtArgs>
            result: $Utils.Optional<ServicioCountAggregateOutputType> | number
          }
        }
      }
      Examen: {
        payload: Prisma.$ExamenPayload<ExtArgs>
        fields: Prisma.ExamenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          findFirst: {
            args: Prisma.ExamenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          findMany: {
            args: Prisma.ExamenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>[]
          }
          create: {
            args: Prisma.ExamenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          createMany: {
            args: Prisma.ExamenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          update: {
            args: Prisma.ExamenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          deleteMany: {
            args: Prisma.ExamenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          aggregate: {
            args: Prisma.ExamenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamen>
          }
          groupBy: {
            args: Prisma.ExamenGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamenCountArgs<ExtArgs>
            result: $Utils.Optional<ExamenCountAggregateOutputType> | number
          }
        }
      }
      Tipo_Resultado: {
        payload: Prisma.$Tipo_ResultadoPayload<ExtArgs>
        fields: Prisma.Tipo_ResultadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tipo_ResultadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tipo_ResultadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          findFirst: {
            args: Prisma.Tipo_ResultadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tipo_ResultadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          findMany: {
            args: Prisma.Tipo_ResultadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>[]
          }
          create: {
            args: Prisma.Tipo_ResultadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          createMany: {
            args: Prisma.Tipo_ResultadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Tipo_ResultadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          update: {
            args: Prisma.Tipo_ResultadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          deleteMany: {
            args: Prisma.Tipo_ResultadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tipo_ResultadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Tipo_ResultadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          aggregate: {
            args: Prisma.Tipo_ResultadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_Resultado>
          }
          groupBy: {
            args: Prisma.Tipo_ResultadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ResultadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tipo_ResultadoCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ResultadoCountAggregateOutputType> | number
          }
        }
      }
      Tipo_Examen: {
        payload: Prisma.$Tipo_ExamenPayload<ExtArgs>
        fields: Prisma.Tipo_ExamenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tipo_ExamenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tipo_ExamenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          findFirst: {
            args: Prisma.Tipo_ExamenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tipo_ExamenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          findMany: {
            args: Prisma.Tipo_ExamenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>[]
          }
          create: {
            args: Prisma.Tipo_ExamenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          createMany: {
            args: Prisma.Tipo_ExamenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Tipo_ExamenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          update: {
            args: Prisma.Tipo_ExamenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          deleteMany: {
            args: Prisma.Tipo_ExamenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tipo_ExamenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Tipo_ExamenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          aggregate: {
            args: Prisma.Tipo_ExamenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_Examen>
          }
          groupBy: {
            args: Prisma.Tipo_ExamenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ExamenGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tipo_ExamenCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ExamenCountAggregateOutputType> | number
          }
        }
      }
      Prestador: {
        payload: Prisma.$PrestadorPayload<ExtArgs>
        fields: Prisma.PrestadorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrestadorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrestadorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          findFirst: {
            args: Prisma.PrestadorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrestadorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          findMany: {
            args: Prisma.PrestadorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>[]
          }
          create: {
            args: Prisma.PrestadorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          createMany: {
            args: Prisma.PrestadorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrestadorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          update: {
            args: Prisma.PrestadorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          deleteMany: {
            args: Prisma.PrestadorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrestadorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrestadorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          aggregate: {
            args: Prisma.PrestadorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrestador>
          }
          groupBy: {
            args: Prisma.PrestadorGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrestadorGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrestadorCountArgs<ExtArgs>
            result: $Utils.Optional<PrestadorCountAggregateOutputType> | number
          }
        }
      }
      Profesional: {
        payload: Prisma.$ProfesionalPayload<ExtArgs>
        fields: Prisma.ProfesionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfesionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfesionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload>
          }
          findFirst: {
            args: Prisma.ProfesionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfesionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload>
          }
          findMany: {
            args: Prisma.ProfesionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload>[]
          }
          create: {
            args: Prisma.ProfesionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload>
          }
          createMany: {
            args: Prisma.ProfesionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProfesionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload>
          }
          update: {
            args: Prisma.ProfesionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload>
          }
          deleteMany: {
            args: Prisma.ProfesionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfesionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfesionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfesionalPayload>
          }
          aggregate: {
            args: Prisma.ProfesionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfesional>
          }
          groupBy: {
            args: Prisma.ProfesionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfesionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfesionalCountArgs<ExtArgs>
            result: $Utils.Optional<ProfesionalCountAggregateOutputType> | number
          }
        }
      }
      Empresa: {
        payload: Prisma.$EmpresaPayload<ExtArgs>
        fields: Prisma.EmpresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findFirst: {
            args: Prisma.EmpresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findMany: {
            args: Prisma.EmpresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          create: {
            args: Prisma.EmpresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          createMany: {
            args: Prisma.EmpresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmpresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          update: {
            args: Prisma.EmpresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.EmpresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      Contrato: {
        payload: Prisma.$ContratoPayload<ExtArgs>
        fields: Prisma.ContratoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContratoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContratoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          findFirst: {
            args: Prisma.ContratoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContratoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          findMany: {
            args: Prisma.ContratoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>[]
          }
          create: {
            args: Prisma.ContratoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          createMany: {
            args: Prisma.ContratoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContratoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          update: {
            args: Prisma.ContratoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          deleteMany: {
            args: Prisma.ContratoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContratoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContratoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          aggregate: {
            args: Prisma.ContratoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContrato>
          }
          groupBy: {
            args: Prisma.ContratoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContratoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContratoCountArgs<ExtArgs>
            result: $Utils.Optional<ContratoCountAggregateOutputType> | number
          }
        }
      }
      Tarifa: {
        payload: Prisma.$TarifaPayload<ExtArgs>
        fields: Prisma.TarifaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TarifaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TarifaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          findFirst: {
            args: Prisma.TarifaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TarifaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          findMany: {
            args: Prisma.TarifaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>[]
          }
          create: {
            args: Prisma.TarifaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          createMany: {
            args: Prisma.TarifaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TarifaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          update: {
            args: Prisma.TarifaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          deleteMany: {
            args: Prisma.TarifaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TarifaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TarifaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          aggregate: {
            args: Prisma.TarifaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTarifa>
          }
          groupBy: {
            args: Prisma.TarifaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TarifaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TarifaCountArgs<ExtArgs>
            result: $Utils.Optional<TarifaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    procedimiento: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | UsuarioCountOutputTypeCountProcedimientoArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
  }


  /**
   * Count Type EpsCountOutputType
   */

  export type EpsCountOutputType = {
    usuario: number
  }

  export type EpsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | EpsCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes
  /**
   * EpsCountOutputType without action
   */
  export type EpsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EpsCountOutputType
     */
    select?: EpsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EpsCountOutputType without action
   */
  export type EpsCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * Count Type Tipo_ProcedimientoCountOutputType
   */

  export type Tipo_ProcedimientoCountOutputType = {
    procedimiento: number
  }

  export type Tipo_ProcedimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Tipo_ProcedimientoCountOutputTypeCountProcedimientoArgs
  }

  // Custom InputTypes
  /**
   * Tipo_ProcedimientoCountOutputType without action
   */
  export type Tipo_ProcedimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_ProcedimientoCountOutputType
     */
    select?: Tipo_ProcedimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipo_ProcedimientoCountOutputType without action
   */
  export type Tipo_ProcedimientoCountOutputTypeCountProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
  }


  /**
   * Count Type ProcedimientoCountOutputType
   */

  export type ProcedimientoCountOutputType = {
    estudio: number
  }

  export type ProcedimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudio?: boolean | ProcedimientoCountOutputTypeCountEstudioArgs
  }

  // Custom InputTypes
  /**
   * ProcedimientoCountOutputType without action
   */
  export type ProcedimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedimientoCountOutputType
     */
    select?: ProcedimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcedimientoCountOutputType without action
   */
  export type ProcedimientoCountOutputTypeCountEstudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudioWhereInput
  }


  /**
   * Count Type DepartamentoCountOutputType
   */

  export type DepartamentoCountOutputType = {
    municipio: number
  }

  export type DepartamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | DepartamentoCountOutputTypeCountMunicipioArgs
  }

  // Custom InputTypes
  /**
   * DepartamentoCountOutputType without action
   */
  export type DepartamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartamentoCountOutputType
     */
    select?: DepartamentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartamentoCountOutputType without action
   */
  export type DepartamentoCountOutputTypeCountMunicipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipioWhereInput
  }


  /**
   * Count Type MunicipioCountOutputType
   */

  export type MunicipioCountOutputType = {
    suario: number
    empresa: number
  }

  export type MunicipioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suario?: boolean | MunicipioCountOutputTypeCountSuarioArgs
    empresa?: boolean | MunicipioCountOutputTypeCountEmpresaArgs
  }

  // Custom InputTypes
  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipioCountOutputType
     */
    select?: MunicipioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeCountSuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }

  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeCountEmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
  }


  /**
   * Count Type Tipo_ServicioCountOutputType
   */

  export type Tipo_ServicioCountOutputType = {
    servicio: number
  }

  export type Tipo_ServicioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Tipo_ServicioCountOutputTypeCountServicioArgs
  }

  // Custom InputTypes
  /**
   * Tipo_ServicioCountOutputType without action
   */
  export type Tipo_ServicioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_ServicioCountOutputType
     */
    select?: Tipo_ServicioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipo_ServicioCountOutputType without action
   */
  export type Tipo_ServicioCountOutputTypeCountServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
  }


  /**
   * Count Type ServicioCountOutputType
   */

  export type ServicioCountOutputType = {
    tarifa: number
  }

  export type ServicioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarifa?: boolean | ServicioCountOutputTypeCountTarifaArgs
  }

  // Custom InputTypes
  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioCountOutputType
     */
    select?: ServicioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountTarifaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TarifaWhereInput
  }


  /**
   * Count Type ExamenCountOutputType
   */

  export type ExamenCountOutputType = {
    tipo_resultado: number
    tarifa: number
  }

  export type ExamenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipo_resultado?: boolean | ExamenCountOutputTypeCountTipo_resultadoArgs
    tarifa?: boolean | ExamenCountOutputTypeCountTarifaArgs
  }

  // Custom InputTypes
  /**
   * ExamenCountOutputType without action
   */
  export type ExamenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenCountOutputType
     */
    select?: ExamenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamenCountOutputType without action
   */
  export type ExamenCountOutputTypeCountTipo_resultadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ResultadoWhereInput
  }

  /**
   * ExamenCountOutputType without action
   */
  export type ExamenCountOutputTypeCountTarifaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TarifaWhereInput
  }


  /**
   * Count Type Tipo_ExamenCountOutputType
   */

  export type Tipo_ExamenCountOutputType = {
    examen: number
  }

  export type Tipo_ExamenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examen?: boolean | Tipo_ExamenCountOutputTypeCountExamenArgs
  }

  // Custom InputTypes
  /**
   * Tipo_ExamenCountOutputType without action
   */
  export type Tipo_ExamenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_ExamenCountOutputType
     */
    select?: Tipo_ExamenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipo_ExamenCountOutputType without action
   */
  export type Tipo_ExamenCountOutputTypeCountExamenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamenWhereInput
  }


  /**
   * Count Type PrestadorCountOutputType
   */

  export type PrestadorCountOutputType = {
    servicio: number
    profesional: number
  }

  export type PrestadorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | PrestadorCountOutputTypeCountServicioArgs
    profesional?: boolean | PrestadorCountOutputTypeCountProfesionalArgs
  }

  // Custom InputTypes
  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorCountOutputType
     */
    select?: PrestadorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeCountServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
  }

  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeCountProfesionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfesionalWhereInput
  }


  /**
   * Count Type EmpresaCountOutputType
   */

  export type EmpresaCountOutputType = {
    contrato: number
  }

  export type EmpresaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contrato?: boolean | EmpresaCountOutputTypeCountContratoArgs
  }

  // Custom InputTypes
  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaCountOutputType
     */
    select?: EmpresaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountContratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratoWhereInput
  }


  /**
   * Count Type ContratoCountOutputType
   */

  export type ContratoCountOutputType = {
    tarifa: number
    procedimiento: number
  }

  export type ContratoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarifa?: boolean | ContratoCountOutputTypeCountTarifaArgs
    procedimiento?: boolean | ContratoCountOutputTypeCountProcedimientoArgs
  }

  // Custom InputTypes
  /**
   * ContratoCountOutputType without action
   */
  export type ContratoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratoCountOutputType
     */
    select?: ContratoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContratoCountOutputType without action
   */
  export type ContratoCountOutputTypeCountTarifaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TarifaWhereInput
  }

  /**
   * ContratoCountOutputType without action
   */
  export type ContratoCountOutputTypeCountProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
  }


  /**
   * Count Type TarifaCountOutputType
   */

  export type TarifaCountOutputType = {
    estudio: number
  }

  export type TarifaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudio?: boolean | TarifaCountOutputTypeCountEstudioArgs
  }

  // Custom InputTypes
  /**
   * TarifaCountOutputType without action
   */
  export type TarifaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TarifaCountOutputType
     */
    select?: TarifaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TarifaCountOutputType without action
   */
  export type TarifaCountOutputTypeCountEstudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudioWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id_usuario: number | null
    municipio: number | null
    eps: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id_usuario: number | null
    municipio: number | null
    eps: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id_usuario: number | null
    tipo_identificacion: $Enums.Tipo_Ident | null
    identificacion: string | null
    primer_nombre: string | null
    segundo_nombre: string | null
    primer_apellido: string | null
    segundo_apellido: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sex | null
    email: string | null
    telefono: string | null
    direccion: string | null
    tipo_usuario: $Enums.Tipo_Usuario | null
    municipio: number | null
    estado: $Enums.Estado | null
    createAt: Date | null
    updateAt: Date | null
    eps: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id_usuario: number | null
    tipo_identificacion: $Enums.Tipo_Ident | null
    identificacion: string | null
    primer_nombre: string | null
    segundo_nombre: string | null
    primer_apellido: string | null
    segundo_apellido: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sex | null
    email: string | null
    telefono: string | null
    direccion: string | null
    tipo_usuario: $Enums.Tipo_Usuario | null
    municipio: number | null
    estado: $Enums.Estado | null
    createAt: Date | null
    updateAt: Date | null
    eps: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id_usuario: number
    tipo_identificacion: number
    identificacion: number
    primer_nombre: number
    segundo_nombre: number
    primer_apellido: number
    segundo_apellido: number
    fecha_nacimiento: number
    sexo: number
    email: number
    telefono: number
    direccion: number
    tipo_usuario: number
    municipio: number
    estado: number
    createAt: number
    updateAt: number
    eps: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id_usuario?: true
    municipio?: true
    eps?: true
  }

  export type UsuarioSumAggregateInputType = {
    id_usuario?: true
    municipio?: true
    eps?: true
  }

  export type UsuarioMinAggregateInputType = {
    id_usuario?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    direccion?: true
    tipo_usuario?: true
    municipio?: true
    estado?: true
    createAt?: true
    updateAt?: true
    eps?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id_usuario?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    direccion?: true
    tipo_usuario?: true
    municipio?: true
    estado?: true
    createAt?: true
    updateAt?: true
    eps?: true
  }

  export type UsuarioCountAggregateInputType = {
    id_usuario?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    direccion?: true
    tipo_usuario?: true
    municipio?: true
    estado?: true
    createAt?: true
    updateAt?: true
    eps?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id_usuario: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre: string | null
    primer_apellido: string
    segundo_apellido: string | null
    fecha_nacimiento: Date
    sexo: $Enums.Sex
    email: string
    telefono: string | null
    direccion: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt: Date
    updateAt: Date
    eps: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    tipo_identificacion?: boolean
    identificacion?: boolean
    primer_nombre?: boolean
    segundo_nombre?: boolean
    primer_apellido?: boolean
    segundo_apellido?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    tipo_usuario?: boolean
    municipio?: boolean
    estado?: boolean
    createAt?: boolean
    updateAt?: boolean
    eps?: boolean
    procedimiento?: boolean | Usuario$procedimientoArgs<ExtArgs>
    Municipio_Usuario?: boolean | MunicipioDefaultArgs<ExtArgs>
    Eps_usuario?: boolean | EpsDefaultArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type UsuarioSelectScalar = {
    id_usuario?: boolean
    tipo_identificacion?: boolean
    identificacion?: boolean
    primer_nombre?: boolean
    segundo_nombre?: boolean
    primer_apellido?: boolean
    segundo_apellido?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    tipo_usuario?: boolean
    municipio?: boolean
    estado?: boolean
    createAt?: boolean
    updateAt?: boolean
    eps?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Usuario$procedimientoArgs<ExtArgs>
    Municipio_Usuario?: boolean | MunicipioDefaultArgs<ExtArgs>
    Eps_usuario?: boolean | EpsDefaultArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>[]
      Municipio_Usuario: Prisma.$MunicipioPayload<ExtArgs>
      Eps_usuario: Prisma.$EpsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      tipo_identificacion: $Enums.Tipo_Ident
      identificacion: string
      primer_nombre: string
      segundo_nombre: string | null
      primer_apellido: string
      segundo_apellido: string | null
      fecha_nacimiento: Date
      sexo: $Enums.Sex
      email: string
      telefono: string | null
      direccion: string | null
      tipo_usuario: $Enums.Tipo_Usuario
      municipio: number
      estado: $Enums.Estado
      createAt: Date
      updateAt: Date
      eps: number
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedimiento<T extends Usuario$procedimientoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$procedimientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany"> | Null>
    Municipio_Usuario<T extends MunicipioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipioDefaultArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Eps_usuario<T extends EpsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EpsDefaultArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id_usuario: FieldRef<"Usuario", 'Int'>
    readonly tipo_identificacion: FieldRef<"Usuario", 'Tipo_Ident'>
    readonly identificacion: FieldRef<"Usuario", 'String'>
    readonly primer_nombre: FieldRef<"Usuario", 'String'>
    readonly segundo_nombre: FieldRef<"Usuario", 'String'>
    readonly primer_apellido: FieldRef<"Usuario", 'String'>
    readonly segundo_apellido: FieldRef<"Usuario", 'String'>
    readonly fecha_nacimiento: FieldRef<"Usuario", 'DateTime'>
    readonly sexo: FieldRef<"Usuario", 'Sex'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly telefono: FieldRef<"Usuario", 'String'>
    readonly direccion: FieldRef<"Usuario", 'String'>
    readonly tipo_usuario: FieldRef<"Usuario", 'Tipo_Usuario'>
    readonly municipio: FieldRef<"Usuario", 'Int'>
    readonly estado: FieldRef<"Usuario", 'Estado'>
    readonly createAt: FieldRef<"Usuario", 'DateTime'>
    readonly updateAt: FieldRef<"Usuario", 'DateTime'>
    readonly eps: FieldRef<"Usuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.procedimiento
   */
  export type Usuario$procedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    cursor?: ProcedimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Eps
   */

  export type AggregateEps = {
    _count: EpsCountAggregateOutputType | null
    _avg: EpsAvgAggregateOutputType | null
    _sum: EpsSumAggregateOutputType | null
    _min: EpsMinAggregateOutputType | null
    _max: EpsMaxAggregateOutputType | null
  }

  export type EpsAvgAggregateOutputType = {
    id_eps: number | null
  }

  export type EpsSumAggregateOutputType = {
    id_eps: number | null
  }

  export type EpsMinAggregateOutputType = {
    id_eps: number | null
    codigo: string | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type EpsMaxAggregateOutputType = {
    id_eps: number | null
    codigo: string | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type EpsCountAggregateOutputType = {
    id_eps: number
    codigo: number
    nombre: number
    estado: number
    _all: number
  }


  export type EpsAvgAggregateInputType = {
    id_eps?: true
  }

  export type EpsSumAggregateInputType = {
    id_eps?: true
  }

  export type EpsMinAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
  }

  export type EpsMaxAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
  }

  export type EpsCountAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type EpsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eps to aggregate.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eps
    **/
    _count?: true | EpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpsMaxAggregateInputType
  }

  export type GetEpsAggregateType<T extends EpsAggregateArgs> = {
        [P in keyof T & keyof AggregateEps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEps[P]>
      : GetScalarType<T[P], AggregateEps[P]>
  }




  export type EpsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpsWhereInput
    orderBy?: EpsOrderByWithAggregationInput | EpsOrderByWithAggregationInput[]
    by: EpsScalarFieldEnum[] | EpsScalarFieldEnum
    having?: EpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpsCountAggregateInputType | true
    _avg?: EpsAvgAggregateInputType
    _sum?: EpsSumAggregateInputType
    _min?: EpsMinAggregateInputType
    _max?: EpsMaxAggregateInputType
  }

  export type EpsGroupByOutputType = {
    id_eps: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
    _count: EpsCountAggregateOutputType | null
    _avg: EpsAvgAggregateOutputType | null
    _sum: EpsSumAggregateOutputType | null
    _min: EpsMinAggregateOutputType | null
    _max: EpsMaxAggregateOutputType | null
  }

  type GetEpsGroupByPayload<T extends EpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpsGroupByOutputType[P]>
            : GetScalarType<T[P], EpsGroupByOutputType[P]>
        }
      >
    >


  export type EpsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_eps?: boolean
    codigo?: boolean
    nombre?: boolean
    estado?: boolean
    usuario?: boolean | Eps$usuarioArgs<ExtArgs>
    _count?: boolean | EpsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eps"]>


  export type EpsSelectScalar = {
    id_eps?: boolean
    codigo?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type EpsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | Eps$usuarioArgs<ExtArgs>
    _count?: boolean | EpsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EpsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Eps"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_eps: number
      codigo: string
      nombre: string
      estado: $Enums.Estado
    }, ExtArgs["result"]["eps"]>
    composites: {}
  }

  type EpsGetPayload<S extends boolean | null | undefined | EpsDefaultArgs> = $Result.GetResult<Prisma.$EpsPayload, S>

  type EpsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EpsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EpsCountAggregateInputType | true
    }

  export interface EpsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Eps'], meta: { name: 'Eps' } }
    /**
     * Find zero or one Eps that matches the filter.
     * @param {EpsFindUniqueArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EpsFindUniqueArgs>(args: SelectSubset<T, EpsFindUniqueArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Eps that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EpsFindUniqueOrThrowArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EpsFindUniqueOrThrowArgs>(args: SelectSubset<T, EpsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Eps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindFirstArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EpsFindFirstArgs>(args?: SelectSubset<T, EpsFindFirstArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Eps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindFirstOrThrowArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EpsFindFirstOrThrowArgs>(args?: SelectSubset<T, EpsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eps
     * const eps = await prisma.eps.findMany()
     * 
     * // Get first 10 Eps
     * const eps = await prisma.eps.findMany({ take: 10 })
     * 
     * // Only select the `id_eps`
     * const epsWithId_epsOnly = await prisma.eps.findMany({ select: { id_eps: true } })
     * 
     */
    findMany<T extends EpsFindManyArgs>(args?: SelectSubset<T, EpsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Eps.
     * @param {EpsCreateArgs} args - Arguments to create a Eps.
     * @example
     * // Create one Eps
     * const Eps = await prisma.eps.create({
     *   data: {
     *     // ... data to create a Eps
     *   }
     * })
     * 
     */
    create<T extends EpsCreateArgs>(args: SelectSubset<T, EpsCreateArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eps.
     * @param {EpsCreateManyArgs} args - Arguments to create many Eps.
     * @example
     * // Create many Eps
     * const eps = await prisma.eps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EpsCreateManyArgs>(args?: SelectSubset<T, EpsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Eps.
     * @param {EpsDeleteArgs} args - Arguments to delete one Eps.
     * @example
     * // Delete one Eps
     * const Eps = await prisma.eps.delete({
     *   where: {
     *     // ... filter to delete one Eps
     *   }
     * })
     * 
     */
    delete<T extends EpsDeleteArgs>(args: SelectSubset<T, EpsDeleteArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Eps.
     * @param {EpsUpdateArgs} args - Arguments to update one Eps.
     * @example
     * // Update one Eps
     * const eps = await prisma.eps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EpsUpdateArgs>(args: SelectSubset<T, EpsUpdateArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eps.
     * @param {EpsDeleteManyArgs} args - Arguments to filter Eps to delete.
     * @example
     * // Delete a few Eps
     * const { count } = await prisma.eps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EpsDeleteManyArgs>(args?: SelectSubset<T, EpsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eps
     * const eps = await prisma.eps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EpsUpdateManyArgs>(args: SelectSubset<T, EpsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eps.
     * @param {EpsUpsertArgs} args - Arguments to update or create a Eps.
     * @example
     * // Update or create a Eps
     * const eps = await prisma.eps.upsert({
     *   create: {
     *     // ... data to create a Eps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eps we want to update
     *   }
     * })
     */
    upsert<T extends EpsUpsertArgs>(args: SelectSubset<T, EpsUpsertArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsCountArgs} args - Arguments to filter Eps to count.
     * @example
     * // Count the number of Eps
     * const count = await prisma.eps.count({
     *   where: {
     *     // ... the filter for the Eps we want to count
     *   }
     * })
    **/
    count<T extends EpsCountArgs>(
      args?: Subset<T, EpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpsAggregateArgs>(args: Subset<T, EpsAggregateArgs>): Prisma.PrismaPromise<GetEpsAggregateType<T>>

    /**
     * Group by Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EpsGroupByArgs['orderBy'] }
        : { orderBy?: EpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Eps model
   */
  readonly fields: EpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Eps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EpsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends Eps$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Eps$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Eps model
   */ 
  interface EpsFieldRefs {
    readonly id_eps: FieldRef<"Eps", 'Int'>
    readonly codigo: FieldRef<"Eps", 'String'>
    readonly nombre: FieldRef<"Eps", 'String'>
    readonly estado: FieldRef<"Eps", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Eps findUnique
   */
  export type EpsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps findUniqueOrThrow
   */
  export type EpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps findFirst
   */
  export type EpsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eps.
     */
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps findFirstOrThrow
   */
  export type EpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eps.
     */
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps findMany
   */
  export type EpsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps create
   */
  export type EpsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The data needed to create a Eps.
     */
    data: XOR<EpsCreateInput, EpsUncheckedCreateInput>
  }

  /**
   * Eps createMany
   */
  export type EpsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eps.
     */
    data: EpsCreateManyInput | EpsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Eps update
   */
  export type EpsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The data needed to update a Eps.
     */
    data: XOR<EpsUpdateInput, EpsUncheckedUpdateInput>
    /**
     * Choose, which Eps to update.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps updateMany
   */
  export type EpsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eps.
     */
    data: XOR<EpsUpdateManyMutationInput, EpsUncheckedUpdateManyInput>
    /**
     * Filter which Eps to update
     */
    where?: EpsWhereInput
  }

  /**
   * Eps upsert
   */
  export type EpsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The filter to search for the Eps to update in case it exists.
     */
    where: EpsWhereUniqueInput
    /**
     * In case the Eps found by the `where` argument doesn't exist, create a new Eps with this data.
     */
    create: XOR<EpsCreateInput, EpsUncheckedCreateInput>
    /**
     * In case the Eps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EpsUpdateInput, EpsUncheckedUpdateInput>
  }

  /**
   * Eps delete
   */
  export type EpsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter which Eps to delete.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps deleteMany
   */
  export type EpsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eps to delete
     */
    where?: EpsWhereInput
  }

  /**
   * Eps.usuario
   */
  export type Eps$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Eps without action
   */
  export type EpsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
  }


  /**
   * Model Tipo_Procedimiento
   */

  export type AggregateTipo_Procedimiento = {
    _count: Tipo_ProcedimientoCountAggregateOutputType | null
    _avg: Tipo_ProcedimientoAvgAggregateOutputType | null
    _sum: Tipo_ProcedimientoSumAggregateOutputType | null
    _min: Tipo_ProcedimientoMinAggregateOutputType | null
    _max: Tipo_ProcedimientoMaxAggregateOutputType | null
  }

  export type Tipo_ProcedimientoAvgAggregateOutputType = {
    id_tipo_procedimiento: number | null
  }

  export type Tipo_ProcedimientoSumAggregateOutputType = {
    id_tipo_procedimiento: number | null
  }

  export type Tipo_ProcedimientoMinAggregateOutputType = {
    id_tipo_procedimiento: number | null
    nombre: string | null
  }

  export type Tipo_ProcedimientoMaxAggregateOutputType = {
    id_tipo_procedimiento: number | null
    nombre: string | null
  }

  export type Tipo_ProcedimientoCountAggregateOutputType = {
    id_tipo_procedimiento: number
    nombre: number
    _all: number
  }


  export type Tipo_ProcedimientoAvgAggregateInputType = {
    id_tipo_procedimiento?: true
  }

  export type Tipo_ProcedimientoSumAggregateInputType = {
    id_tipo_procedimiento?: true
  }

  export type Tipo_ProcedimientoMinAggregateInputType = {
    id_tipo_procedimiento?: true
    nombre?: true
  }

  export type Tipo_ProcedimientoMaxAggregateInputType = {
    id_tipo_procedimiento?: true
    nombre?: true
  }

  export type Tipo_ProcedimientoCountAggregateInputType = {
    id_tipo_procedimiento?: true
    nombre?: true
    _all?: true
  }

  export type Tipo_ProcedimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Procedimiento to aggregate.
     */
    where?: Tipo_ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Procedimientos to fetch.
     */
    orderBy?: Tipo_ProcedimientoOrderByWithRelationInput | Tipo_ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tipo_ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipo_Procedimientos
    **/
    _count?: true | Tipo_ProcedimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_ProcedimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_ProcedimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_ProcedimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_ProcedimientoMaxAggregateInputType
  }

  export type GetTipo_ProcedimientoAggregateType<T extends Tipo_ProcedimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_Procedimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_Procedimiento[P]>
      : GetScalarType<T[P], AggregateTipo_Procedimiento[P]>
  }




  export type Tipo_ProcedimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ProcedimientoWhereInput
    orderBy?: Tipo_ProcedimientoOrderByWithAggregationInput | Tipo_ProcedimientoOrderByWithAggregationInput[]
    by: Tipo_ProcedimientoScalarFieldEnum[] | Tipo_ProcedimientoScalarFieldEnum
    having?: Tipo_ProcedimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_ProcedimientoCountAggregateInputType | true
    _avg?: Tipo_ProcedimientoAvgAggregateInputType
    _sum?: Tipo_ProcedimientoSumAggregateInputType
    _min?: Tipo_ProcedimientoMinAggregateInputType
    _max?: Tipo_ProcedimientoMaxAggregateInputType
  }

  export type Tipo_ProcedimientoGroupByOutputType = {
    id_tipo_procedimiento: number
    nombre: string
    _count: Tipo_ProcedimientoCountAggregateOutputType | null
    _avg: Tipo_ProcedimientoAvgAggregateOutputType | null
    _sum: Tipo_ProcedimientoSumAggregateOutputType | null
    _min: Tipo_ProcedimientoMinAggregateOutputType | null
    _max: Tipo_ProcedimientoMaxAggregateOutputType | null
  }

  type GetTipo_ProcedimientoGroupByPayload<T extends Tipo_ProcedimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_ProcedimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_ProcedimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_ProcedimientoGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_ProcedimientoGroupByOutputType[P]>
        }
      >
    >


  export type Tipo_ProcedimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_procedimiento?: boolean
    nombre?: boolean
    procedimiento?: boolean | Tipo_Procedimiento$procedimientoArgs<ExtArgs>
    _count?: boolean | Tipo_ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_Procedimiento"]>


  export type Tipo_ProcedimientoSelectScalar = {
    id_tipo_procedimiento?: boolean
    nombre?: boolean
  }

  export type Tipo_ProcedimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Tipo_Procedimiento$procedimientoArgs<ExtArgs>
    _count?: boolean | Tipo_ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Tipo_ProcedimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tipo_Procedimiento"
    objects: {
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_procedimiento: number
      nombre: string
    }, ExtArgs["result"]["tipo_Procedimiento"]>
    composites: {}
  }

  type Tipo_ProcedimientoGetPayload<S extends boolean | null | undefined | Tipo_ProcedimientoDefaultArgs> = $Result.GetResult<Prisma.$Tipo_ProcedimientoPayload, S>

  type Tipo_ProcedimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tipo_ProcedimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_ProcedimientoCountAggregateInputType | true
    }

  export interface Tipo_ProcedimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tipo_Procedimiento'], meta: { name: 'Tipo_Procedimiento' } }
    /**
     * Find zero or one Tipo_Procedimiento that matches the filter.
     * @param {Tipo_ProcedimientoFindUniqueArgs} args - Arguments to find a Tipo_Procedimiento
     * @example
     * // Get one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tipo_ProcedimientoFindUniqueArgs>(args: SelectSubset<T, Tipo_ProcedimientoFindUniqueArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_Procedimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Tipo_ProcedimientoFindUniqueOrThrowArgs} args - Arguments to find a Tipo_Procedimiento
     * @example
     * // Get one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tipo_ProcedimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, Tipo_ProcedimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_Procedimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoFindFirstArgs} args - Arguments to find a Tipo_Procedimiento
     * @example
     * // Get one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tipo_ProcedimientoFindFirstArgs>(args?: SelectSubset<T, Tipo_ProcedimientoFindFirstArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_Procedimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoFindFirstOrThrowArgs} args - Arguments to find a Tipo_Procedimiento
     * @example
     * // Get one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tipo_ProcedimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, Tipo_ProcedimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_Procedimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_Procedimientos
     * const tipo_Procedimientos = await prisma.tipo_Procedimiento.findMany()
     * 
     * // Get first 10 Tipo_Procedimientos
     * const tipo_Procedimientos = await prisma.tipo_Procedimiento.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_procedimiento`
     * const tipo_ProcedimientoWithId_tipo_procedimientoOnly = await prisma.tipo_Procedimiento.findMany({ select: { id_tipo_procedimiento: true } })
     * 
     */
    findMany<T extends Tipo_ProcedimientoFindManyArgs>(args?: SelectSubset<T, Tipo_ProcedimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_Procedimiento.
     * @param {Tipo_ProcedimientoCreateArgs} args - Arguments to create a Tipo_Procedimiento.
     * @example
     * // Create one Tipo_Procedimiento
     * const Tipo_Procedimiento = await prisma.tipo_Procedimiento.create({
     *   data: {
     *     // ... data to create a Tipo_Procedimiento
     *   }
     * })
     * 
     */
    create<T extends Tipo_ProcedimientoCreateArgs>(args: SelectSubset<T, Tipo_ProcedimientoCreateArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_Procedimientos.
     * @param {Tipo_ProcedimientoCreateManyArgs} args - Arguments to create many Tipo_Procedimientos.
     * @example
     * // Create many Tipo_Procedimientos
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tipo_ProcedimientoCreateManyArgs>(args?: SelectSubset<T, Tipo_ProcedimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_Procedimiento.
     * @param {Tipo_ProcedimientoDeleteArgs} args - Arguments to delete one Tipo_Procedimiento.
     * @example
     * // Delete one Tipo_Procedimiento
     * const Tipo_Procedimiento = await prisma.tipo_Procedimiento.delete({
     *   where: {
     *     // ... filter to delete one Tipo_Procedimiento
     *   }
     * })
     * 
     */
    delete<T extends Tipo_ProcedimientoDeleteArgs>(args: SelectSubset<T, Tipo_ProcedimientoDeleteArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_Procedimiento.
     * @param {Tipo_ProcedimientoUpdateArgs} args - Arguments to update one Tipo_Procedimiento.
     * @example
     * // Update one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tipo_ProcedimientoUpdateArgs>(args: SelectSubset<T, Tipo_ProcedimientoUpdateArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_Procedimientos.
     * @param {Tipo_ProcedimientoDeleteManyArgs} args - Arguments to filter Tipo_Procedimientos to delete.
     * @example
     * // Delete a few Tipo_Procedimientos
     * const { count } = await prisma.tipo_Procedimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tipo_ProcedimientoDeleteManyArgs>(args?: SelectSubset<T, Tipo_ProcedimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_Procedimientos
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tipo_ProcedimientoUpdateManyArgs>(args: SelectSubset<T, Tipo_ProcedimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_Procedimiento.
     * @param {Tipo_ProcedimientoUpsertArgs} args - Arguments to update or create a Tipo_Procedimiento.
     * @example
     * // Update or create a Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.upsert({
     *   create: {
     *     // ... data to create a Tipo_Procedimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_Procedimiento we want to update
     *   }
     * })
     */
    upsert<T extends Tipo_ProcedimientoUpsertArgs>(args: SelectSubset<T, Tipo_ProcedimientoUpsertArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoCountArgs} args - Arguments to filter Tipo_Procedimientos to count.
     * @example
     * // Count the number of Tipo_Procedimientos
     * const count = await prisma.tipo_Procedimiento.count({
     *   where: {
     *     // ... the filter for the Tipo_Procedimientos we want to count
     *   }
     * })
    **/
    count<T extends Tipo_ProcedimientoCountArgs>(
      args?: Subset<T, Tipo_ProcedimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_ProcedimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_ProcedimientoAggregateArgs>(args: Subset<T, Tipo_ProcedimientoAggregateArgs>): Prisma.PrismaPromise<GetTipo_ProcedimientoAggregateType<T>>

    /**
     * Group by Tipo_Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_ProcedimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_ProcedimientoGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_ProcedimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_ProcedimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_ProcedimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tipo_Procedimiento model
   */
  readonly fields: Tipo_ProcedimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo_Procedimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tipo_ProcedimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedimiento<T extends Tipo_Procedimiento$procedimientoArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_Procedimiento$procedimientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tipo_Procedimiento model
   */ 
  interface Tipo_ProcedimientoFieldRefs {
    readonly id_tipo_procedimiento: FieldRef<"Tipo_Procedimiento", 'Int'>
    readonly nombre: FieldRef<"Tipo_Procedimiento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tipo_Procedimiento findUnique
   */
  export type Tipo_ProcedimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimiento to fetch.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
  }

  /**
   * Tipo_Procedimiento findUniqueOrThrow
   */
  export type Tipo_ProcedimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimiento to fetch.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
  }

  /**
   * Tipo_Procedimiento findFirst
   */
  export type Tipo_ProcedimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimiento to fetch.
     */
    where?: Tipo_ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Procedimientos to fetch.
     */
    orderBy?: Tipo_ProcedimientoOrderByWithRelationInput | Tipo_ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Procedimientos.
     */
    cursor?: Tipo_ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Procedimientos.
     */
    distinct?: Tipo_ProcedimientoScalarFieldEnum | Tipo_ProcedimientoScalarFieldEnum[]
  }

  /**
   * Tipo_Procedimiento findFirstOrThrow
   */
  export type Tipo_ProcedimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimiento to fetch.
     */
    where?: Tipo_ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Procedimientos to fetch.
     */
    orderBy?: Tipo_ProcedimientoOrderByWithRelationInput | Tipo_ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Procedimientos.
     */
    cursor?: Tipo_ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Procedimientos.
     */
    distinct?: Tipo_ProcedimientoScalarFieldEnum | Tipo_ProcedimientoScalarFieldEnum[]
  }

  /**
   * Tipo_Procedimiento findMany
   */
  export type Tipo_ProcedimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimientos to fetch.
     */
    where?: Tipo_ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Procedimientos to fetch.
     */
    orderBy?: Tipo_ProcedimientoOrderByWithRelationInput | Tipo_ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipo_Procedimientos.
     */
    cursor?: Tipo_ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Procedimientos.
     */
    skip?: number
    distinct?: Tipo_ProcedimientoScalarFieldEnum | Tipo_ProcedimientoScalarFieldEnum[]
  }

  /**
   * Tipo_Procedimiento create
   */
  export type Tipo_ProcedimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Tipo_Procedimiento.
     */
    data: XOR<Tipo_ProcedimientoCreateInput, Tipo_ProcedimientoUncheckedCreateInput>
  }

  /**
   * Tipo_Procedimiento createMany
   */
  export type Tipo_ProcedimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tipo_Procedimientos.
     */
    data: Tipo_ProcedimientoCreateManyInput | Tipo_ProcedimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tipo_Procedimiento update
   */
  export type Tipo_ProcedimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Tipo_Procedimiento.
     */
    data: XOR<Tipo_ProcedimientoUpdateInput, Tipo_ProcedimientoUncheckedUpdateInput>
    /**
     * Choose, which Tipo_Procedimiento to update.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
  }

  /**
   * Tipo_Procedimiento updateMany
   */
  export type Tipo_ProcedimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tipo_Procedimientos.
     */
    data: XOR<Tipo_ProcedimientoUpdateManyMutationInput, Tipo_ProcedimientoUncheckedUpdateManyInput>
    /**
     * Filter which Tipo_Procedimientos to update
     */
    where?: Tipo_ProcedimientoWhereInput
  }

  /**
   * Tipo_Procedimiento upsert
   */
  export type Tipo_ProcedimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Tipo_Procedimiento to update in case it exists.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
    /**
     * In case the Tipo_Procedimiento found by the `where` argument doesn't exist, create a new Tipo_Procedimiento with this data.
     */
    create: XOR<Tipo_ProcedimientoCreateInput, Tipo_ProcedimientoUncheckedCreateInput>
    /**
     * In case the Tipo_Procedimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tipo_ProcedimientoUpdateInput, Tipo_ProcedimientoUncheckedUpdateInput>
  }

  /**
   * Tipo_Procedimiento delete
   */
  export type Tipo_ProcedimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter which Tipo_Procedimiento to delete.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
  }

  /**
   * Tipo_Procedimiento deleteMany
   */
  export type Tipo_ProcedimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Procedimientos to delete
     */
    where?: Tipo_ProcedimientoWhereInput
  }

  /**
   * Tipo_Procedimiento.procedimiento
   */
  export type Tipo_Procedimiento$procedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    cursor?: ProcedimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Tipo_Procedimiento without action
   */
  export type Tipo_ProcedimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
  }


  /**
   * Model Procedimiento
   */

  export type AggregateProcedimiento = {
    _count: ProcedimientoCountAggregateOutputType | null
    _avg: ProcedimientoAvgAggregateOutputType | null
    _sum: ProcedimientoSumAggregateOutputType | null
    _min: ProcedimientoMinAggregateOutputType | null
    _max: ProcedimientoMaxAggregateOutputType | null
  }

  export type ProcedimientoAvgAggregateOutputType = {
    id_procedimiento: number | null
    factura: number | null
    contrato: number | null
    tipo_procedimiento: number | null
    usuario: number | null
  }

  export type ProcedimientoSumAggregateOutputType = {
    id_procedimiento: number | null
    factura: number | null
    contrato: number | null
    tipo_procedimiento: number | null
    usuario: number | null
  }

  export type ProcedimientoMinAggregateOutputType = {
    id_procedimiento: number | null
    factura: number | null
    fecha: Date | null
    edad_persona: string | null
    createAt: Date | null
    updateAt: Date | null
    contrato: number | null
    tipo_procedimiento: number | null
    usuario: number | null
  }

  export type ProcedimientoMaxAggregateOutputType = {
    id_procedimiento: number | null
    factura: number | null
    fecha: Date | null
    edad_persona: string | null
    createAt: Date | null
    updateAt: Date | null
    contrato: number | null
    tipo_procedimiento: number | null
    usuario: number | null
  }

  export type ProcedimientoCountAggregateOutputType = {
    id_procedimiento: number
    factura: number
    fecha: number
    edad_persona: number
    createAt: number
    updateAt: number
    contrato: number
    tipo_procedimiento: number
    usuario: number
    _all: number
  }


  export type ProcedimientoAvgAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    contrato?: true
    tipo_procedimiento?: true
    usuario?: true
  }

  export type ProcedimientoSumAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    contrato?: true
    tipo_procedimiento?: true
    usuario?: true
  }

  export type ProcedimientoMinAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    fecha?: true
    edad_persona?: true
    createAt?: true
    updateAt?: true
    contrato?: true
    tipo_procedimiento?: true
    usuario?: true
  }

  export type ProcedimientoMaxAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    fecha?: true
    edad_persona?: true
    createAt?: true
    updateAt?: true
    contrato?: true
    tipo_procedimiento?: true
    usuario?: true
  }

  export type ProcedimientoCountAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    fecha?: true
    edad_persona?: true
    createAt?: true
    updateAt?: true
    contrato?: true
    tipo_procedimiento?: true
    usuario?: true
    _all?: true
  }

  export type ProcedimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedimiento to aggregate.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procedimientos
    **/
    _count?: true | ProcedimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcedimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcedimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedimientoMaxAggregateInputType
  }

  export type GetProcedimientoAggregateType<T extends ProcedimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedimiento[P]>
      : GetScalarType<T[P], AggregateProcedimiento[P]>
  }




  export type ProcedimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithAggregationInput | ProcedimientoOrderByWithAggregationInput[]
    by: ProcedimientoScalarFieldEnum[] | ProcedimientoScalarFieldEnum
    having?: ProcedimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedimientoCountAggregateInputType | true
    _avg?: ProcedimientoAvgAggregateInputType
    _sum?: ProcedimientoSumAggregateInputType
    _min?: ProcedimientoMinAggregateInputType
    _max?: ProcedimientoMaxAggregateInputType
  }

  export type ProcedimientoGroupByOutputType = {
    id_procedimiento: number
    factura: number
    fecha: Date
    edad_persona: string
    createAt: Date
    updateAt: Date
    contrato: number
    tipo_procedimiento: number
    usuario: number
    _count: ProcedimientoCountAggregateOutputType | null
    _avg: ProcedimientoAvgAggregateOutputType | null
    _sum: ProcedimientoSumAggregateOutputType | null
    _min: ProcedimientoMinAggregateOutputType | null
    _max: ProcedimientoMaxAggregateOutputType | null
  }

  type GetProcedimientoGroupByPayload<T extends ProcedimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedimientoGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedimientoGroupByOutputType[P]>
        }
      >
    >


  export type ProcedimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_procedimiento?: boolean
    factura?: boolean
    fecha?: boolean
    edad_persona?: boolean
    createAt?: boolean
    updateAt?: boolean
    contrato?: boolean
    tipo_procedimiento?: boolean
    usuario?: boolean
    estudio?: boolean | Procedimiento$estudioArgs<ExtArgs>
    Procedimeinto_Contrato?: boolean | ContratoDefaultArgs<ExtArgs>
    Tipo_Procedimiento_Procedimiento?: boolean | Tipo_ProcedimientoDefaultArgs<ExtArgs>
    Procedimiento_Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    _count?: boolean | ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedimiento"]>


  export type ProcedimientoSelectScalar = {
    id_procedimiento?: boolean
    factura?: boolean
    fecha?: boolean
    edad_persona?: boolean
    createAt?: boolean
    updateAt?: boolean
    contrato?: boolean
    tipo_procedimiento?: boolean
    usuario?: boolean
  }

  export type ProcedimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudio?: boolean | Procedimiento$estudioArgs<ExtArgs>
    Procedimeinto_Contrato?: boolean | ContratoDefaultArgs<ExtArgs>
    Tipo_Procedimiento_Procedimiento?: boolean | Tipo_ProcedimientoDefaultArgs<ExtArgs>
    Procedimiento_Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    _count?: boolean | ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProcedimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Procedimiento"
    objects: {
      estudio: Prisma.$EstudioPayload<ExtArgs>[]
      Procedimeinto_Contrato: Prisma.$ContratoPayload<ExtArgs>
      Tipo_Procedimiento_Procedimiento: Prisma.$Tipo_ProcedimientoPayload<ExtArgs>
      Procedimiento_Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_procedimiento: number
      factura: number
      fecha: Date
      edad_persona: string
      createAt: Date
      updateAt: Date
      contrato: number
      tipo_procedimiento: number
      usuario: number
    }, ExtArgs["result"]["procedimiento"]>
    composites: {}
  }

  type ProcedimientoGetPayload<S extends boolean | null | undefined | ProcedimientoDefaultArgs> = $Result.GetResult<Prisma.$ProcedimientoPayload, S>

  type ProcedimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcedimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcedimientoCountAggregateInputType | true
    }

  export interface ProcedimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Procedimiento'], meta: { name: 'Procedimiento' } }
    /**
     * Find zero or one Procedimiento that matches the filter.
     * @param {ProcedimientoFindUniqueArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedimientoFindUniqueArgs>(args: SelectSubset<T, ProcedimientoFindUniqueArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Procedimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcedimientoFindUniqueOrThrowArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Procedimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindFirstArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedimientoFindFirstArgs>(args?: SelectSubset<T, ProcedimientoFindFirstArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Procedimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindFirstOrThrowArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procedimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedimientos
     * const procedimientos = await prisma.procedimiento.findMany()
     * 
     * // Get first 10 Procedimientos
     * const procedimientos = await prisma.procedimiento.findMany({ take: 10 })
     * 
     * // Only select the `id_procedimiento`
     * const procedimientoWithId_procedimientoOnly = await prisma.procedimiento.findMany({ select: { id_procedimiento: true } })
     * 
     */
    findMany<T extends ProcedimientoFindManyArgs>(args?: SelectSubset<T, ProcedimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Procedimiento.
     * @param {ProcedimientoCreateArgs} args - Arguments to create a Procedimiento.
     * @example
     * // Create one Procedimiento
     * const Procedimiento = await prisma.procedimiento.create({
     *   data: {
     *     // ... data to create a Procedimiento
     *   }
     * })
     * 
     */
    create<T extends ProcedimientoCreateArgs>(args: SelectSubset<T, ProcedimientoCreateArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procedimientos.
     * @param {ProcedimientoCreateManyArgs} args - Arguments to create many Procedimientos.
     * @example
     * // Create many Procedimientos
     * const procedimiento = await prisma.procedimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedimientoCreateManyArgs>(args?: SelectSubset<T, ProcedimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Procedimiento.
     * @param {ProcedimientoDeleteArgs} args - Arguments to delete one Procedimiento.
     * @example
     * // Delete one Procedimiento
     * const Procedimiento = await prisma.procedimiento.delete({
     *   where: {
     *     // ... filter to delete one Procedimiento
     *   }
     * })
     * 
     */
    delete<T extends ProcedimientoDeleteArgs>(args: SelectSubset<T, ProcedimientoDeleteArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Procedimiento.
     * @param {ProcedimientoUpdateArgs} args - Arguments to update one Procedimiento.
     * @example
     * // Update one Procedimiento
     * const procedimiento = await prisma.procedimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedimientoUpdateArgs>(args: SelectSubset<T, ProcedimientoUpdateArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procedimientos.
     * @param {ProcedimientoDeleteManyArgs} args - Arguments to filter Procedimientos to delete.
     * @example
     * // Delete a few Procedimientos
     * const { count } = await prisma.procedimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedimientoDeleteManyArgs>(args?: SelectSubset<T, ProcedimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedimientos
     * const procedimiento = await prisma.procedimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedimientoUpdateManyArgs>(args: SelectSubset<T, ProcedimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Procedimiento.
     * @param {ProcedimientoUpsertArgs} args - Arguments to update or create a Procedimiento.
     * @example
     * // Update or create a Procedimiento
     * const procedimiento = await prisma.procedimiento.upsert({
     *   create: {
     *     // ... data to create a Procedimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedimiento we want to update
     *   }
     * })
     */
    upsert<T extends ProcedimientoUpsertArgs>(args: SelectSubset<T, ProcedimientoUpsertArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoCountArgs} args - Arguments to filter Procedimientos to count.
     * @example
     * // Count the number of Procedimientos
     * const count = await prisma.procedimiento.count({
     *   where: {
     *     // ... the filter for the Procedimientos we want to count
     *   }
     * })
    **/
    count<T extends ProcedimientoCountArgs>(
      args?: Subset<T, ProcedimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedimientoAggregateArgs>(args: Subset<T, ProcedimientoAggregateArgs>): Prisma.PrismaPromise<GetProcedimientoAggregateType<T>>

    /**
     * Group by Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedimientoGroupByArgs['orderBy'] }
        : { orderBy?: ProcedimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Procedimiento model
   */
  readonly fields: ProcedimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Procedimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudio<T extends Procedimiento$estudioArgs<ExtArgs> = {}>(args?: Subset<T, Procedimiento$estudioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findMany"> | Null>
    Procedimeinto_Contrato<T extends ContratoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContratoDefaultArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tipo_Procedimiento_Procedimiento<T extends Tipo_ProcedimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_ProcedimientoDefaultArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Procedimiento_Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Procedimiento model
   */ 
  interface ProcedimientoFieldRefs {
    readonly id_procedimiento: FieldRef<"Procedimiento", 'Int'>
    readonly factura: FieldRef<"Procedimiento", 'Int'>
    readonly fecha: FieldRef<"Procedimiento", 'DateTime'>
    readonly edad_persona: FieldRef<"Procedimiento", 'String'>
    readonly createAt: FieldRef<"Procedimiento", 'DateTime'>
    readonly updateAt: FieldRef<"Procedimiento", 'DateTime'>
    readonly contrato: FieldRef<"Procedimiento", 'Int'>
    readonly tipo_procedimiento: FieldRef<"Procedimiento", 'Int'>
    readonly usuario: FieldRef<"Procedimiento", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Procedimiento findUnique
   */
  export type ProcedimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento findUniqueOrThrow
   */
  export type ProcedimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento findFirst
   */
  export type ProcedimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedimientos.
     */
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento findFirstOrThrow
   */
  export type ProcedimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedimientos.
     */
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento findMany
   */
  export type ProcedimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimientos to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento create
   */
  export type ProcedimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Procedimiento.
     */
    data: XOR<ProcedimientoCreateInput, ProcedimientoUncheckedCreateInput>
  }

  /**
   * Procedimiento createMany
   */
  export type ProcedimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procedimientos.
     */
    data: ProcedimientoCreateManyInput | ProcedimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedimiento update
   */
  export type ProcedimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Procedimiento.
     */
    data: XOR<ProcedimientoUpdateInput, ProcedimientoUncheckedUpdateInput>
    /**
     * Choose, which Procedimiento to update.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento updateMany
   */
  export type ProcedimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procedimientos.
     */
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyInput>
    /**
     * Filter which Procedimientos to update
     */
    where?: ProcedimientoWhereInput
  }

  /**
   * Procedimiento upsert
   */
  export type ProcedimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Procedimiento to update in case it exists.
     */
    where: ProcedimientoWhereUniqueInput
    /**
     * In case the Procedimiento found by the `where` argument doesn't exist, create a new Procedimiento with this data.
     */
    create: XOR<ProcedimientoCreateInput, ProcedimientoUncheckedCreateInput>
    /**
     * In case the Procedimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedimientoUpdateInput, ProcedimientoUncheckedUpdateInput>
  }

  /**
   * Procedimiento delete
   */
  export type ProcedimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter which Procedimiento to delete.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento deleteMany
   */
  export type ProcedimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedimientos to delete
     */
    where?: ProcedimientoWhereInput
  }

  /**
   * Procedimiento.estudio
   */
  export type Procedimiento$estudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    where?: EstudioWhereInput
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    cursor?: EstudioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Procedimiento without action
   */
  export type ProcedimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
  }


  /**
   * Model Estudio
   */

  export type AggregateEstudio = {
    _count: EstudioCountAggregateOutputType | null
    _avg: EstudioAvgAggregateOutputType | null
    _sum: EstudioSumAggregateOutputType | null
    _min: EstudioMinAggregateOutputType | null
    _max: EstudioMaxAggregateOutputType | null
  }

  export type EstudioAvgAggregateOutputType = {
    id_estudio: number | null
    consecutivo: number | null
    cantidad: number | null
    profesional: number | null
    tarifa: number | null
    procedimiento: number | null
  }

  export type EstudioSumAggregateOutputType = {
    id_estudio: number | null
    consecutivo: number | null
    cantidad: number | null
    profesional: number | null
    tarifa: number | null
    procedimiento: number | null
  }

  export type EstudioMinAggregateOutputType = {
    id_estudio: number | null
    consecutivo: number | null
    cantidad: number | null
    fecha_muestra: Date | null
    fecha_resultado: Date | null
    resultado: string | null
    observacion: string | null
    profesional: number | null
    tarifa: number | null
    procedimiento: number | null
  }

  export type EstudioMaxAggregateOutputType = {
    id_estudio: number | null
    consecutivo: number | null
    cantidad: number | null
    fecha_muestra: Date | null
    fecha_resultado: Date | null
    resultado: string | null
    observacion: string | null
    profesional: number | null
    tarifa: number | null
    procedimiento: number | null
  }

  export type EstudioCountAggregateOutputType = {
    id_estudio: number
    consecutivo: number
    cantidad: number
    fecha_muestra: number
    fecha_resultado: number
    resultado: number
    observacion: number
    profesional: number
    tarifa: number
    procedimiento: number
    _all: number
  }


  export type EstudioAvgAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    profesional?: true
    tarifa?: true
    procedimiento?: true
  }

  export type EstudioSumAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    profesional?: true
    tarifa?: true
    procedimiento?: true
  }

  export type EstudioMinAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    fecha_muestra?: true
    fecha_resultado?: true
    resultado?: true
    observacion?: true
    profesional?: true
    tarifa?: true
    procedimiento?: true
  }

  export type EstudioMaxAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    fecha_muestra?: true
    fecha_resultado?: true
    resultado?: true
    observacion?: true
    profesional?: true
    tarifa?: true
    procedimiento?: true
  }

  export type EstudioCountAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    fecha_muestra?: true
    fecha_resultado?: true
    resultado?: true
    observacion?: true
    profesional?: true
    tarifa?: true
    procedimiento?: true
    _all?: true
  }

  export type EstudioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudio to aggregate.
     */
    where?: EstudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudios to fetch.
     */
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estudios
    **/
    _count?: true | EstudioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudioMaxAggregateInputType
  }

  export type GetEstudioAggregateType<T extends EstudioAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudio[P]>
      : GetScalarType<T[P], AggregateEstudio[P]>
  }




  export type EstudioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudioWhereInput
    orderBy?: EstudioOrderByWithAggregationInput | EstudioOrderByWithAggregationInput[]
    by: EstudioScalarFieldEnum[] | EstudioScalarFieldEnum
    having?: EstudioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudioCountAggregateInputType | true
    _avg?: EstudioAvgAggregateInputType
    _sum?: EstudioSumAggregateInputType
    _min?: EstudioMinAggregateInputType
    _max?: EstudioMaxAggregateInputType
  }

  export type EstudioGroupByOutputType = {
    id_estudio: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date
    fecha_resultado: Date
    resultado: string
    observacion: string
    profesional: number
    tarifa: number
    procedimiento: number
    _count: EstudioCountAggregateOutputType | null
    _avg: EstudioAvgAggregateOutputType | null
    _sum: EstudioSumAggregateOutputType | null
    _min: EstudioMinAggregateOutputType | null
    _max: EstudioMaxAggregateOutputType | null
  }

  type GetEstudioGroupByPayload<T extends EstudioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudioGroupByOutputType[P]>
            : GetScalarType<T[P], EstudioGroupByOutputType[P]>
        }
      >
    >


  export type EstudioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_estudio?: boolean
    consecutivo?: boolean
    cantidad?: boolean
    fecha_muestra?: boolean
    fecha_resultado?: boolean
    resultado?: boolean
    observacion?: boolean
    profesional?: boolean
    tarifa?: boolean
    procedimiento?: boolean
    Tarifa_Estudio?: boolean | TarifaDefaultArgs<ExtArgs>
    Estudio_Procedimiento?: boolean | ProcedimientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudio"]>


  export type EstudioSelectScalar = {
    id_estudio?: boolean
    consecutivo?: boolean
    cantidad?: boolean
    fecha_muestra?: boolean
    fecha_resultado?: boolean
    resultado?: boolean
    observacion?: boolean
    profesional?: boolean
    tarifa?: boolean
    procedimiento?: boolean
  }

  export type EstudioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tarifa_Estudio?: boolean | TarifaDefaultArgs<ExtArgs>
    Estudio_Procedimiento?: boolean | ProcedimientoDefaultArgs<ExtArgs>
  }

  export type $EstudioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estudio"
    objects: {
      Tarifa_Estudio: Prisma.$TarifaPayload<ExtArgs>
      Estudio_Procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_estudio: number
      consecutivo: number
      cantidad: number
      fecha_muestra: Date
      fecha_resultado: Date
      resultado: string
      observacion: string
      profesional: number
      tarifa: number
      procedimiento: number
    }, ExtArgs["result"]["estudio"]>
    composites: {}
  }

  type EstudioGetPayload<S extends boolean | null | undefined | EstudioDefaultArgs> = $Result.GetResult<Prisma.$EstudioPayload, S>

  type EstudioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstudioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstudioCountAggregateInputType | true
    }

  export interface EstudioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estudio'], meta: { name: 'Estudio' } }
    /**
     * Find zero or one Estudio that matches the filter.
     * @param {EstudioFindUniqueArgs} args - Arguments to find a Estudio
     * @example
     * // Get one Estudio
     * const estudio = await prisma.estudio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudioFindUniqueArgs>(args: SelectSubset<T, EstudioFindUniqueArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Estudio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EstudioFindUniqueOrThrowArgs} args - Arguments to find a Estudio
     * @example
     * // Get one Estudio
     * const estudio = await prisma.estudio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudioFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Estudio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioFindFirstArgs} args - Arguments to find a Estudio
     * @example
     * // Get one Estudio
     * const estudio = await prisma.estudio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudioFindFirstArgs>(args?: SelectSubset<T, EstudioFindFirstArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Estudio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioFindFirstOrThrowArgs} args - Arguments to find a Estudio
     * @example
     * // Get one Estudio
     * const estudio = await prisma.estudio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudioFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudioFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Estudios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudios
     * const estudios = await prisma.estudio.findMany()
     * 
     * // Get first 10 Estudios
     * const estudios = await prisma.estudio.findMany({ take: 10 })
     * 
     * // Only select the `id_estudio`
     * const estudioWithId_estudioOnly = await prisma.estudio.findMany({ select: { id_estudio: true } })
     * 
     */
    findMany<T extends EstudioFindManyArgs>(args?: SelectSubset<T, EstudioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Estudio.
     * @param {EstudioCreateArgs} args - Arguments to create a Estudio.
     * @example
     * // Create one Estudio
     * const Estudio = await prisma.estudio.create({
     *   data: {
     *     // ... data to create a Estudio
     *   }
     * })
     * 
     */
    create<T extends EstudioCreateArgs>(args: SelectSubset<T, EstudioCreateArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Estudios.
     * @param {EstudioCreateManyArgs} args - Arguments to create many Estudios.
     * @example
     * // Create many Estudios
     * const estudio = await prisma.estudio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudioCreateManyArgs>(args?: SelectSubset<T, EstudioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estudio.
     * @param {EstudioDeleteArgs} args - Arguments to delete one Estudio.
     * @example
     * // Delete one Estudio
     * const Estudio = await prisma.estudio.delete({
     *   where: {
     *     // ... filter to delete one Estudio
     *   }
     * })
     * 
     */
    delete<T extends EstudioDeleteArgs>(args: SelectSubset<T, EstudioDeleteArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Estudio.
     * @param {EstudioUpdateArgs} args - Arguments to update one Estudio.
     * @example
     * // Update one Estudio
     * const estudio = await prisma.estudio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudioUpdateArgs>(args: SelectSubset<T, EstudioUpdateArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Estudios.
     * @param {EstudioDeleteManyArgs} args - Arguments to filter Estudios to delete.
     * @example
     * // Delete a few Estudios
     * const { count } = await prisma.estudio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudioDeleteManyArgs>(args?: SelectSubset<T, EstudioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudios
     * const estudio = await prisma.estudio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudioUpdateManyArgs>(args: SelectSubset<T, EstudioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estudio.
     * @param {EstudioUpsertArgs} args - Arguments to update or create a Estudio.
     * @example
     * // Update or create a Estudio
     * const estudio = await prisma.estudio.upsert({
     *   create: {
     *     // ... data to create a Estudio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudio we want to update
     *   }
     * })
     */
    upsert<T extends EstudioUpsertArgs>(args: SelectSubset<T, EstudioUpsertArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Estudios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioCountArgs} args - Arguments to filter Estudios to count.
     * @example
     * // Count the number of Estudios
     * const count = await prisma.estudio.count({
     *   where: {
     *     // ... the filter for the Estudios we want to count
     *   }
     * })
    **/
    count<T extends EstudioCountArgs>(
      args?: Subset<T, EstudioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudioAggregateArgs>(args: Subset<T, EstudioAggregateArgs>): Prisma.PrismaPromise<GetEstudioAggregateType<T>>

    /**
     * Group by Estudio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudioGroupByArgs['orderBy'] }
        : { orderBy?: EstudioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estudio model
   */
  readonly fields: EstudioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estudio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Tarifa_Estudio<T extends TarifaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TarifaDefaultArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Estudio_Procedimiento<T extends ProcedimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcedimientoDefaultArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estudio model
   */ 
  interface EstudioFieldRefs {
    readonly id_estudio: FieldRef<"Estudio", 'Int'>
    readonly consecutivo: FieldRef<"Estudio", 'Int'>
    readonly cantidad: FieldRef<"Estudio", 'Int'>
    readonly fecha_muestra: FieldRef<"Estudio", 'DateTime'>
    readonly fecha_resultado: FieldRef<"Estudio", 'DateTime'>
    readonly resultado: FieldRef<"Estudio", 'String'>
    readonly observacion: FieldRef<"Estudio", 'String'>
    readonly profesional: FieldRef<"Estudio", 'Int'>
    readonly tarifa: FieldRef<"Estudio", 'Int'>
    readonly procedimiento: FieldRef<"Estudio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Estudio findUnique
   */
  export type EstudioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudio to fetch.
     */
    where: EstudioWhereUniqueInput
  }

  /**
   * Estudio findUniqueOrThrow
   */
  export type EstudioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudio to fetch.
     */
    where: EstudioWhereUniqueInput
  }

  /**
   * Estudio findFirst
   */
  export type EstudioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudio to fetch.
     */
    where?: EstudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudios to fetch.
     */
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudios.
     */
    cursor?: EstudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudios.
     */
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Estudio findFirstOrThrow
   */
  export type EstudioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudio to fetch.
     */
    where?: EstudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudios to fetch.
     */
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudios.
     */
    cursor?: EstudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudios.
     */
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Estudio findMany
   */
  export type EstudioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudios to fetch.
     */
    where?: EstudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudios to fetch.
     */
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estudios.
     */
    cursor?: EstudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudios.
     */
    skip?: number
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Estudio create
   */
  export type EstudioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * The data needed to create a Estudio.
     */
    data: XOR<EstudioCreateInput, EstudioUncheckedCreateInput>
  }

  /**
   * Estudio createMany
   */
  export type EstudioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estudios.
     */
    data: EstudioCreateManyInput | EstudioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estudio update
   */
  export type EstudioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * The data needed to update a Estudio.
     */
    data: XOR<EstudioUpdateInput, EstudioUncheckedUpdateInput>
    /**
     * Choose, which Estudio to update.
     */
    where: EstudioWhereUniqueInput
  }

  /**
   * Estudio updateMany
   */
  export type EstudioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estudios.
     */
    data: XOR<EstudioUpdateManyMutationInput, EstudioUncheckedUpdateManyInput>
    /**
     * Filter which Estudios to update
     */
    where?: EstudioWhereInput
  }

  /**
   * Estudio upsert
   */
  export type EstudioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * The filter to search for the Estudio to update in case it exists.
     */
    where: EstudioWhereUniqueInput
    /**
     * In case the Estudio found by the `where` argument doesn't exist, create a new Estudio with this data.
     */
    create: XOR<EstudioCreateInput, EstudioUncheckedCreateInput>
    /**
     * In case the Estudio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudioUpdateInput, EstudioUncheckedUpdateInput>
  }

  /**
   * Estudio delete
   */
  export type EstudioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter which Estudio to delete.
     */
    where: EstudioWhereUniqueInput
  }

  /**
   * Estudio deleteMany
   */
  export type EstudioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudios to delete
     */
    where?: EstudioWhereInput
  }

  /**
   * Estudio without action
   */
  export type EstudioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
  }


  /**
   * Model Departamento
   */

  export type AggregateDepartamento = {
    _count: DepartamentoCountAggregateOutputType | null
    _avg: DepartamentoAvgAggregateOutputType | null
    _sum: DepartamentoSumAggregateOutputType | null
    _min: DepartamentoMinAggregateOutputType | null
    _max: DepartamentoMaxAggregateOutputType | null
  }

  export type DepartamentoAvgAggregateOutputType = {
    id_departamento: number | null
  }

  export type DepartamentoSumAggregateOutputType = {
    id_departamento: number | null
  }

  export type DepartamentoMinAggregateOutputType = {
    id_departamento: number | null
    nombre: string | null
  }

  export type DepartamentoMaxAggregateOutputType = {
    id_departamento: number | null
    nombre: string | null
  }

  export type DepartamentoCountAggregateOutputType = {
    id_departamento: number
    nombre: number
    _all: number
  }


  export type DepartamentoAvgAggregateInputType = {
    id_departamento?: true
  }

  export type DepartamentoSumAggregateInputType = {
    id_departamento?: true
  }

  export type DepartamentoMinAggregateInputType = {
    id_departamento?: true
    nombre?: true
  }

  export type DepartamentoMaxAggregateInputType = {
    id_departamento?: true
    nombre?: true
  }

  export type DepartamentoCountAggregateInputType = {
    id_departamento?: true
    nombre?: true
    _all?: true
  }

  export type DepartamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departamento to aggregate.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departamentos
    **/
    _count?: true | DepartamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartamentoMaxAggregateInputType
  }

  export type GetDepartamentoAggregateType<T extends DepartamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartamento[P]>
      : GetScalarType<T[P], AggregateDepartamento[P]>
  }




  export type DepartamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartamentoWhereInput
    orderBy?: DepartamentoOrderByWithAggregationInput | DepartamentoOrderByWithAggregationInput[]
    by: DepartamentoScalarFieldEnum[] | DepartamentoScalarFieldEnum
    having?: DepartamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartamentoCountAggregateInputType | true
    _avg?: DepartamentoAvgAggregateInputType
    _sum?: DepartamentoSumAggregateInputType
    _min?: DepartamentoMinAggregateInputType
    _max?: DepartamentoMaxAggregateInputType
  }

  export type DepartamentoGroupByOutputType = {
    id_departamento: number
    nombre: string
    _count: DepartamentoCountAggregateOutputType | null
    _avg: DepartamentoAvgAggregateOutputType | null
    _sum: DepartamentoSumAggregateOutputType | null
    _min: DepartamentoMinAggregateOutputType | null
    _max: DepartamentoMaxAggregateOutputType | null
  }

  type GetDepartamentoGroupByPayload<T extends DepartamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartamentoGroupByOutputType[P]>
            : GetScalarType<T[P], DepartamentoGroupByOutputType[P]>
        }
      >
    >


  export type DepartamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_departamento?: boolean
    nombre?: boolean
    municipio?: boolean | Departamento$municipioArgs<ExtArgs>
    _count?: boolean | DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departamento"]>


  export type DepartamentoSelectScalar = {
    id_departamento?: boolean
    nombre?: boolean
  }

  export type DepartamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | Departamento$municipioArgs<ExtArgs>
    _count?: boolean | DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Departamento"
    objects: {
      municipio: Prisma.$MunicipioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_departamento: number
      nombre: string
    }, ExtArgs["result"]["departamento"]>
    composites: {}
  }

  type DepartamentoGetPayload<S extends boolean | null | undefined | DepartamentoDefaultArgs> = $Result.GetResult<Prisma.$DepartamentoPayload, S>

  type DepartamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartamentoCountAggregateInputType | true
    }

  export interface DepartamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Departamento'], meta: { name: 'Departamento' } }
    /**
     * Find zero or one Departamento that matches the filter.
     * @param {DepartamentoFindUniqueArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartamentoFindUniqueArgs>(args: SelectSubset<T, DepartamentoFindUniqueArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Departamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartamentoFindUniqueOrThrowArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Departamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindFirstArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartamentoFindFirstArgs>(args?: SelectSubset<T, DepartamentoFindFirstArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Departamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindFirstOrThrowArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departamentos
     * const departamentos = await prisma.departamento.findMany()
     * 
     * // Get first 10 Departamentos
     * const departamentos = await prisma.departamento.findMany({ take: 10 })
     * 
     * // Only select the `id_departamento`
     * const departamentoWithId_departamentoOnly = await prisma.departamento.findMany({ select: { id_departamento: true } })
     * 
     */
    findMany<T extends DepartamentoFindManyArgs>(args?: SelectSubset<T, DepartamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Departamento.
     * @param {DepartamentoCreateArgs} args - Arguments to create a Departamento.
     * @example
     * // Create one Departamento
     * const Departamento = await prisma.departamento.create({
     *   data: {
     *     // ... data to create a Departamento
     *   }
     * })
     * 
     */
    create<T extends DepartamentoCreateArgs>(args: SelectSubset<T, DepartamentoCreateArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departamentos.
     * @param {DepartamentoCreateManyArgs} args - Arguments to create many Departamentos.
     * @example
     * // Create many Departamentos
     * const departamento = await prisma.departamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartamentoCreateManyArgs>(args?: SelectSubset<T, DepartamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Departamento.
     * @param {DepartamentoDeleteArgs} args - Arguments to delete one Departamento.
     * @example
     * // Delete one Departamento
     * const Departamento = await prisma.departamento.delete({
     *   where: {
     *     // ... filter to delete one Departamento
     *   }
     * })
     * 
     */
    delete<T extends DepartamentoDeleteArgs>(args: SelectSubset<T, DepartamentoDeleteArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Departamento.
     * @param {DepartamentoUpdateArgs} args - Arguments to update one Departamento.
     * @example
     * // Update one Departamento
     * const departamento = await prisma.departamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartamentoUpdateArgs>(args: SelectSubset<T, DepartamentoUpdateArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departamentos.
     * @param {DepartamentoDeleteManyArgs} args - Arguments to filter Departamentos to delete.
     * @example
     * // Delete a few Departamentos
     * const { count } = await prisma.departamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartamentoDeleteManyArgs>(args?: SelectSubset<T, DepartamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departamentos
     * const departamento = await prisma.departamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartamentoUpdateManyArgs>(args: SelectSubset<T, DepartamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Departamento.
     * @param {DepartamentoUpsertArgs} args - Arguments to update or create a Departamento.
     * @example
     * // Update or create a Departamento
     * const departamento = await prisma.departamento.upsert({
     *   create: {
     *     // ... data to create a Departamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departamento we want to update
     *   }
     * })
     */
    upsert<T extends DepartamentoUpsertArgs>(args: SelectSubset<T, DepartamentoUpsertArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoCountArgs} args - Arguments to filter Departamentos to count.
     * @example
     * // Count the number of Departamentos
     * const count = await prisma.departamento.count({
     *   where: {
     *     // ... the filter for the Departamentos we want to count
     *   }
     * })
    **/
    count<T extends DepartamentoCountArgs>(
      args?: Subset<T, DepartamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartamentoAggregateArgs>(args: Subset<T, DepartamentoAggregateArgs>): Prisma.PrismaPromise<GetDepartamentoAggregateType<T>>

    /**
     * Group by Departamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartamentoGroupByArgs['orderBy'] }
        : { orderBy?: DepartamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Departamento model
   */
  readonly fields: DepartamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Departamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipio<T extends Departamento$municipioArgs<ExtArgs> = {}>(args?: Subset<T, Departamento$municipioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Departamento model
   */ 
  interface DepartamentoFieldRefs {
    readonly id_departamento: FieldRef<"Departamento", 'Int'>
    readonly nombre: FieldRef<"Departamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Departamento findUnique
   */
  export type DepartamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento findUniqueOrThrow
   */
  export type DepartamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento findFirst
   */
  export type DepartamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     */
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento findFirstOrThrow
   */
  export type DepartamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     */
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento findMany
   */
  export type DepartamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamentos to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento create
   */
  export type DepartamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Departamento.
     */
    data: XOR<DepartamentoCreateInput, DepartamentoUncheckedCreateInput>
  }

  /**
   * Departamento createMany
   */
  export type DepartamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departamentos.
     */
    data: DepartamentoCreateManyInput | DepartamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Departamento update
   */
  export type DepartamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Departamento.
     */
    data: XOR<DepartamentoUpdateInput, DepartamentoUncheckedUpdateInput>
    /**
     * Choose, which Departamento to update.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento updateMany
   */
  export type DepartamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departamentos.
     */
    data: XOR<DepartamentoUpdateManyMutationInput, DepartamentoUncheckedUpdateManyInput>
    /**
     * Filter which Departamentos to update
     */
    where?: DepartamentoWhereInput
  }

  /**
   * Departamento upsert
   */
  export type DepartamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Departamento to update in case it exists.
     */
    where: DepartamentoWhereUniqueInput
    /**
     * In case the Departamento found by the `where` argument doesn't exist, create a new Departamento with this data.
     */
    create: XOR<DepartamentoCreateInput, DepartamentoUncheckedCreateInput>
    /**
     * In case the Departamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartamentoUpdateInput, DepartamentoUncheckedUpdateInput>
  }

  /**
   * Departamento delete
   */
  export type DepartamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter which Departamento to delete.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento deleteMany
   */
  export type DepartamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departamentos to delete
     */
    where?: DepartamentoWhereInput
  }

  /**
   * Departamento.municipio
   */
  export type Departamento$municipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    where?: MunicipioWhereInput
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    cursor?: MunicipioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Departamento without action
   */
  export type DepartamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
  }


  /**
   * Model Municipio
   */

  export type AggregateMunicipio = {
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  export type MunicipioAvgAggregateOutputType = {
    id_municipio: number | null
    departamento: number | null
  }

  export type MunicipioSumAggregateOutputType = {
    id_municipio: number | null
    departamento: number | null
  }

  export type MunicipioMinAggregateOutputType = {
    id_municipio: number | null
    nombre: string | null
    departamento: number | null
  }

  export type MunicipioMaxAggregateOutputType = {
    id_municipio: number | null
    nombre: string | null
    departamento: number | null
  }

  export type MunicipioCountAggregateOutputType = {
    id_municipio: number
    nombre: number
    departamento: number
    _all: number
  }


  export type MunicipioAvgAggregateInputType = {
    id_municipio?: true
    departamento?: true
  }

  export type MunicipioSumAggregateInputType = {
    id_municipio?: true
    departamento?: true
  }

  export type MunicipioMinAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamento?: true
  }

  export type MunicipioMaxAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamento?: true
  }

  export type MunicipioCountAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamento?: true
    _all?: true
  }

  export type MunicipioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipio to aggregate.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipios
    **/
    _count?: true | MunicipioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MunicipioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MunicipioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipioMaxAggregateInputType
  }

  export type GetMunicipioAggregateType<T extends MunicipioAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipio[P]>
      : GetScalarType<T[P], AggregateMunicipio[P]>
  }




  export type MunicipioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipioWhereInput
    orderBy?: MunicipioOrderByWithAggregationInput | MunicipioOrderByWithAggregationInput[]
    by: MunicipioScalarFieldEnum[] | MunicipioScalarFieldEnum
    having?: MunicipioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipioCountAggregateInputType | true
    _avg?: MunicipioAvgAggregateInputType
    _sum?: MunicipioSumAggregateInputType
    _min?: MunicipioMinAggregateInputType
    _max?: MunicipioMaxAggregateInputType
  }

  export type MunicipioGroupByOutputType = {
    id_municipio: number
    nombre: string
    departamento: number
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  type GetMunicipioGroupByPayload<T extends MunicipioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
        }
      >
    >


  export type MunicipioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_municipio?: boolean
    nombre?: boolean
    departamento?: boolean
    suario?: boolean | Municipio$suarioArgs<ExtArgs>
    empresa?: boolean | Municipio$empresaArgs<ExtArgs>
    Departamentos_Municipio?: boolean | DepartamentoDefaultArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipio"]>


  export type MunicipioSelectScalar = {
    id_municipio?: boolean
    nombre?: boolean
    departamento?: boolean
  }

  export type MunicipioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suario?: boolean | Municipio$suarioArgs<ExtArgs>
    empresa?: boolean | Municipio$empresaArgs<ExtArgs>
    Departamentos_Municipio?: boolean | DepartamentoDefaultArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MunicipioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipio"
    objects: {
      suario: Prisma.$UsuarioPayload<ExtArgs>[]
      empresa: Prisma.$EmpresaPayload<ExtArgs>[]
      Departamentos_Municipio: Prisma.$DepartamentoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_municipio: number
      nombre: string
      departamento: number
    }, ExtArgs["result"]["municipio"]>
    composites: {}
  }

  type MunicipioGetPayload<S extends boolean | null | undefined | MunicipioDefaultArgs> = $Result.GetResult<Prisma.$MunicipioPayload, S>

  type MunicipioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MunicipioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MunicipioCountAggregateInputType | true
    }

  export interface MunicipioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipio'], meta: { name: 'Municipio' } }
    /**
     * Find zero or one Municipio that matches the filter.
     * @param {MunicipioFindUniqueArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipioFindUniqueArgs>(args: SelectSubset<T, MunicipioFindUniqueArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Municipio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MunicipioFindUniqueOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipioFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Municipio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindFirstArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipioFindFirstArgs>(args?: SelectSubset<T, MunicipioFindFirstArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Municipio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindFirstOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipioFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipioFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Municipios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipios
     * const municipios = await prisma.municipio.findMany()
     * 
     * // Get first 10 Municipios
     * const municipios = await prisma.municipio.findMany({ take: 10 })
     * 
     * // Only select the `id_municipio`
     * const municipioWithId_municipioOnly = await prisma.municipio.findMany({ select: { id_municipio: true } })
     * 
     */
    findMany<T extends MunicipioFindManyArgs>(args?: SelectSubset<T, MunicipioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Municipio.
     * @param {MunicipioCreateArgs} args - Arguments to create a Municipio.
     * @example
     * // Create one Municipio
     * const Municipio = await prisma.municipio.create({
     *   data: {
     *     // ... data to create a Municipio
     *   }
     * })
     * 
     */
    create<T extends MunicipioCreateArgs>(args: SelectSubset<T, MunicipioCreateArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Municipios.
     * @param {MunicipioCreateManyArgs} args - Arguments to create many Municipios.
     * @example
     * // Create many Municipios
     * const municipio = await prisma.municipio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipioCreateManyArgs>(args?: SelectSubset<T, MunicipioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Municipio.
     * @param {MunicipioDeleteArgs} args - Arguments to delete one Municipio.
     * @example
     * // Delete one Municipio
     * const Municipio = await prisma.municipio.delete({
     *   where: {
     *     // ... filter to delete one Municipio
     *   }
     * })
     * 
     */
    delete<T extends MunicipioDeleteArgs>(args: SelectSubset<T, MunicipioDeleteArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Municipio.
     * @param {MunicipioUpdateArgs} args - Arguments to update one Municipio.
     * @example
     * // Update one Municipio
     * const municipio = await prisma.municipio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipioUpdateArgs>(args: SelectSubset<T, MunicipioUpdateArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Municipios.
     * @param {MunicipioDeleteManyArgs} args - Arguments to filter Municipios to delete.
     * @example
     * // Delete a few Municipios
     * const { count } = await prisma.municipio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipioDeleteManyArgs>(args?: SelectSubset<T, MunicipioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipios
     * const municipio = await prisma.municipio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipioUpdateManyArgs>(args: SelectSubset<T, MunicipioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Municipio.
     * @param {MunicipioUpsertArgs} args - Arguments to update or create a Municipio.
     * @example
     * // Update or create a Municipio
     * const municipio = await prisma.municipio.upsert({
     *   create: {
     *     // ... data to create a Municipio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipio we want to update
     *   }
     * })
     */
    upsert<T extends MunicipioUpsertArgs>(args: SelectSubset<T, MunicipioUpsertArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioCountArgs} args - Arguments to filter Municipios to count.
     * @example
     * // Count the number of Municipios
     * const count = await prisma.municipio.count({
     *   where: {
     *     // ... the filter for the Municipios we want to count
     *   }
     * })
    **/
    count<T extends MunicipioCountArgs>(
      args?: Subset<T, MunicipioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipioAggregateArgs>(args: Subset<T, MunicipioAggregateArgs>): Prisma.PrismaPromise<GetMunicipioAggregateType<T>>

    /**
     * Group by Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipioGroupByArgs['orderBy'] }
        : { orderBy?: MunicipioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipio model
   */
  readonly fields: MunicipioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    suario<T extends Municipio$suarioArgs<ExtArgs> = {}>(args?: Subset<T, Municipio$suarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    empresa<T extends Municipio$empresaArgs<ExtArgs> = {}>(args?: Subset<T, Municipio$empresaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany"> | Null>
    Departamentos_Municipio<T extends DepartamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartamentoDefaultArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipio model
   */ 
  interface MunicipioFieldRefs {
    readonly id_municipio: FieldRef<"Municipio", 'Int'>
    readonly nombre: FieldRef<"Municipio", 'String'>
    readonly departamento: FieldRef<"Municipio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Municipio findUnique
   */
  export type MunicipioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio findUniqueOrThrow
   */
  export type MunicipioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio findFirst
   */
  export type MunicipioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio findFirstOrThrow
   */
  export type MunicipioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio findMany
   */
  export type MunicipioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipios to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio create
   */
  export type MunicipioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipio.
     */
    data: XOR<MunicipioCreateInput, MunicipioUncheckedCreateInput>
  }

  /**
   * Municipio createMany
   */
  export type MunicipioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipios.
     */
    data: MunicipioCreateManyInput | MunicipioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Municipio update
   */
  export type MunicipioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipio.
     */
    data: XOR<MunicipioUpdateInput, MunicipioUncheckedUpdateInput>
    /**
     * Choose, which Municipio to update.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio updateMany
   */
  export type MunicipioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipios.
     */
    data: XOR<MunicipioUpdateManyMutationInput, MunicipioUncheckedUpdateManyInput>
    /**
     * Filter which Municipios to update
     */
    where?: MunicipioWhereInput
  }

  /**
   * Municipio upsert
   */
  export type MunicipioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipio to update in case it exists.
     */
    where: MunicipioWhereUniqueInput
    /**
     * In case the Municipio found by the `where` argument doesn't exist, create a new Municipio with this data.
     */
    create: XOR<MunicipioCreateInput, MunicipioUncheckedCreateInput>
    /**
     * In case the Municipio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipioUpdateInput, MunicipioUncheckedUpdateInput>
  }

  /**
   * Municipio delete
   */
  export type MunicipioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter which Municipio to delete.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio deleteMany
   */
  export type MunicipioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipios to delete
     */
    where?: MunicipioWhereInput
  }

  /**
   * Municipio.suario
   */
  export type Municipio$suarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Municipio.empresa
   */
  export type Municipio$empresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    cursor?: EmpresaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Municipio without action
   */
  export type MunicipioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
  }


  /**
   * Model Tipo_Servicio
   */

  export type AggregateTipo_Servicio = {
    _count: Tipo_ServicioCountAggregateOutputType | null
    _avg: Tipo_ServicioAvgAggregateOutputType | null
    _sum: Tipo_ServicioSumAggregateOutputType | null
    _min: Tipo_ServicioMinAggregateOutputType | null
    _max: Tipo_ServicioMaxAggregateOutputType | null
  }

  export type Tipo_ServicioAvgAggregateOutputType = {
    id_tipo_servicio: number | null
  }

  export type Tipo_ServicioSumAggregateOutputType = {
    id_tipo_servicio: number | null
  }

  export type Tipo_ServicioMinAggregateOutputType = {
    id_tipo_servicio: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type Tipo_ServicioMaxAggregateOutputType = {
    id_tipo_servicio: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type Tipo_ServicioCountAggregateOutputType = {
    id_tipo_servicio: number
    nombre: number
    estado: number
    _all: number
  }


  export type Tipo_ServicioAvgAggregateInputType = {
    id_tipo_servicio?: true
  }

  export type Tipo_ServicioSumAggregateInputType = {
    id_tipo_servicio?: true
  }

  export type Tipo_ServicioMinAggregateInputType = {
    id_tipo_servicio?: true
    nombre?: true
    estado?: true
  }

  export type Tipo_ServicioMaxAggregateInputType = {
    id_tipo_servicio?: true
    nombre?: true
    estado?: true
  }

  export type Tipo_ServicioCountAggregateInputType = {
    id_tipo_servicio?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type Tipo_ServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Servicio to aggregate.
     */
    where?: Tipo_ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Servicios to fetch.
     */
    orderBy?: Tipo_ServicioOrderByWithRelationInput | Tipo_ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tipo_ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipo_Servicios
    **/
    _count?: true | Tipo_ServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_ServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_ServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_ServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_ServicioMaxAggregateInputType
  }

  export type GetTipo_ServicioAggregateType<T extends Tipo_ServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_Servicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_Servicio[P]>
      : GetScalarType<T[P], AggregateTipo_Servicio[P]>
  }




  export type Tipo_ServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ServicioWhereInput
    orderBy?: Tipo_ServicioOrderByWithAggregationInput | Tipo_ServicioOrderByWithAggregationInput[]
    by: Tipo_ServicioScalarFieldEnum[] | Tipo_ServicioScalarFieldEnum
    having?: Tipo_ServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_ServicioCountAggregateInputType | true
    _avg?: Tipo_ServicioAvgAggregateInputType
    _sum?: Tipo_ServicioSumAggregateInputType
    _min?: Tipo_ServicioMinAggregateInputType
    _max?: Tipo_ServicioMaxAggregateInputType
  }

  export type Tipo_ServicioGroupByOutputType = {
    id_tipo_servicio: number
    nombre: string
    estado: $Enums.Estado
    _count: Tipo_ServicioCountAggregateOutputType | null
    _avg: Tipo_ServicioAvgAggregateOutputType | null
    _sum: Tipo_ServicioSumAggregateOutputType | null
    _min: Tipo_ServicioMinAggregateOutputType | null
    _max: Tipo_ServicioMaxAggregateOutputType | null
  }

  type GetTipo_ServicioGroupByPayload<T extends Tipo_ServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_ServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_ServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_ServicioGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_ServicioGroupByOutputType[P]>
        }
      >
    >


  export type Tipo_ServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_servicio?: boolean
    nombre?: boolean
    estado?: boolean
    servicio?: boolean | Tipo_Servicio$servicioArgs<ExtArgs>
    _count?: boolean | Tipo_ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_Servicio"]>


  export type Tipo_ServicioSelectScalar = {
    id_tipo_servicio?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type Tipo_ServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Tipo_Servicio$servicioArgs<ExtArgs>
    _count?: boolean | Tipo_ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Tipo_ServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tipo_Servicio"
    objects: {
      servicio: Prisma.$ServicioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_servicio: number
      nombre: string
      estado: $Enums.Estado
    }, ExtArgs["result"]["tipo_Servicio"]>
    composites: {}
  }

  type Tipo_ServicioGetPayload<S extends boolean | null | undefined | Tipo_ServicioDefaultArgs> = $Result.GetResult<Prisma.$Tipo_ServicioPayload, S>

  type Tipo_ServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tipo_ServicioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_ServicioCountAggregateInputType | true
    }

  export interface Tipo_ServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tipo_Servicio'], meta: { name: 'Tipo_Servicio' } }
    /**
     * Find zero or one Tipo_Servicio that matches the filter.
     * @param {Tipo_ServicioFindUniqueArgs} args - Arguments to find a Tipo_Servicio
     * @example
     * // Get one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tipo_ServicioFindUniqueArgs>(args: SelectSubset<T, Tipo_ServicioFindUniqueArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_Servicio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Tipo_ServicioFindUniqueOrThrowArgs} args - Arguments to find a Tipo_Servicio
     * @example
     * // Get one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tipo_ServicioFindUniqueOrThrowArgs>(args: SelectSubset<T, Tipo_ServicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_Servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioFindFirstArgs} args - Arguments to find a Tipo_Servicio
     * @example
     * // Get one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tipo_ServicioFindFirstArgs>(args?: SelectSubset<T, Tipo_ServicioFindFirstArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_Servicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioFindFirstOrThrowArgs} args - Arguments to find a Tipo_Servicio
     * @example
     * // Get one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tipo_ServicioFindFirstOrThrowArgs>(args?: SelectSubset<T, Tipo_ServicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_Servicios
     * const tipo_Servicios = await prisma.tipo_Servicio.findMany()
     * 
     * // Get first 10 Tipo_Servicios
     * const tipo_Servicios = await prisma.tipo_Servicio.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_servicio`
     * const tipo_ServicioWithId_tipo_servicioOnly = await prisma.tipo_Servicio.findMany({ select: { id_tipo_servicio: true } })
     * 
     */
    findMany<T extends Tipo_ServicioFindManyArgs>(args?: SelectSubset<T, Tipo_ServicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_Servicio.
     * @param {Tipo_ServicioCreateArgs} args - Arguments to create a Tipo_Servicio.
     * @example
     * // Create one Tipo_Servicio
     * const Tipo_Servicio = await prisma.tipo_Servicio.create({
     *   data: {
     *     // ... data to create a Tipo_Servicio
     *   }
     * })
     * 
     */
    create<T extends Tipo_ServicioCreateArgs>(args: SelectSubset<T, Tipo_ServicioCreateArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_Servicios.
     * @param {Tipo_ServicioCreateManyArgs} args - Arguments to create many Tipo_Servicios.
     * @example
     * // Create many Tipo_Servicios
     * const tipo_Servicio = await prisma.tipo_Servicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tipo_ServicioCreateManyArgs>(args?: SelectSubset<T, Tipo_ServicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_Servicio.
     * @param {Tipo_ServicioDeleteArgs} args - Arguments to delete one Tipo_Servicio.
     * @example
     * // Delete one Tipo_Servicio
     * const Tipo_Servicio = await prisma.tipo_Servicio.delete({
     *   where: {
     *     // ... filter to delete one Tipo_Servicio
     *   }
     * })
     * 
     */
    delete<T extends Tipo_ServicioDeleteArgs>(args: SelectSubset<T, Tipo_ServicioDeleteArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_Servicio.
     * @param {Tipo_ServicioUpdateArgs} args - Arguments to update one Tipo_Servicio.
     * @example
     * // Update one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tipo_ServicioUpdateArgs>(args: SelectSubset<T, Tipo_ServicioUpdateArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_Servicios.
     * @param {Tipo_ServicioDeleteManyArgs} args - Arguments to filter Tipo_Servicios to delete.
     * @example
     * // Delete a few Tipo_Servicios
     * const { count } = await prisma.tipo_Servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tipo_ServicioDeleteManyArgs>(args?: SelectSubset<T, Tipo_ServicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_Servicios
     * const tipo_Servicio = await prisma.tipo_Servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tipo_ServicioUpdateManyArgs>(args: SelectSubset<T, Tipo_ServicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_Servicio.
     * @param {Tipo_ServicioUpsertArgs} args - Arguments to update or create a Tipo_Servicio.
     * @example
     * // Update or create a Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.upsert({
     *   create: {
     *     // ... data to create a Tipo_Servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_Servicio we want to update
     *   }
     * })
     */
    upsert<T extends Tipo_ServicioUpsertArgs>(args: SelectSubset<T, Tipo_ServicioUpsertArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioCountArgs} args - Arguments to filter Tipo_Servicios to count.
     * @example
     * // Count the number of Tipo_Servicios
     * const count = await prisma.tipo_Servicio.count({
     *   where: {
     *     // ... the filter for the Tipo_Servicios we want to count
     *   }
     * })
    **/
    count<T extends Tipo_ServicioCountArgs>(
      args?: Subset<T, Tipo_ServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_ServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_ServicioAggregateArgs>(args: Subset<T, Tipo_ServicioAggregateArgs>): Prisma.PrismaPromise<GetTipo_ServicioAggregateType<T>>

    /**
     * Group by Tipo_Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_ServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_ServicioGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_ServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_ServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_ServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tipo_Servicio model
   */
  readonly fields: Tipo_ServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo_Servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tipo_ServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends Tipo_Servicio$servicioArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_Servicio$servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tipo_Servicio model
   */ 
  interface Tipo_ServicioFieldRefs {
    readonly id_tipo_servicio: FieldRef<"Tipo_Servicio", 'Int'>
    readonly nombre: FieldRef<"Tipo_Servicio", 'String'>
    readonly estado: FieldRef<"Tipo_Servicio", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Tipo_Servicio findUnique
   */
  export type Tipo_ServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicio to fetch.
     */
    where: Tipo_ServicioWhereUniqueInput
  }

  /**
   * Tipo_Servicio findUniqueOrThrow
   */
  export type Tipo_ServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicio to fetch.
     */
    where: Tipo_ServicioWhereUniqueInput
  }

  /**
   * Tipo_Servicio findFirst
   */
  export type Tipo_ServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicio to fetch.
     */
    where?: Tipo_ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Servicios to fetch.
     */
    orderBy?: Tipo_ServicioOrderByWithRelationInput | Tipo_ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Servicios.
     */
    cursor?: Tipo_ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Servicios.
     */
    distinct?: Tipo_ServicioScalarFieldEnum | Tipo_ServicioScalarFieldEnum[]
  }

  /**
   * Tipo_Servicio findFirstOrThrow
   */
  export type Tipo_ServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicio to fetch.
     */
    where?: Tipo_ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Servicios to fetch.
     */
    orderBy?: Tipo_ServicioOrderByWithRelationInput | Tipo_ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Servicios.
     */
    cursor?: Tipo_ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Servicios.
     */
    distinct?: Tipo_ServicioScalarFieldEnum | Tipo_ServicioScalarFieldEnum[]
  }

  /**
   * Tipo_Servicio findMany
   */
  export type Tipo_ServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicios to fetch.
     */
    where?: Tipo_ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Servicios to fetch.
     */
    orderBy?: Tipo_ServicioOrderByWithRelationInput | Tipo_ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipo_Servicios.
     */
    cursor?: Tipo_ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Servicios.
     */
    skip?: number
    distinct?: Tipo_ServicioScalarFieldEnum | Tipo_ServicioScalarFieldEnum[]
  }

  /**
   * Tipo_Servicio create
   */
  export type Tipo_ServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a Tipo_Servicio.
     */
    data: XOR<Tipo_ServicioCreateInput, Tipo_ServicioUncheckedCreateInput>
  }

  /**
   * Tipo_Servicio createMany
   */
  export type Tipo_ServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tipo_Servicios.
     */
    data: Tipo_ServicioCreateManyInput | Tipo_ServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tipo_Servicio update
   */
  export type Tipo_ServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a Tipo_Servicio.
     */
    data: XOR<Tipo_ServicioUpdateInput, Tipo_ServicioUncheckedUpdateInput>
    /**
     * Choose, which Tipo_Servicio to update.
     */
    where: Tipo_ServicioWhereUniqueInput
  }

  /**
   * Tipo_Servicio updateMany
   */
  export type Tipo_ServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tipo_Servicios.
     */
    data: XOR<Tipo_ServicioUpdateManyMutationInput, Tipo_ServicioUncheckedUpdateManyInput>
    /**
     * Filter which Tipo_Servicios to update
     */
    where?: Tipo_ServicioWhereInput
  }

  /**
   * Tipo_Servicio upsert
   */
  export type Tipo_ServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the Tipo_Servicio to update in case it exists.
     */
    where: Tipo_ServicioWhereUniqueInput
    /**
     * In case the Tipo_Servicio found by the `where` argument doesn't exist, create a new Tipo_Servicio with this data.
     */
    create: XOR<Tipo_ServicioCreateInput, Tipo_ServicioUncheckedCreateInput>
    /**
     * In case the Tipo_Servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tipo_ServicioUpdateInput, Tipo_ServicioUncheckedUpdateInput>
  }

  /**
   * Tipo_Servicio delete
   */
  export type Tipo_ServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter which Tipo_Servicio to delete.
     */
    where: Tipo_ServicioWhereUniqueInput
  }

  /**
   * Tipo_Servicio deleteMany
   */
  export type Tipo_ServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Servicios to delete
     */
    where?: Tipo_ServicioWhereInput
  }

  /**
   * Tipo_Servicio.servicio
   */
  export type Tipo_Servicio$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    cursor?: ServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Tipo_Servicio without action
   */
  export type Tipo_ServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
  }


  /**
   * Model Servicio
   */

  export type AggregateServicio = {
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  export type ServicioAvgAggregateOutputType = {
    id_servicio: number | null
    precio: Decimal | null
    iva: Decimal | null
    nivel: number | null
    tipo_servicio: number | null
    prestador: number | null
  }

  export type ServicioSumAggregateOutputType = {
    id_servicio: number | null
    precio: Decimal | null
    iva: Decimal | null
    nivel: number | null
    tipo_servicio: number | null
    prestador: number | null
  }

  export type ServicioMinAggregateOutputType = {
    id_servicio: number | null
    nombre: string | null
    precio: Decimal | null
    iva: Decimal | null
    nivel: number | null
    tipo_servicio: number | null
    prestador: number | null
  }

  export type ServicioMaxAggregateOutputType = {
    id_servicio: number | null
    nombre: string | null
    precio: Decimal | null
    iva: Decimal | null
    nivel: number | null
    tipo_servicio: number | null
    prestador: number | null
  }

  export type ServicioCountAggregateOutputType = {
    id_servicio: number
    nombre: number
    precio: number
    iva: number
    nivel: number
    tipo_servicio: number
    prestador: number
    _all: number
  }


  export type ServicioAvgAggregateInputType = {
    id_servicio?: true
    precio?: true
    iva?: true
    nivel?: true
    tipo_servicio?: true
    prestador?: true
  }

  export type ServicioSumAggregateInputType = {
    id_servicio?: true
    precio?: true
    iva?: true
    nivel?: true
    tipo_servicio?: true
    prestador?: true
  }

  export type ServicioMinAggregateInputType = {
    id_servicio?: true
    nombre?: true
    precio?: true
    iva?: true
    nivel?: true
    tipo_servicio?: true
    prestador?: true
  }

  export type ServicioMaxAggregateInputType = {
    id_servicio?: true
    nombre?: true
    precio?: true
    iva?: true
    nivel?: true
    tipo_servicio?: true
    prestador?: true
  }

  export type ServicioCountAggregateInputType = {
    id_servicio?: true
    nombre?: true
    precio?: true
    iva?: true
    nivel?: true
    tipo_servicio?: true
    prestador?: true
    _all?: true
  }

  export type ServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicio to aggregate.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicios
    **/
    _count?: true | ServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioMaxAggregateInputType
  }

  export type GetServicioAggregateType<T extends ServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio[P]>
      : GetScalarType<T[P], AggregateServicio[P]>
  }




  export type ServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithAggregationInput | ServicioOrderByWithAggregationInput[]
    by: ServicioScalarFieldEnum[] | ServicioScalarFieldEnum
    having?: ServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioCountAggregateInputType | true
    _avg?: ServicioAvgAggregateInputType
    _sum?: ServicioSumAggregateInputType
    _min?: ServicioMinAggregateInputType
    _max?: ServicioMaxAggregateInputType
  }

  export type ServicioGroupByOutputType = {
    id_servicio: number
    nombre: string
    precio: Decimal
    iva: Decimal
    nivel: number
    tipo_servicio: number
    prestador: number
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  type GetServicioGroupByPayload<T extends ServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicioGroupByOutputType[P]>
            : GetScalarType<T[P], ServicioGroupByOutputType[P]>
        }
      >
    >


  export type ServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_servicio?: boolean
    nombre?: boolean
    precio?: boolean
    iva?: boolean
    nivel?: boolean
    tipo_servicio?: boolean
    prestador?: boolean
    tarifa?: boolean | Servicio$tarifaArgs<ExtArgs>
    Servicio_Tipo_Servicio?: boolean | Tipo_ServicioDefaultArgs<ExtArgs>
    Prestador_Servicio?: boolean | PrestadorDefaultArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>


  export type ServicioSelectScalar = {
    id_servicio?: boolean
    nombre?: boolean
    precio?: boolean
    iva?: boolean
    nivel?: boolean
    tipo_servicio?: boolean
    prestador?: boolean
  }

  export type ServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarifa?: boolean | Servicio$tarifaArgs<ExtArgs>
    Servicio_Tipo_Servicio?: boolean | Tipo_ServicioDefaultArgs<ExtArgs>
    Prestador_Servicio?: boolean | PrestadorDefaultArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Servicio"
    objects: {
      tarifa: Prisma.$TarifaPayload<ExtArgs>[]
      Servicio_Tipo_Servicio: Prisma.$Tipo_ServicioPayload<ExtArgs>
      Prestador_Servicio: Prisma.$PrestadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_servicio: number
      nombre: string
      precio: Prisma.Decimal
      iva: Prisma.Decimal
      nivel: number
      tipo_servicio: number
      prestador: number
    }, ExtArgs["result"]["servicio"]>
    composites: {}
  }

  type ServicioGetPayload<S extends boolean | null | undefined | ServicioDefaultArgs> = $Result.GetResult<Prisma.$ServicioPayload, S>

  type ServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServicioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicioCountAggregateInputType | true
    }

  export interface ServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Servicio'], meta: { name: 'Servicio' } }
    /**
     * Find zero or one Servicio that matches the filter.
     * @param {ServicioFindUniqueArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicioFindUniqueArgs>(args: SelectSubset<T, ServicioFindUniqueArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServicioFindUniqueOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicioFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicioFindFirstArgs>(args?: SelectSubset<T, ServicioFindFirstArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicioFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicio.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicio.findMany({ take: 10 })
     * 
     * // Only select the `id_servicio`
     * const servicioWithId_servicioOnly = await prisma.servicio.findMany({ select: { id_servicio: true } })
     * 
     */
    findMany<T extends ServicioFindManyArgs>(args?: SelectSubset<T, ServicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicio.
     * @param {ServicioCreateArgs} args - Arguments to create a Servicio.
     * @example
     * // Create one Servicio
     * const Servicio = await prisma.servicio.create({
     *   data: {
     *     // ... data to create a Servicio
     *   }
     * })
     * 
     */
    create<T extends ServicioCreateArgs>(args: SelectSubset<T, ServicioCreateArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicios.
     * @param {ServicioCreateManyArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicio = await prisma.servicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicioCreateManyArgs>(args?: SelectSubset<T, ServicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio.
     * @param {ServicioDeleteArgs} args - Arguments to delete one Servicio.
     * @example
     * // Delete one Servicio
     * const Servicio = await prisma.servicio.delete({
     *   where: {
     *     // ... filter to delete one Servicio
     *   }
     * })
     * 
     */
    delete<T extends ServicioDeleteArgs>(args: SelectSubset<T, ServicioDeleteArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicio.
     * @param {ServicioUpdateArgs} args - Arguments to update one Servicio.
     * @example
     * // Update one Servicio
     * const servicio = await prisma.servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicioUpdateArgs>(args: SelectSubset<T, ServicioUpdateArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {ServicioDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicioDeleteManyArgs>(args?: SelectSubset<T, ServicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicio = await prisma.servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicioUpdateManyArgs>(args: SelectSubset<T, ServicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio.
     * @param {ServicioUpsertArgs} args - Arguments to update or create a Servicio.
     * @example
     * // Update or create a Servicio
     * const servicio = await prisma.servicio.upsert({
     *   create: {
     *     // ... data to create a Servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio we want to update
     *   }
     * })
     */
    upsert<T extends ServicioUpsertArgs>(args: SelectSubset<T, ServicioUpsertArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicio.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends ServicioCountArgs>(
      args?: Subset<T, ServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioAggregateArgs>(args: Subset<T, ServicioAggregateArgs>): Prisma.PrismaPromise<GetServicioAggregateType<T>>

    /**
     * Group by Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicioGroupByArgs['orderBy'] }
        : { orderBy?: ServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Servicio model
   */
  readonly fields: ServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tarifa<T extends Servicio$tarifaArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$tarifaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findMany"> | Null>
    Servicio_Tipo_Servicio<T extends Tipo_ServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_ServicioDefaultArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Prestador_Servicio<T extends PrestadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrestadorDefaultArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Servicio model
   */ 
  interface ServicioFieldRefs {
    readonly id_servicio: FieldRef<"Servicio", 'Int'>
    readonly nombre: FieldRef<"Servicio", 'String'>
    readonly precio: FieldRef<"Servicio", 'Decimal'>
    readonly iva: FieldRef<"Servicio", 'Decimal'>
    readonly nivel: FieldRef<"Servicio", 'Int'>
    readonly tipo_servicio: FieldRef<"Servicio", 'Int'>
    readonly prestador: FieldRef<"Servicio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Servicio findUnique
   */
  export type ServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findUniqueOrThrow
   */
  export type ServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findFirst
   */
  export type ServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio findFirstOrThrow
   */
  export type ServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio findMany
   */
  export type ServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio create
   */
  export type ServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a Servicio.
     */
    data: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
  }

  /**
   * Servicio createMany
   */
  export type ServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servicios.
     */
    data: ServicioCreateManyInput | ServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Servicio update
   */
  export type ServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a Servicio.
     */
    data: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
    /**
     * Choose, which Servicio to update.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio updateMany
   */
  export type ServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servicios.
     */
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyInput>
    /**
     * Filter which Servicios to update
     */
    where?: ServicioWhereInput
  }

  /**
   * Servicio upsert
   */
  export type ServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the Servicio to update in case it exists.
     */
    where: ServicioWhereUniqueInput
    /**
     * In case the Servicio found by the `where` argument doesn't exist, create a new Servicio with this data.
     */
    create: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
    /**
     * In case the Servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
  }

  /**
   * Servicio delete
   */
  export type ServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter which Servicio to delete.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio deleteMany
   */
  export type ServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to delete
     */
    where?: ServicioWhereInput
  }

  /**
   * Servicio.tarifa
   */
  export type Servicio$tarifaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    where?: TarifaWhereInput
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    cursor?: TarifaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Servicio without action
   */
  export type ServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
  }


  /**
   * Model Examen
   */

  export type AggregateExamen = {
    _count: ExamenCountAggregateOutputType | null
    _avg: ExamenAvgAggregateOutputType | null
    _sum: ExamenSumAggregateOutputType | null
    _min: ExamenMinAggregateOutputType | null
    _max: ExamenMaxAggregateOutputType | null
  }

  export type ExamenAvgAggregateOutputType = {
    id_examen: number | null
    precio: Decimal | null
    tipo_examen: number | null
  }

  export type ExamenSumAggregateOutputType = {
    id_examen: number | null
    precio: Decimal | null
    tipo_examen: number | null
  }

  export type ExamenMinAggregateOutputType = {
    id_examen: number | null
    nombre: string | null
    unidades: string | null
    rango_biologico: string | null
    metodo: string | null
    precio: Decimal | null
    estado: $Enums.Estado | null
    tipo_examen: number | null
  }

  export type ExamenMaxAggregateOutputType = {
    id_examen: number | null
    nombre: string | null
    unidades: string | null
    rango_biologico: string | null
    metodo: string | null
    precio: Decimal | null
    estado: $Enums.Estado | null
    tipo_examen: number | null
  }

  export type ExamenCountAggregateOutputType = {
    id_examen: number
    nombre: number
    unidades: number
    rango_biologico: number
    metodo: number
    precio: number
    estado: number
    tipo_examen: number
    _all: number
  }


  export type ExamenAvgAggregateInputType = {
    id_examen?: true
    precio?: true
    tipo_examen?: true
  }

  export type ExamenSumAggregateInputType = {
    id_examen?: true
    precio?: true
    tipo_examen?: true
  }

  export type ExamenMinAggregateInputType = {
    id_examen?: true
    nombre?: true
    unidades?: true
    rango_biologico?: true
    metodo?: true
    precio?: true
    estado?: true
    tipo_examen?: true
  }

  export type ExamenMaxAggregateInputType = {
    id_examen?: true
    nombre?: true
    unidades?: true
    rango_biologico?: true
    metodo?: true
    precio?: true
    estado?: true
    tipo_examen?: true
  }

  export type ExamenCountAggregateInputType = {
    id_examen?: true
    nombre?: true
    unidades?: true
    rango_biologico?: true
    metodo?: true
    precio?: true
    estado?: true
    tipo_examen?: true
    _all?: true
  }

  export type ExamenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Examen to aggregate.
     */
    where?: ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examen to fetch.
     */
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Examen
    **/
    _count?: true | ExamenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamenMaxAggregateInputType
  }

  export type GetExamenAggregateType<T extends ExamenAggregateArgs> = {
        [P in keyof T & keyof AggregateExamen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamen[P]>
      : GetScalarType<T[P], AggregateExamen[P]>
  }




  export type ExamenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamenWhereInput
    orderBy?: ExamenOrderByWithAggregationInput | ExamenOrderByWithAggregationInput[]
    by: ExamenScalarFieldEnum[] | ExamenScalarFieldEnum
    having?: ExamenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamenCountAggregateInputType | true
    _avg?: ExamenAvgAggregateInputType
    _sum?: ExamenSumAggregateInputType
    _min?: ExamenMinAggregateInputType
    _max?: ExamenMaxAggregateInputType
  }

  export type ExamenGroupByOutputType = {
    id_examen: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal
    estado: $Enums.Estado
    tipo_examen: number
    _count: ExamenCountAggregateOutputType | null
    _avg: ExamenAvgAggregateOutputType | null
    _sum: ExamenSumAggregateOutputType | null
    _min: ExamenMinAggregateOutputType | null
    _max: ExamenMaxAggregateOutputType | null
  }

  type GetExamenGroupByPayload<T extends ExamenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamenGroupByOutputType[P]>
            : GetScalarType<T[P], ExamenGroupByOutputType[P]>
        }
      >
    >


  export type ExamenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_examen?: boolean
    nombre?: boolean
    unidades?: boolean
    rango_biologico?: boolean
    metodo?: boolean
    precio?: boolean
    estado?: boolean
    tipo_examen?: boolean
    tipo_resultado?: boolean | Examen$tipo_resultadoArgs<ExtArgs>
    tarifa?: boolean | Examen$tarifaArgs<ExtArgs>
    examen_tipo_examen?: boolean | Tipo_ExamenDefaultArgs<ExtArgs>
    _count?: boolean | ExamenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examen"]>


  export type ExamenSelectScalar = {
    id_examen?: boolean
    nombre?: boolean
    unidades?: boolean
    rango_biologico?: boolean
    metodo?: boolean
    precio?: boolean
    estado?: boolean
    tipo_examen?: boolean
  }

  export type ExamenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipo_resultado?: boolean | Examen$tipo_resultadoArgs<ExtArgs>
    tarifa?: boolean | Examen$tarifaArgs<ExtArgs>
    examen_tipo_examen?: boolean | Tipo_ExamenDefaultArgs<ExtArgs>
    _count?: boolean | ExamenCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Examen"
    objects: {
      tipo_resultado: Prisma.$Tipo_ResultadoPayload<ExtArgs>[]
      tarifa: Prisma.$TarifaPayload<ExtArgs>[]
      examen_tipo_examen: Prisma.$Tipo_ExamenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_examen: number
      nombre: string
      unidades: string
      rango_biologico: string
      metodo: string
      precio: Prisma.Decimal
      estado: $Enums.Estado
      tipo_examen: number
    }, ExtArgs["result"]["examen"]>
    composites: {}
  }

  type ExamenGetPayload<S extends boolean | null | undefined | ExamenDefaultArgs> = $Result.GetResult<Prisma.$ExamenPayload, S>

  type ExamenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamenCountAggregateInputType | true
    }

  export interface ExamenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Examen'], meta: { name: 'Examen' } }
    /**
     * Find zero or one Examen that matches the filter.
     * @param {ExamenFindUniqueArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamenFindUniqueArgs>(args: SelectSubset<T, ExamenFindUniqueArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Examen that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamenFindUniqueOrThrowArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamenFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenFindFirstArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamenFindFirstArgs>(args?: SelectSubset<T, ExamenFindFirstArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Examen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenFindFirstOrThrowArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamenFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Examen
     * const examen = await prisma.examen.findMany()
     * 
     * // Get first 10 Examen
     * const examen = await prisma.examen.findMany({ take: 10 })
     * 
     * // Only select the `id_examen`
     * const examenWithId_examenOnly = await prisma.examen.findMany({ select: { id_examen: true } })
     * 
     */
    findMany<T extends ExamenFindManyArgs>(args?: SelectSubset<T, ExamenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Examen.
     * @param {ExamenCreateArgs} args - Arguments to create a Examen.
     * @example
     * // Create one Examen
     * const Examen = await prisma.examen.create({
     *   data: {
     *     // ... data to create a Examen
     *   }
     * })
     * 
     */
    create<T extends ExamenCreateArgs>(args: SelectSubset<T, ExamenCreateArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Examen.
     * @param {ExamenCreateManyArgs} args - Arguments to create many Examen.
     * @example
     * // Create many Examen
     * const examen = await prisma.examen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamenCreateManyArgs>(args?: SelectSubset<T, ExamenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Examen.
     * @param {ExamenDeleteArgs} args - Arguments to delete one Examen.
     * @example
     * // Delete one Examen
     * const Examen = await prisma.examen.delete({
     *   where: {
     *     // ... filter to delete one Examen
     *   }
     * })
     * 
     */
    delete<T extends ExamenDeleteArgs>(args: SelectSubset<T, ExamenDeleteArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Examen.
     * @param {ExamenUpdateArgs} args - Arguments to update one Examen.
     * @example
     * // Update one Examen
     * const examen = await prisma.examen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamenUpdateArgs>(args: SelectSubset<T, ExamenUpdateArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Examen.
     * @param {ExamenDeleteManyArgs} args - Arguments to filter Examen to delete.
     * @example
     * // Delete a few Examen
     * const { count } = await prisma.examen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamenDeleteManyArgs>(args?: SelectSubset<T, ExamenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Examen
     * const examen = await prisma.examen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamenUpdateManyArgs>(args: SelectSubset<T, ExamenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Examen.
     * @param {ExamenUpsertArgs} args - Arguments to update or create a Examen.
     * @example
     * // Update or create a Examen
     * const examen = await prisma.examen.upsert({
     *   create: {
     *     // ... data to create a Examen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Examen we want to update
     *   }
     * })
     */
    upsert<T extends ExamenUpsertArgs>(args: SelectSubset<T, ExamenUpsertArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenCountArgs} args - Arguments to filter Examen to count.
     * @example
     * // Count the number of Examen
     * const count = await prisma.examen.count({
     *   where: {
     *     // ... the filter for the Examen we want to count
     *   }
     * })
    **/
    count<T extends ExamenCountArgs>(
      args?: Subset<T, ExamenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamenAggregateArgs>(args: Subset<T, ExamenAggregateArgs>): Prisma.PrismaPromise<GetExamenAggregateType<T>>

    /**
     * Group by Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamenGroupByArgs['orderBy'] }
        : { orderBy?: ExamenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Examen model
   */
  readonly fields: ExamenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Examen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipo_resultado<T extends Examen$tipo_resultadoArgs<ExtArgs> = {}>(args?: Subset<T, Examen$tipo_resultadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findMany"> | Null>
    tarifa<T extends Examen$tarifaArgs<ExtArgs> = {}>(args?: Subset<T, Examen$tarifaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findMany"> | Null>
    examen_tipo_examen<T extends Tipo_ExamenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_ExamenDefaultArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Examen model
   */ 
  interface ExamenFieldRefs {
    readonly id_examen: FieldRef<"Examen", 'Int'>
    readonly nombre: FieldRef<"Examen", 'String'>
    readonly unidades: FieldRef<"Examen", 'String'>
    readonly rango_biologico: FieldRef<"Examen", 'String'>
    readonly metodo: FieldRef<"Examen", 'String'>
    readonly precio: FieldRef<"Examen", 'Decimal'>
    readonly estado: FieldRef<"Examen", 'Estado'>
    readonly tipo_examen: FieldRef<"Examen", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Examen findUnique
   */
  export type ExamenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where: ExamenWhereUniqueInput
  }

  /**
   * Examen findUniqueOrThrow
   */
  export type ExamenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where: ExamenWhereUniqueInput
  }

  /**
   * Examen findFirst
   */
  export type ExamenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where?: ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examen to fetch.
     */
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examen.
     */
    cursor?: ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examen.
     */
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * Examen findFirstOrThrow
   */
  export type ExamenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where?: ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examen to fetch.
     */
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examen.
     */
    cursor?: ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examen.
     */
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * Examen findMany
   */
  export type ExamenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where?: ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examen to fetch.
     */
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Examen.
     */
    cursor?: ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examen.
     */
    skip?: number
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * Examen create
   */
  export type ExamenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * The data needed to create a Examen.
     */
    data: XOR<ExamenCreateInput, ExamenUncheckedCreateInput>
  }

  /**
   * Examen createMany
   */
  export type ExamenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Examen.
     */
    data: ExamenCreateManyInput | ExamenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Examen update
   */
  export type ExamenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * The data needed to update a Examen.
     */
    data: XOR<ExamenUpdateInput, ExamenUncheckedUpdateInput>
    /**
     * Choose, which Examen to update.
     */
    where: ExamenWhereUniqueInput
  }

  /**
   * Examen updateMany
   */
  export type ExamenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Examen.
     */
    data: XOR<ExamenUpdateManyMutationInput, ExamenUncheckedUpdateManyInput>
    /**
     * Filter which Examen to update
     */
    where?: ExamenWhereInput
  }

  /**
   * Examen upsert
   */
  export type ExamenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * The filter to search for the Examen to update in case it exists.
     */
    where: ExamenWhereUniqueInput
    /**
     * In case the Examen found by the `where` argument doesn't exist, create a new Examen with this data.
     */
    create: XOR<ExamenCreateInput, ExamenUncheckedCreateInput>
    /**
     * In case the Examen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamenUpdateInput, ExamenUncheckedUpdateInput>
  }

  /**
   * Examen delete
   */
  export type ExamenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter which Examen to delete.
     */
    where: ExamenWhereUniqueInput
  }

  /**
   * Examen deleteMany
   */
  export type ExamenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Examen to delete
     */
    where?: ExamenWhereInput
  }

  /**
   * Examen.tipo_resultado
   */
  export type Examen$tipo_resultadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    where?: Tipo_ResultadoWhereInput
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    cursor?: Tipo_ResultadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tipo_ResultadoScalarFieldEnum | Tipo_ResultadoScalarFieldEnum[]
  }

  /**
   * Examen.tarifa
   */
  export type Examen$tarifaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    where?: TarifaWhereInput
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    cursor?: TarifaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Examen without action
   */
  export type ExamenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
  }


  /**
   * Model Tipo_Resultado
   */

  export type AggregateTipo_Resultado = {
    _count: Tipo_ResultadoCountAggregateOutputType | null
    _avg: Tipo_ResultadoAvgAggregateOutputType | null
    _sum: Tipo_ResultadoSumAggregateOutputType | null
    _min: Tipo_ResultadoMinAggregateOutputType | null
    _max: Tipo_ResultadoMaxAggregateOutputType | null
  }

  export type Tipo_ResultadoAvgAggregateOutputType = {
    id_tipo_resultado: number | null
    examen: number | null
  }

  export type Tipo_ResultadoSumAggregateOutputType = {
    id_tipo_resultado: number | null
    examen: number | null
  }

  export type Tipo_ResultadoMinAggregateOutputType = {
    id_tipo_resultado: number | null
    nombre: string | null
    estado: $Enums.Estado | null
    examen: number | null
  }

  export type Tipo_ResultadoMaxAggregateOutputType = {
    id_tipo_resultado: number | null
    nombre: string | null
    estado: $Enums.Estado | null
    examen: number | null
  }

  export type Tipo_ResultadoCountAggregateOutputType = {
    id_tipo_resultado: number
    nombre: number
    estado: number
    examen: number
    _all: number
  }


  export type Tipo_ResultadoAvgAggregateInputType = {
    id_tipo_resultado?: true
    examen?: true
  }

  export type Tipo_ResultadoSumAggregateInputType = {
    id_tipo_resultado?: true
    examen?: true
  }

  export type Tipo_ResultadoMinAggregateInputType = {
    id_tipo_resultado?: true
    nombre?: true
    estado?: true
    examen?: true
  }

  export type Tipo_ResultadoMaxAggregateInputType = {
    id_tipo_resultado?: true
    nombre?: true
    estado?: true
    examen?: true
  }

  export type Tipo_ResultadoCountAggregateInputType = {
    id_tipo_resultado?: true
    nombre?: true
    estado?: true
    examen?: true
    _all?: true
  }

  export type Tipo_ResultadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Resultado to aggregate.
     */
    where?: Tipo_ResultadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Resultados to fetch.
     */
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tipo_ResultadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Resultados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Resultados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipo_Resultados
    **/
    _count?: true | Tipo_ResultadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_ResultadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_ResultadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_ResultadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_ResultadoMaxAggregateInputType
  }

  export type GetTipo_ResultadoAggregateType<T extends Tipo_ResultadoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_Resultado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_Resultado[P]>
      : GetScalarType<T[P], AggregateTipo_Resultado[P]>
  }




  export type Tipo_ResultadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ResultadoWhereInput
    orderBy?: Tipo_ResultadoOrderByWithAggregationInput | Tipo_ResultadoOrderByWithAggregationInput[]
    by: Tipo_ResultadoScalarFieldEnum[] | Tipo_ResultadoScalarFieldEnum
    having?: Tipo_ResultadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_ResultadoCountAggregateInputType | true
    _avg?: Tipo_ResultadoAvgAggregateInputType
    _sum?: Tipo_ResultadoSumAggregateInputType
    _min?: Tipo_ResultadoMinAggregateInputType
    _max?: Tipo_ResultadoMaxAggregateInputType
  }

  export type Tipo_ResultadoGroupByOutputType = {
    id_tipo_resultado: number
    nombre: string
    estado: $Enums.Estado
    examen: number
    _count: Tipo_ResultadoCountAggregateOutputType | null
    _avg: Tipo_ResultadoAvgAggregateOutputType | null
    _sum: Tipo_ResultadoSumAggregateOutputType | null
    _min: Tipo_ResultadoMinAggregateOutputType | null
    _max: Tipo_ResultadoMaxAggregateOutputType | null
  }

  type GetTipo_ResultadoGroupByPayload<T extends Tipo_ResultadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_ResultadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_ResultadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_ResultadoGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_ResultadoGroupByOutputType[P]>
        }
      >
    >


  export type Tipo_ResultadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_resultado?: boolean
    nombre?: boolean
    estado?: boolean
    examen?: boolean
    Tipo_Resultado_examen?: boolean | ExamenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_Resultado"]>


  export type Tipo_ResultadoSelectScalar = {
    id_tipo_resultado?: boolean
    nombre?: boolean
    estado?: boolean
    examen?: boolean
  }

  export type Tipo_ResultadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tipo_Resultado_examen?: boolean | ExamenDefaultArgs<ExtArgs>
  }

  export type $Tipo_ResultadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tipo_Resultado"
    objects: {
      Tipo_Resultado_examen: Prisma.$ExamenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_resultado: number
      nombre: string
      estado: $Enums.Estado
      examen: number
    }, ExtArgs["result"]["tipo_Resultado"]>
    composites: {}
  }

  type Tipo_ResultadoGetPayload<S extends boolean | null | undefined | Tipo_ResultadoDefaultArgs> = $Result.GetResult<Prisma.$Tipo_ResultadoPayload, S>

  type Tipo_ResultadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tipo_ResultadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_ResultadoCountAggregateInputType | true
    }

  export interface Tipo_ResultadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tipo_Resultado'], meta: { name: 'Tipo_Resultado' } }
    /**
     * Find zero or one Tipo_Resultado that matches the filter.
     * @param {Tipo_ResultadoFindUniqueArgs} args - Arguments to find a Tipo_Resultado
     * @example
     * // Get one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tipo_ResultadoFindUniqueArgs>(args: SelectSubset<T, Tipo_ResultadoFindUniqueArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_Resultado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Tipo_ResultadoFindUniqueOrThrowArgs} args - Arguments to find a Tipo_Resultado
     * @example
     * // Get one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tipo_ResultadoFindUniqueOrThrowArgs>(args: SelectSubset<T, Tipo_ResultadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_Resultado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoFindFirstArgs} args - Arguments to find a Tipo_Resultado
     * @example
     * // Get one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tipo_ResultadoFindFirstArgs>(args?: SelectSubset<T, Tipo_ResultadoFindFirstArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_Resultado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoFindFirstOrThrowArgs} args - Arguments to find a Tipo_Resultado
     * @example
     * // Get one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tipo_ResultadoFindFirstOrThrowArgs>(args?: SelectSubset<T, Tipo_ResultadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_Resultados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_Resultados
     * const tipo_Resultados = await prisma.tipo_Resultado.findMany()
     * 
     * // Get first 10 Tipo_Resultados
     * const tipo_Resultados = await prisma.tipo_Resultado.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_resultado`
     * const tipo_ResultadoWithId_tipo_resultadoOnly = await prisma.tipo_Resultado.findMany({ select: { id_tipo_resultado: true } })
     * 
     */
    findMany<T extends Tipo_ResultadoFindManyArgs>(args?: SelectSubset<T, Tipo_ResultadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_Resultado.
     * @param {Tipo_ResultadoCreateArgs} args - Arguments to create a Tipo_Resultado.
     * @example
     * // Create one Tipo_Resultado
     * const Tipo_Resultado = await prisma.tipo_Resultado.create({
     *   data: {
     *     // ... data to create a Tipo_Resultado
     *   }
     * })
     * 
     */
    create<T extends Tipo_ResultadoCreateArgs>(args: SelectSubset<T, Tipo_ResultadoCreateArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_Resultados.
     * @param {Tipo_ResultadoCreateManyArgs} args - Arguments to create many Tipo_Resultados.
     * @example
     * // Create many Tipo_Resultados
     * const tipo_Resultado = await prisma.tipo_Resultado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tipo_ResultadoCreateManyArgs>(args?: SelectSubset<T, Tipo_ResultadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_Resultado.
     * @param {Tipo_ResultadoDeleteArgs} args - Arguments to delete one Tipo_Resultado.
     * @example
     * // Delete one Tipo_Resultado
     * const Tipo_Resultado = await prisma.tipo_Resultado.delete({
     *   where: {
     *     // ... filter to delete one Tipo_Resultado
     *   }
     * })
     * 
     */
    delete<T extends Tipo_ResultadoDeleteArgs>(args: SelectSubset<T, Tipo_ResultadoDeleteArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_Resultado.
     * @param {Tipo_ResultadoUpdateArgs} args - Arguments to update one Tipo_Resultado.
     * @example
     * // Update one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tipo_ResultadoUpdateArgs>(args: SelectSubset<T, Tipo_ResultadoUpdateArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_Resultados.
     * @param {Tipo_ResultadoDeleteManyArgs} args - Arguments to filter Tipo_Resultados to delete.
     * @example
     * // Delete a few Tipo_Resultados
     * const { count } = await prisma.tipo_Resultado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tipo_ResultadoDeleteManyArgs>(args?: SelectSubset<T, Tipo_ResultadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_Resultados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_Resultados
     * const tipo_Resultado = await prisma.tipo_Resultado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tipo_ResultadoUpdateManyArgs>(args: SelectSubset<T, Tipo_ResultadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_Resultado.
     * @param {Tipo_ResultadoUpsertArgs} args - Arguments to update or create a Tipo_Resultado.
     * @example
     * // Update or create a Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.upsert({
     *   create: {
     *     // ... data to create a Tipo_Resultado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_Resultado we want to update
     *   }
     * })
     */
    upsert<T extends Tipo_ResultadoUpsertArgs>(args: SelectSubset<T, Tipo_ResultadoUpsertArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_Resultados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoCountArgs} args - Arguments to filter Tipo_Resultados to count.
     * @example
     * // Count the number of Tipo_Resultados
     * const count = await prisma.tipo_Resultado.count({
     *   where: {
     *     // ... the filter for the Tipo_Resultados we want to count
     *   }
     * })
    **/
    count<T extends Tipo_ResultadoCountArgs>(
      args?: Subset<T, Tipo_ResultadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_ResultadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_Resultado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_ResultadoAggregateArgs>(args: Subset<T, Tipo_ResultadoAggregateArgs>): Prisma.PrismaPromise<GetTipo_ResultadoAggregateType<T>>

    /**
     * Group by Tipo_Resultado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_ResultadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_ResultadoGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_ResultadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_ResultadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_ResultadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tipo_Resultado model
   */
  readonly fields: Tipo_ResultadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo_Resultado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tipo_ResultadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Tipo_Resultado_examen<T extends ExamenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamenDefaultArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tipo_Resultado model
   */ 
  interface Tipo_ResultadoFieldRefs {
    readonly id_tipo_resultado: FieldRef<"Tipo_Resultado", 'Int'>
    readonly nombre: FieldRef<"Tipo_Resultado", 'String'>
    readonly estado: FieldRef<"Tipo_Resultado", 'Estado'>
    readonly examen: FieldRef<"Tipo_Resultado", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tipo_Resultado findUnique
   */
  export type Tipo_ResultadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultado to fetch.
     */
    where: Tipo_ResultadoWhereUniqueInput
  }

  /**
   * Tipo_Resultado findUniqueOrThrow
   */
  export type Tipo_ResultadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultado to fetch.
     */
    where: Tipo_ResultadoWhereUniqueInput
  }

  /**
   * Tipo_Resultado findFirst
   */
  export type Tipo_ResultadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultado to fetch.
     */
    where?: Tipo_ResultadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Resultados to fetch.
     */
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Resultados.
     */
    cursor?: Tipo_ResultadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Resultados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Resultados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Resultados.
     */
    distinct?: Tipo_ResultadoScalarFieldEnum | Tipo_ResultadoScalarFieldEnum[]
  }

  /**
   * Tipo_Resultado findFirstOrThrow
   */
  export type Tipo_ResultadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultado to fetch.
     */
    where?: Tipo_ResultadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Resultados to fetch.
     */
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Resultados.
     */
    cursor?: Tipo_ResultadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Resultados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Resultados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Resultados.
     */
    distinct?: Tipo_ResultadoScalarFieldEnum | Tipo_ResultadoScalarFieldEnum[]
  }

  /**
   * Tipo_Resultado findMany
   */
  export type Tipo_ResultadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultados to fetch.
     */
    where?: Tipo_ResultadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Resultados to fetch.
     */
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipo_Resultados.
     */
    cursor?: Tipo_ResultadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Resultados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Resultados.
     */
    skip?: number
    distinct?: Tipo_ResultadoScalarFieldEnum | Tipo_ResultadoScalarFieldEnum[]
  }

  /**
   * Tipo_Resultado create
   */
  export type Tipo_ResultadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * The data needed to create a Tipo_Resultado.
     */
    data: XOR<Tipo_ResultadoCreateInput, Tipo_ResultadoUncheckedCreateInput>
  }

  /**
   * Tipo_Resultado createMany
   */
  export type Tipo_ResultadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tipo_Resultados.
     */
    data: Tipo_ResultadoCreateManyInput | Tipo_ResultadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tipo_Resultado update
   */
  export type Tipo_ResultadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * The data needed to update a Tipo_Resultado.
     */
    data: XOR<Tipo_ResultadoUpdateInput, Tipo_ResultadoUncheckedUpdateInput>
    /**
     * Choose, which Tipo_Resultado to update.
     */
    where: Tipo_ResultadoWhereUniqueInput
  }

  /**
   * Tipo_Resultado updateMany
   */
  export type Tipo_ResultadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tipo_Resultados.
     */
    data: XOR<Tipo_ResultadoUpdateManyMutationInput, Tipo_ResultadoUncheckedUpdateManyInput>
    /**
     * Filter which Tipo_Resultados to update
     */
    where?: Tipo_ResultadoWhereInput
  }

  /**
   * Tipo_Resultado upsert
   */
  export type Tipo_ResultadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * The filter to search for the Tipo_Resultado to update in case it exists.
     */
    where: Tipo_ResultadoWhereUniqueInput
    /**
     * In case the Tipo_Resultado found by the `where` argument doesn't exist, create a new Tipo_Resultado with this data.
     */
    create: XOR<Tipo_ResultadoCreateInput, Tipo_ResultadoUncheckedCreateInput>
    /**
     * In case the Tipo_Resultado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tipo_ResultadoUpdateInput, Tipo_ResultadoUncheckedUpdateInput>
  }

  /**
   * Tipo_Resultado delete
   */
  export type Tipo_ResultadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter which Tipo_Resultado to delete.
     */
    where: Tipo_ResultadoWhereUniqueInput
  }

  /**
   * Tipo_Resultado deleteMany
   */
  export type Tipo_ResultadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Resultados to delete
     */
    where?: Tipo_ResultadoWhereInput
  }

  /**
   * Tipo_Resultado without action
   */
  export type Tipo_ResultadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
  }


  /**
   * Model Tipo_Examen
   */

  export type AggregateTipo_Examen = {
    _count: Tipo_ExamenCountAggregateOutputType | null
    _avg: Tipo_ExamenAvgAggregateOutputType | null
    _sum: Tipo_ExamenSumAggregateOutputType | null
    _min: Tipo_ExamenMinAggregateOutputType | null
    _max: Tipo_ExamenMaxAggregateOutputType | null
  }

  export type Tipo_ExamenAvgAggregateOutputType = {
    id_tipo_examen: number | null
  }

  export type Tipo_ExamenSumAggregateOutputType = {
    id_tipo_examen: number | null
  }

  export type Tipo_ExamenMinAggregateOutputType = {
    id_tipo_examen: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type Tipo_ExamenMaxAggregateOutputType = {
    id_tipo_examen: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type Tipo_ExamenCountAggregateOutputType = {
    id_tipo_examen: number
    nombre: number
    estado: number
    _all: number
  }


  export type Tipo_ExamenAvgAggregateInputType = {
    id_tipo_examen?: true
  }

  export type Tipo_ExamenSumAggregateInputType = {
    id_tipo_examen?: true
  }

  export type Tipo_ExamenMinAggregateInputType = {
    id_tipo_examen?: true
    nombre?: true
    estado?: true
  }

  export type Tipo_ExamenMaxAggregateInputType = {
    id_tipo_examen?: true
    nombre?: true
    estado?: true
  }

  export type Tipo_ExamenCountAggregateInputType = {
    id_tipo_examen?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type Tipo_ExamenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Examen to aggregate.
     */
    where?: Tipo_ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Examen to fetch.
     */
    orderBy?: Tipo_ExamenOrderByWithRelationInput | Tipo_ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tipo_ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipo_Examen
    **/
    _count?: true | Tipo_ExamenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_ExamenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_ExamenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_ExamenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_ExamenMaxAggregateInputType
  }

  export type GetTipo_ExamenAggregateType<T extends Tipo_ExamenAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_Examen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_Examen[P]>
      : GetScalarType<T[P], AggregateTipo_Examen[P]>
  }




  export type Tipo_ExamenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ExamenWhereInput
    orderBy?: Tipo_ExamenOrderByWithAggregationInput | Tipo_ExamenOrderByWithAggregationInput[]
    by: Tipo_ExamenScalarFieldEnum[] | Tipo_ExamenScalarFieldEnum
    having?: Tipo_ExamenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_ExamenCountAggregateInputType | true
    _avg?: Tipo_ExamenAvgAggregateInputType
    _sum?: Tipo_ExamenSumAggregateInputType
    _min?: Tipo_ExamenMinAggregateInputType
    _max?: Tipo_ExamenMaxAggregateInputType
  }

  export type Tipo_ExamenGroupByOutputType = {
    id_tipo_examen: number
    nombre: string
    estado: $Enums.Estado
    _count: Tipo_ExamenCountAggregateOutputType | null
    _avg: Tipo_ExamenAvgAggregateOutputType | null
    _sum: Tipo_ExamenSumAggregateOutputType | null
    _min: Tipo_ExamenMinAggregateOutputType | null
    _max: Tipo_ExamenMaxAggregateOutputType | null
  }

  type GetTipo_ExamenGroupByPayload<T extends Tipo_ExamenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_ExamenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_ExamenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_ExamenGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_ExamenGroupByOutputType[P]>
        }
      >
    >


  export type Tipo_ExamenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_examen?: boolean
    nombre?: boolean
    estado?: boolean
    examen?: boolean | Tipo_Examen$examenArgs<ExtArgs>
    _count?: boolean | Tipo_ExamenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_Examen"]>


  export type Tipo_ExamenSelectScalar = {
    id_tipo_examen?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type Tipo_ExamenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examen?: boolean | Tipo_Examen$examenArgs<ExtArgs>
    _count?: boolean | Tipo_ExamenCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Tipo_ExamenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tipo_Examen"
    objects: {
      examen: Prisma.$ExamenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_examen: number
      nombre: string
      estado: $Enums.Estado
    }, ExtArgs["result"]["tipo_Examen"]>
    composites: {}
  }

  type Tipo_ExamenGetPayload<S extends boolean | null | undefined | Tipo_ExamenDefaultArgs> = $Result.GetResult<Prisma.$Tipo_ExamenPayload, S>

  type Tipo_ExamenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tipo_ExamenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_ExamenCountAggregateInputType | true
    }

  export interface Tipo_ExamenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tipo_Examen'], meta: { name: 'Tipo_Examen' } }
    /**
     * Find zero or one Tipo_Examen that matches the filter.
     * @param {Tipo_ExamenFindUniqueArgs} args - Arguments to find a Tipo_Examen
     * @example
     * // Get one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tipo_ExamenFindUniqueArgs>(args: SelectSubset<T, Tipo_ExamenFindUniqueArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_Examen that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Tipo_ExamenFindUniqueOrThrowArgs} args - Arguments to find a Tipo_Examen
     * @example
     * // Get one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tipo_ExamenFindUniqueOrThrowArgs>(args: SelectSubset<T, Tipo_ExamenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenFindFirstArgs} args - Arguments to find a Tipo_Examen
     * @example
     * // Get one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tipo_ExamenFindFirstArgs>(args?: SelectSubset<T, Tipo_ExamenFindFirstArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_Examen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenFindFirstOrThrowArgs} args - Arguments to find a Tipo_Examen
     * @example
     * // Get one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tipo_ExamenFindFirstOrThrowArgs>(args?: SelectSubset<T, Tipo_ExamenFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findMany()
     * 
     * // Get first 10 Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_examen`
     * const tipo_ExamenWithId_tipo_examenOnly = await prisma.tipo_Examen.findMany({ select: { id_tipo_examen: true } })
     * 
     */
    findMany<T extends Tipo_ExamenFindManyArgs>(args?: SelectSubset<T, Tipo_ExamenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_Examen.
     * @param {Tipo_ExamenCreateArgs} args - Arguments to create a Tipo_Examen.
     * @example
     * // Create one Tipo_Examen
     * const Tipo_Examen = await prisma.tipo_Examen.create({
     *   data: {
     *     // ... data to create a Tipo_Examen
     *   }
     * })
     * 
     */
    create<T extends Tipo_ExamenCreateArgs>(args: SelectSubset<T, Tipo_ExamenCreateArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_Examen.
     * @param {Tipo_ExamenCreateManyArgs} args - Arguments to create many Tipo_Examen.
     * @example
     * // Create many Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tipo_ExamenCreateManyArgs>(args?: SelectSubset<T, Tipo_ExamenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_Examen.
     * @param {Tipo_ExamenDeleteArgs} args - Arguments to delete one Tipo_Examen.
     * @example
     * // Delete one Tipo_Examen
     * const Tipo_Examen = await prisma.tipo_Examen.delete({
     *   where: {
     *     // ... filter to delete one Tipo_Examen
     *   }
     * })
     * 
     */
    delete<T extends Tipo_ExamenDeleteArgs>(args: SelectSubset<T, Tipo_ExamenDeleteArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_Examen.
     * @param {Tipo_ExamenUpdateArgs} args - Arguments to update one Tipo_Examen.
     * @example
     * // Update one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tipo_ExamenUpdateArgs>(args: SelectSubset<T, Tipo_ExamenUpdateArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_Examen.
     * @param {Tipo_ExamenDeleteManyArgs} args - Arguments to filter Tipo_Examen to delete.
     * @example
     * // Delete a few Tipo_Examen
     * const { count } = await prisma.tipo_Examen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tipo_ExamenDeleteManyArgs>(args?: SelectSubset<T, Tipo_ExamenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tipo_ExamenUpdateManyArgs>(args: SelectSubset<T, Tipo_ExamenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_Examen.
     * @param {Tipo_ExamenUpsertArgs} args - Arguments to update or create a Tipo_Examen.
     * @example
     * // Update or create a Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.upsert({
     *   create: {
     *     // ... data to create a Tipo_Examen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_Examen we want to update
     *   }
     * })
     */
    upsert<T extends Tipo_ExamenUpsertArgs>(args: SelectSubset<T, Tipo_ExamenUpsertArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenCountArgs} args - Arguments to filter Tipo_Examen to count.
     * @example
     * // Count the number of Tipo_Examen
     * const count = await prisma.tipo_Examen.count({
     *   where: {
     *     // ... the filter for the Tipo_Examen we want to count
     *   }
     * })
    **/
    count<T extends Tipo_ExamenCountArgs>(
      args?: Subset<T, Tipo_ExamenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_ExamenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_ExamenAggregateArgs>(args: Subset<T, Tipo_ExamenAggregateArgs>): Prisma.PrismaPromise<GetTipo_ExamenAggregateType<T>>

    /**
     * Group by Tipo_Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_ExamenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_ExamenGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_ExamenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_ExamenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_ExamenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tipo_Examen model
   */
  readonly fields: Tipo_ExamenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo_Examen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tipo_ExamenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examen<T extends Tipo_Examen$examenArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_Examen$examenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tipo_Examen model
   */ 
  interface Tipo_ExamenFieldRefs {
    readonly id_tipo_examen: FieldRef<"Tipo_Examen", 'Int'>
    readonly nombre: FieldRef<"Tipo_Examen", 'String'>
    readonly estado: FieldRef<"Tipo_Examen", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Tipo_Examen findUnique
   */
  export type Tipo_ExamenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where: Tipo_ExamenWhereUniqueInput
  }

  /**
   * Tipo_Examen findUniqueOrThrow
   */
  export type Tipo_ExamenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where: Tipo_ExamenWhereUniqueInput
  }

  /**
   * Tipo_Examen findFirst
   */
  export type Tipo_ExamenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where?: Tipo_ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Examen to fetch.
     */
    orderBy?: Tipo_ExamenOrderByWithRelationInput | Tipo_ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Examen.
     */
    cursor?: Tipo_ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Examen.
     */
    distinct?: Tipo_ExamenScalarFieldEnum | Tipo_ExamenScalarFieldEnum[]
  }

  /**
   * Tipo_Examen findFirstOrThrow
   */
  export type Tipo_ExamenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where?: Tipo_ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Examen to fetch.
     */
    orderBy?: Tipo_ExamenOrderByWithRelationInput | Tipo_ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Examen.
     */
    cursor?: Tipo_ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Examen.
     */
    distinct?: Tipo_ExamenScalarFieldEnum | Tipo_ExamenScalarFieldEnum[]
  }

  /**
   * Tipo_Examen findMany
   */
  export type Tipo_ExamenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where?: Tipo_ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Examen to fetch.
     */
    orderBy?: Tipo_ExamenOrderByWithRelationInput | Tipo_ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipo_Examen.
     */
    cursor?: Tipo_ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Examen.
     */
    skip?: number
    distinct?: Tipo_ExamenScalarFieldEnum | Tipo_ExamenScalarFieldEnum[]
  }

  /**
   * Tipo_Examen create
   */
  export type Tipo_ExamenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * The data needed to create a Tipo_Examen.
     */
    data: XOR<Tipo_ExamenCreateInput, Tipo_ExamenUncheckedCreateInput>
  }

  /**
   * Tipo_Examen createMany
   */
  export type Tipo_ExamenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tipo_Examen.
     */
    data: Tipo_ExamenCreateManyInput | Tipo_ExamenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tipo_Examen update
   */
  export type Tipo_ExamenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * The data needed to update a Tipo_Examen.
     */
    data: XOR<Tipo_ExamenUpdateInput, Tipo_ExamenUncheckedUpdateInput>
    /**
     * Choose, which Tipo_Examen to update.
     */
    where: Tipo_ExamenWhereUniqueInput
  }

  /**
   * Tipo_Examen updateMany
   */
  export type Tipo_ExamenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tipo_Examen.
     */
    data: XOR<Tipo_ExamenUpdateManyMutationInput, Tipo_ExamenUncheckedUpdateManyInput>
    /**
     * Filter which Tipo_Examen to update
     */
    where?: Tipo_ExamenWhereInput
  }

  /**
   * Tipo_Examen upsert
   */
  export type Tipo_ExamenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * The filter to search for the Tipo_Examen to update in case it exists.
     */
    where: Tipo_ExamenWhereUniqueInput
    /**
     * In case the Tipo_Examen found by the `where` argument doesn't exist, create a new Tipo_Examen with this data.
     */
    create: XOR<Tipo_ExamenCreateInput, Tipo_ExamenUncheckedCreateInput>
    /**
     * In case the Tipo_Examen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tipo_ExamenUpdateInput, Tipo_ExamenUncheckedUpdateInput>
  }

  /**
   * Tipo_Examen delete
   */
  export type Tipo_ExamenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter which Tipo_Examen to delete.
     */
    where: Tipo_ExamenWhereUniqueInput
  }

  /**
   * Tipo_Examen deleteMany
   */
  export type Tipo_ExamenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Examen to delete
     */
    where?: Tipo_ExamenWhereInput
  }

  /**
   * Tipo_Examen.examen
   */
  export type Tipo_Examen$examenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    where?: ExamenWhereInput
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    cursor?: ExamenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * Tipo_Examen without action
   */
  export type Tipo_ExamenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
  }


  /**
   * Model Prestador
   */

  export type AggregatePrestador = {
    _count: PrestadorCountAggregateOutputType | null
    _avg: PrestadorAvgAggregateOutputType | null
    _sum: PrestadorSumAggregateOutputType | null
    _min: PrestadorMinAggregateOutputType | null
    _max: PrestadorMaxAggregateOutputType | null
  }

  export type PrestadorAvgAggregateOutputType = {
    id_prestador: number | null
    codigo: number | null
  }

  export type PrestadorSumAggregateOutputType = {
    id_prestador: number | null
    codigo: bigint | null
  }

  export type PrestadorMinAggregateOutputType = {
    id_prestador: number | null
    codigo: bigint | null
    nit: string | null
    razon_social: string | null
  }

  export type PrestadorMaxAggregateOutputType = {
    id_prestador: number | null
    codigo: bigint | null
    nit: string | null
    razon_social: string | null
  }

  export type PrestadorCountAggregateOutputType = {
    id_prestador: number
    codigo: number
    nit: number
    razon_social: number
    _all: number
  }


  export type PrestadorAvgAggregateInputType = {
    id_prestador?: true
    codigo?: true
  }

  export type PrestadorSumAggregateInputType = {
    id_prestador?: true
    codigo?: true
  }

  export type PrestadorMinAggregateInputType = {
    id_prestador?: true
    codigo?: true
    nit?: true
    razon_social?: true
  }

  export type PrestadorMaxAggregateInputType = {
    id_prestador?: true
    codigo?: true
    nit?: true
    razon_social?: true
  }

  export type PrestadorCountAggregateInputType = {
    id_prestador?: true
    codigo?: true
    nit?: true
    razon_social?: true
    _all?: true
  }

  export type PrestadorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prestador to aggregate.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prestadors
    **/
    _count?: true | PrestadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrestadorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrestadorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrestadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrestadorMaxAggregateInputType
  }

  export type GetPrestadorAggregateType<T extends PrestadorAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestador[P]>
      : GetScalarType<T[P], AggregatePrestador[P]>
  }




  export type PrestadorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrestadorWhereInput
    orderBy?: PrestadorOrderByWithAggregationInput | PrestadorOrderByWithAggregationInput[]
    by: PrestadorScalarFieldEnum[] | PrestadorScalarFieldEnum
    having?: PrestadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrestadorCountAggregateInputType | true
    _avg?: PrestadorAvgAggregateInputType
    _sum?: PrestadorSumAggregateInputType
    _min?: PrestadorMinAggregateInputType
    _max?: PrestadorMaxAggregateInputType
  }

  export type PrestadorGroupByOutputType = {
    id_prestador: number
    codigo: bigint
    nit: string
    razon_social: string
    _count: PrestadorCountAggregateOutputType | null
    _avg: PrestadorAvgAggregateOutputType | null
    _sum: PrestadorSumAggregateOutputType | null
    _min: PrestadorMinAggregateOutputType | null
    _max: PrestadorMaxAggregateOutputType | null
  }

  type GetPrestadorGroupByPayload<T extends PrestadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrestadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrestadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrestadorGroupByOutputType[P]>
            : GetScalarType<T[P], PrestadorGroupByOutputType[P]>
        }
      >
    >


  export type PrestadorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_prestador?: boolean
    codigo?: boolean
    nit?: boolean
    razon_social?: boolean
    servicio?: boolean | Prestador$servicioArgs<ExtArgs>
    profesional?: boolean | Prestador$profesionalArgs<ExtArgs>
    _count?: boolean | PrestadorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prestador"]>


  export type PrestadorSelectScalar = {
    id_prestador?: boolean
    codigo?: boolean
    nit?: boolean
    razon_social?: boolean
  }

  export type PrestadorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Prestador$servicioArgs<ExtArgs>
    profesional?: boolean | Prestador$profesionalArgs<ExtArgs>
    _count?: boolean | PrestadorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PrestadorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prestador"
    objects: {
      servicio: Prisma.$ServicioPayload<ExtArgs>[]
      profesional: Prisma.$ProfesionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_prestador: number
      codigo: bigint
      nit: string
      razon_social: string
    }, ExtArgs["result"]["prestador"]>
    composites: {}
  }

  type PrestadorGetPayload<S extends boolean | null | undefined | PrestadorDefaultArgs> = $Result.GetResult<Prisma.$PrestadorPayload, S>

  type PrestadorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrestadorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrestadorCountAggregateInputType | true
    }

  export interface PrestadorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prestador'], meta: { name: 'Prestador' } }
    /**
     * Find zero or one Prestador that matches the filter.
     * @param {PrestadorFindUniqueArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrestadorFindUniqueArgs>(args: SelectSubset<T, PrestadorFindUniqueArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prestador that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrestadorFindUniqueOrThrowArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrestadorFindUniqueOrThrowArgs>(args: SelectSubset<T, PrestadorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prestador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindFirstArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrestadorFindFirstArgs>(args?: SelectSubset<T, PrestadorFindFirstArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prestador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindFirstOrThrowArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrestadorFindFirstOrThrowArgs>(args?: SelectSubset<T, PrestadorFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prestadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prestadors
     * const prestadors = await prisma.prestador.findMany()
     * 
     * // Get first 10 Prestadors
     * const prestadors = await prisma.prestador.findMany({ take: 10 })
     * 
     * // Only select the `id_prestador`
     * const prestadorWithId_prestadorOnly = await prisma.prestador.findMany({ select: { id_prestador: true } })
     * 
     */
    findMany<T extends PrestadorFindManyArgs>(args?: SelectSubset<T, PrestadorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prestador.
     * @param {PrestadorCreateArgs} args - Arguments to create a Prestador.
     * @example
     * // Create one Prestador
     * const Prestador = await prisma.prestador.create({
     *   data: {
     *     // ... data to create a Prestador
     *   }
     * })
     * 
     */
    create<T extends PrestadorCreateArgs>(args: SelectSubset<T, PrestadorCreateArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prestadors.
     * @param {PrestadorCreateManyArgs} args - Arguments to create many Prestadors.
     * @example
     * // Create many Prestadors
     * const prestador = await prisma.prestador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrestadorCreateManyArgs>(args?: SelectSubset<T, PrestadorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prestador.
     * @param {PrestadorDeleteArgs} args - Arguments to delete one Prestador.
     * @example
     * // Delete one Prestador
     * const Prestador = await prisma.prestador.delete({
     *   where: {
     *     // ... filter to delete one Prestador
     *   }
     * })
     * 
     */
    delete<T extends PrestadorDeleteArgs>(args: SelectSubset<T, PrestadorDeleteArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prestador.
     * @param {PrestadorUpdateArgs} args - Arguments to update one Prestador.
     * @example
     * // Update one Prestador
     * const prestador = await prisma.prestador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrestadorUpdateArgs>(args: SelectSubset<T, PrestadorUpdateArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prestadors.
     * @param {PrestadorDeleteManyArgs} args - Arguments to filter Prestadors to delete.
     * @example
     * // Delete a few Prestadors
     * const { count } = await prisma.prestador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrestadorDeleteManyArgs>(args?: SelectSubset<T, PrestadorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prestadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prestadors
     * const prestador = await prisma.prestador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrestadorUpdateManyArgs>(args: SelectSubset<T, PrestadorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prestador.
     * @param {PrestadorUpsertArgs} args - Arguments to update or create a Prestador.
     * @example
     * // Update or create a Prestador
     * const prestador = await prisma.prestador.upsert({
     *   create: {
     *     // ... data to create a Prestador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prestador we want to update
     *   }
     * })
     */
    upsert<T extends PrestadorUpsertArgs>(args: SelectSubset<T, PrestadorUpsertArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prestadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorCountArgs} args - Arguments to filter Prestadors to count.
     * @example
     * // Count the number of Prestadors
     * const count = await prisma.prestador.count({
     *   where: {
     *     // ... the filter for the Prestadors we want to count
     *   }
     * })
    **/
    count<T extends PrestadorCountArgs>(
      args?: Subset<T, PrestadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrestadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prestador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrestadorAggregateArgs>(args: Subset<T, PrestadorAggregateArgs>): Prisma.PrismaPromise<GetPrestadorAggregateType<T>>

    /**
     * Group by Prestador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrestadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrestadorGroupByArgs['orderBy'] }
        : { orderBy?: PrestadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrestadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prestador model
   */
  readonly fields: PrestadorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prestador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrestadorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends Prestador$servicioArgs<ExtArgs> = {}>(args?: Subset<T, Prestador$servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany"> | Null>
    profesional<T extends Prestador$profesionalArgs<ExtArgs> = {}>(args?: Subset<T, Prestador$profesionalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prestador model
   */ 
  interface PrestadorFieldRefs {
    readonly id_prestador: FieldRef<"Prestador", 'Int'>
    readonly codigo: FieldRef<"Prestador", 'BigInt'>
    readonly nit: FieldRef<"Prestador", 'String'>
    readonly razon_social: FieldRef<"Prestador", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prestador findUnique
   */
  export type PrestadorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador findUniqueOrThrow
   */
  export type PrestadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador findFirst
   */
  export type PrestadorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prestadors.
     */
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador findFirstOrThrow
   */
  export type PrestadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prestadors.
     */
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador findMany
   */
  export type PrestadorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestadors to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador create
   */
  export type PrestadorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The data needed to create a Prestador.
     */
    data: XOR<PrestadorCreateInput, PrestadorUncheckedCreateInput>
  }

  /**
   * Prestador createMany
   */
  export type PrestadorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prestadors.
     */
    data: PrestadorCreateManyInput | PrestadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prestador update
   */
  export type PrestadorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The data needed to update a Prestador.
     */
    data: XOR<PrestadorUpdateInput, PrestadorUncheckedUpdateInput>
    /**
     * Choose, which Prestador to update.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador updateMany
   */
  export type PrestadorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prestadors.
     */
    data: XOR<PrestadorUpdateManyMutationInput, PrestadorUncheckedUpdateManyInput>
    /**
     * Filter which Prestadors to update
     */
    where?: PrestadorWhereInput
  }

  /**
   * Prestador upsert
   */
  export type PrestadorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The filter to search for the Prestador to update in case it exists.
     */
    where: PrestadorWhereUniqueInput
    /**
     * In case the Prestador found by the `where` argument doesn't exist, create a new Prestador with this data.
     */
    create: XOR<PrestadorCreateInput, PrestadorUncheckedCreateInput>
    /**
     * In case the Prestador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrestadorUpdateInput, PrestadorUncheckedUpdateInput>
  }

  /**
   * Prestador delete
   */
  export type PrestadorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter which Prestador to delete.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador deleteMany
   */
  export type PrestadorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prestadors to delete
     */
    where?: PrestadorWhereInput
  }

  /**
   * Prestador.servicio
   */
  export type Prestador$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    cursor?: ServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Prestador.profesional
   */
  export type Prestador$profesionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    where?: ProfesionalWhereInput
    orderBy?: ProfesionalOrderByWithRelationInput | ProfesionalOrderByWithRelationInput[]
    cursor?: ProfesionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfesionalScalarFieldEnum | ProfesionalScalarFieldEnum[]
  }

  /**
   * Prestador without action
   */
  export type PrestadorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
  }


  /**
   * Model Profesional
   */

  export type AggregateProfesional = {
    _count: ProfesionalCountAggregateOutputType | null
    _avg: ProfesionalAvgAggregateOutputType | null
    _sum: ProfesionalSumAggregateOutputType | null
    _min: ProfesionalMinAggregateOutputType | null
    _max: ProfesionalMaxAggregateOutputType | null
  }

  export type ProfesionalAvgAggregateOutputType = {
    id_profesional: number | null
    identificacion: number | null
    prestador: number | null
  }

  export type ProfesionalSumAggregateOutputType = {
    id_profesional: number | null
    identificacion: bigint | null
    prestador: number | null
  }

  export type ProfesionalMinAggregateOutputType = {
    id_profesional: number | null
    identificacion: bigint | null
    nombre: string | null
    cargo: string | null
    rol: $Enums.Rol | null
    email: string | null
    password: string | null
    estado: $Enums.Estado | null
    prestador: number | null
  }

  export type ProfesionalMaxAggregateOutputType = {
    id_profesional: number | null
    identificacion: bigint | null
    nombre: string | null
    cargo: string | null
    rol: $Enums.Rol | null
    email: string | null
    password: string | null
    estado: $Enums.Estado | null
    prestador: number | null
  }

  export type ProfesionalCountAggregateOutputType = {
    id_profesional: number
    identificacion: number
    nombre: number
    cargo: number
    rol: number
    email: number
    password: number
    estado: number
    prestador: number
    _all: number
  }


  export type ProfesionalAvgAggregateInputType = {
    id_profesional?: true
    identificacion?: true
    prestador?: true
  }

  export type ProfesionalSumAggregateInputType = {
    id_profesional?: true
    identificacion?: true
    prestador?: true
  }

  export type ProfesionalMinAggregateInputType = {
    id_profesional?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    email?: true
    password?: true
    estado?: true
    prestador?: true
  }

  export type ProfesionalMaxAggregateInputType = {
    id_profesional?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    email?: true
    password?: true
    estado?: true
    prestador?: true
  }

  export type ProfesionalCountAggregateInputType = {
    id_profesional?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    email?: true
    password?: true
    estado?: true
    prestador?: true
    _all?: true
  }

  export type ProfesionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profesional to aggregate.
     */
    where?: ProfesionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesionals to fetch.
     */
    orderBy?: ProfesionalOrderByWithRelationInput | ProfesionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfesionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profesionals
    **/
    _count?: true | ProfesionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfesionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfesionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfesionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfesionalMaxAggregateInputType
  }

  export type GetProfesionalAggregateType<T extends ProfesionalAggregateArgs> = {
        [P in keyof T & keyof AggregateProfesional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfesional[P]>
      : GetScalarType<T[P], AggregateProfesional[P]>
  }




  export type ProfesionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfesionalWhereInput
    orderBy?: ProfesionalOrderByWithAggregationInput | ProfesionalOrderByWithAggregationInput[]
    by: ProfesionalScalarFieldEnum[] | ProfesionalScalarFieldEnum
    having?: ProfesionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfesionalCountAggregateInputType | true
    _avg?: ProfesionalAvgAggregateInputType
    _sum?: ProfesionalSumAggregateInputType
    _min?: ProfesionalMinAggregateInputType
    _max?: ProfesionalMaxAggregateInputType
  }

  export type ProfesionalGroupByOutputType = {
    id_profesional: number
    identificacion: bigint
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado: $Enums.Estado
    prestador: number
    _count: ProfesionalCountAggregateOutputType | null
    _avg: ProfesionalAvgAggregateOutputType | null
    _sum: ProfesionalSumAggregateOutputType | null
    _min: ProfesionalMinAggregateOutputType | null
    _max: ProfesionalMaxAggregateOutputType | null
  }

  type GetProfesionalGroupByPayload<T extends ProfesionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfesionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfesionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfesionalGroupByOutputType[P]>
            : GetScalarType<T[P], ProfesionalGroupByOutputType[P]>
        }
      >
    >


  export type ProfesionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_profesional?: boolean
    identificacion?: boolean
    nombre?: boolean
    cargo?: boolean
    rol?: boolean
    email?: boolean
    password?: boolean
    estado?: boolean
    prestador?: boolean
    Propefisonal_Presatador?: boolean | PrestadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profesional"]>


  export type ProfesionalSelectScalar = {
    id_profesional?: boolean
    identificacion?: boolean
    nombre?: boolean
    cargo?: boolean
    rol?: boolean
    email?: boolean
    password?: boolean
    estado?: boolean
    prestador?: boolean
  }

  export type ProfesionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Propefisonal_Presatador?: boolean | PrestadorDefaultArgs<ExtArgs>
  }

  export type $ProfesionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profesional"
    objects: {
      Propefisonal_Presatador: Prisma.$PrestadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_profesional: number
      identificacion: bigint
      nombre: string
      cargo: string
      rol: $Enums.Rol
      email: string
      password: string
      estado: $Enums.Estado
      prestador: number
    }, ExtArgs["result"]["profesional"]>
    composites: {}
  }

  type ProfesionalGetPayload<S extends boolean | null | undefined | ProfesionalDefaultArgs> = $Result.GetResult<Prisma.$ProfesionalPayload, S>

  type ProfesionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfesionalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfesionalCountAggregateInputType | true
    }

  export interface ProfesionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profesional'], meta: { name: 'Profesional' } }
    /**
     * Find zero or one Profesional that matches the filter.
     * @param {ProfesionalFindUniqueArgs} args - Arguments to find a Profesional
     * @example
     * // Get one Profesional
     * const profesional = await prisma.profesional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfesionalFindUniqueArgs>(args: SelectSubset<T, ProfesionalFindUniqueArgs<ExtArgs>>): Prisma__ProfesionalClient<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profesional that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfesionalFindUniqueOrThrowArgs} args - Arguments to find a Profesional
     * @example
     * // Get one Profesional
     * const profesional = await prisma.profesional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfesionalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfesionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfesionalClient<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profesional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesionalFindFirstArgs} args - Arguments to find a Profesional
     * @example
     * // Get one Profesional
     * const profesional = await prisma.profesional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfesionalFindFirstArgs>(args?: SelectSubset<T, ProfesionalFindFirstArgs<ExtArgs>>): Prisma__ProfesionalClient<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profesional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesionalFindFirstOrThrowArgs} args - Arguments to find a Profesional
     * @example
     * // Get one Profesional
     * const profesional = await prisma.profesional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfesionalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfesionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfesionalClient<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profesionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profesionals
     * const profesionals = await prisma.profesional.findMany()
     * 
     * // Get first 10 Profesionals
     * const profesionals = await prisma.profesional.findMany({ take: 10 })
     * 
     * // Only select the `id_profesional`
     * const profesionalWithId_profesionalOnly = await prisma.profesional.findMany({ select: { id_profesional: true } })
     * 
     */
    findMany<T extends ProfesionalFindManyArgs>(args?: SelectSubset<T, ProfesionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profesional.
     * @param {ProfesionalCreateArgs} args - Arguments to create a Profesional.
     * @example
     * // Create one Profesional
     * const Profesional = await prisma.profesional.create({
     *   data: {
     *     // ... data to create a Profesional
     *   }
     * })
     * 
     */
    create<T extends ProfesionalCreateArgs>(args: SelectSubset<T, ProfesionalCreateArgs<ExtArgs>>): Prisma__ProfesionalClient<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profesionals.
     * @param {ProfesionalCreateManyArgs} args - Arguments to create many Profesionals.
     * @example
     * // Create many Profesionals
     * const profesional = await prisma.profesional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfesionalCreateManyArgs>(args?: SelectSubset<T, ProfesionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profesional.
     * @param {ProfesionalDeleteArgs} args - Arguments to delete one Profesional.
     * @example
     * // Delete one Profesional
     * const Profesional = await prisma.profesional.delete({
     *   where: {
     *     // ... filter to delete one Profesional
     *   }
     * })
     * 
     */
    delete<T extends ProfesionalDeleteArgs>(args: SelectSubset<T, ProfesionalDeleteArgs<ExtArgs>>): Prisma__ProfesionalClient<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profesional.
     * @param {ProfesionalUpdateArgs} args - Arguments to update one Profesional.
     * @example
     * // Update one Profesional
     * const profesional = await prisma.profesional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfesionalUpdateArgs>(args: SelectSubset<T, ProfesionalUpdateArgs<ExtArgs>>): Prisma__ProfesionalClient<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profesionals.
     * @param {ProfesionalDeleteManyArgs} args - Arguments to filter Profesionals to delete.
     * @example
     * // Delete a few Profesionals
     * const { count } = await prisma.profesional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfesionalDeleteManyArgs>(args?: SelectSubset<T, ProfesionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profesionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profesionals
     * const profesional = await prisma.profesional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfesionalUpdateManyArgs>(args: SelectSubset<T, ProfesionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profesional.
     * @param {ProfesionalUpsertArgs} args - Arguments to update or create a Profesional.
     * @example
     * // Update or create a Profesional
     * const profesional = await prisma.profesional.upsert({
     *   create: {
     *     // ... data to create a Profesional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profesional we want to update
     *   }
     * })
     */
    upsert<T extends ProfesionalUpsertArgs>(args: SelectSubset<T, ProfesionalUpsertArgs<ExtArgs>>): Prisma__ProfesionalClient<$Result.GetResult<Prisma.$ProfesionalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profesionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesionalCountArgs} args - Arguments to filter Profesionals to count.
     * @example
     * // Count the number of Profesionals
     * const count = await prisma.profesional.count({
     *   where: {
     *     // ... the filter for the Profesionals we want to count
     *   }
     * })
    **/
    count<T extends ProfesionalCountArgs>(
      args?: Subset<T, ProfesionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfesionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profesional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfesionalAggregateArgs>(args: Subset<T, ProfesionalAggregateArgs>): Prisma.PrismaPromise<GetProfesionalAggregateType<T>>

    /**
     * Group by Profesional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfesionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfesionalGroupByArgs['orderBy'] }
        : { orderBy?: ProfesionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfesionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfesionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profesional model
   */
  readonly fields: ProfesionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profesional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfesionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Propefisonal_Presatador<T extends PrestadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrestadorDefaultArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profesional model
   */ 
  interface ProfesionalFieldRefs {
    readonly id_profesional: FieldRef<"Profesional", 'Int'>
    readonly identificacion: FieldRef<"Profesional", 'BigInt'>
    readonly nombre: FieldRef<"Profesional", 'String'>
    readonly cargo: FieldRef<"Profesional", 'String'>
    readonly rol: FieldRef<"Profesional", 'Rol'>
    readonly email: FieldRef<"Profesional", 'String'>
    readonly password: FieldRef<"Profesional", 'String'>
    readonly estado: FieldRef<"Profesional", 'Estado'>
    readonly prestador: FieldRef<"Profesional", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Profesional findUnique
   */
  export type ProfesionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * Filter, which Profesional to fetch.
     */
    where: ProfesionalWhereUniqueInput
  }

  /**
   * Profesional findUniqueOrThrow
   */
  export type ProfesionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * Filter, which Profesional to fetch.
     */
    where: ProfesionalWhereUniqueInput
  }

  /**
   * Profesional findFirst
   */
  export type ProfesionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * Filter, which Profesional to fetch.
     */
    where?: ProfesionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesionals to fetch.
     */
    orderBy?: ProfesionalOrderByWithRelationInput | ProfesionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profesionals.
     */
    cursor?: ProfesionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profesionals.
     */
    distinct?: ProfesionalScalarFieldEnum | ProfesionalScalarFieldEnum[]
  }

  /**
   * Profesional findFirstOrThrow
   */
  export type ProfesionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * Filter, which Profesional to fetch.
     */
    where?: ProfesionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesionals to fetch.
     */
    orderBy?: ProfesionalOrderByWithRelationInput | ProfesionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profesionals.
     */
    cursor?: ProfesionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profesionals.
     */
    distinct?: ProfesionalScalarFieldEnum | ProfesionalScalarFieldEnum[]
  }

  /**
   * Profesional findMany
   */
  export type ProfesionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * Filter, which Profesionals to fetch.
     */
    where?: ProfesionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profesionals to fetch.
     */
    orderBy?: ProfesionalOrderByWithRelationInput | ProfesionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profesionals.
     */
    cursor?: ProfesionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profesionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profesionals.
     */
    skip?: number
    distinct?: ProfesionalScalarFieldEnum | ProfesionalScalarFieldEnum[]
  }

  /**
   * Profesional create
   */
  export type ProfesionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * The data needed to create a Profesional.
     */
    data: XOR<ProfesionalCreateInput, ProfesionalUncheckedCreateInput>
  }

  /**
   * Profesional createMany
   */
  export type ProfesionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profesionals.
     */
    data: ProfesionalCreateManyInput | ProfesionalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profesional update
   */
  export type ProfesionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * The data needed to update a Profesional.
     */
    data: XOR<ProfesionalUpdateInput, ProfesionalUncheckedUpdateInput>
    /**
     * Choose, which Profesional to update.
     */
    where: ProfesionalWhereUniqueInput
  }

  /**
   * Profesional updateMany
   */
  export type ProfesionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profesionals.
     */
    data: XOR<ProfesionalUpdateManyMutationInput, ProfesionalUncheckedUpdateManyInput>
    /**
     * Filter which Profesionals to update
     */
    where?: ProfesionalWhereInput
  }

  /**
   * Profesional upsert
   */
  export type ProfesionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * The filter to search for the Profesional to update in case it exists.
     */
    where: ProfesionalWhereUniqueInput
    /**
     * In case the Profesional found by the `where` argument doesn't exist, create a new Profesional with this data.
     */
    create: XOR<ProfesionalCreateInput, ProfesionalUncheckedCreateInput>
    /**
     * In case the Profesional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfesionalUpdateInput, ProfesionalUncheckedUpdateInput>
  }

  /**
   * Profesional delete
   */
  export type ProfesionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
    /**
     * Filter which Profesional to delete.
     */
    where: ProfesionalWhereUniqueInput
  }

  /**
   * Profesional deleteMany
   */
  export type ProfesionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profesionals to delete
     */
    where?: ProfesionalWhereInput
  }

  /**
   * Profesional without action
   */
  export type ProfesionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profesional
     */
    select?: ProfesionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfesionalInclude<ExtArgs> | null
  }


  /**
   * Model Empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaAvgAggregateOutputType = {
    id_empresa: number | null
    codigo: number | null
    municipio: number | null
  }

  export type EmpresaSumAggregateOutputType = {
    id_empresa: number | null
    codigo: number | null
    municipio: number | null
  }

  export type EmpresaMinAggregateOutputType = {
    id_empresa: number | null
    nit: string | null
    codigo: number | null
    nombre: string | null
    sigla: string | null
    tipo: $Enums.Tipo_Empresa | null
    estado: $Enums.Estado | null
    municipio: number | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id_empresa: number | null
    nit: string | null
    codigo: number | null
    nombre: string | null
    sigla: string | null
    tipo: $Enums.Tipo_Empresa | null
    estado: $Enums.Estado | null
    municipio: number | null
  }

  export type EmpresaCountAggregateOutputType = {
    id_empresa: number
    nit: number
    codigo: number
    nombre: number
    sigla: number
    tipo: number
    estado: number
    municipio: number
    _all: number
  }


  export type EmpresaAvgAggregateInputType = {
    id_empresa?: true
    codigo?: true
    municipio?: true
  }

  export type EmpresaSumAggregateInputType = {
    id_empresa?: true
    codigo?: true
    municipio?: true
  }

  export type EmpresaMinAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipio?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipio?: true
  }

  export type EmpresaCountAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipio?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresa to aggregate.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithAggregationInput | EmpresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: EmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _avg?: EmpresaAvgAggregateInputType
    _sum?: EmpresaSumAggregateInputType
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id_empresa: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipio: number
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empresa?: boolean
    nit?: boolean
    codigo?: boolean
    nombre?: boolean
    sigla?: boolean
    tipo?: boolean
    estado?: boolean
    municipio?: boolean
    contrato?: boolean | Empresa$contratoArgs<ExtArgs>
    Muncipio_Empresa?: boolean | MunicipioDefaultArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>


  export type EmpresaSelectScalar = {
    id_empresa?: boolean
    nit?: boolean
    codigo?: boolean
    nombre?: boolean
    sigla?: boolean
    tipo?: boolean
    estado?: boolean
    municipio?: boolean
  }

  export type EmpresaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contrato?: boolean | Empresa$contratoArgs<ExtArgs>
    Muncipio_Empresa?: boolean | MunicipioDefaultArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmpresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empresa"
    objects: {
      contrato: Prisma.$ContratoPayload<ExtArgs>[]
      Muncipio_Empresa: Prisma.$MunicipioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_empresa: number
      nit: string
      codigo: number
      nombre: string
      sigla: string
      tipo: $Enums.Tipo_Empresa
      estado: $Enums.Estado
      municipio: number
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type EmpresaGetPayload<S extends boolean | null | undefined | EmpresaDefaultArgs> = $Result.GetResult<Prisma.$EmpresaPayload, S>

  type EmpresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface EmpresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empresa'], meta: { name: 'Empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {EmpresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaFindUniqueArgs>(args: SelectSubset<T, EmpresaFindUniqueArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaFindFirstArgs>(args?: SelectSubset<T, EmpresaFindFirstArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id_empresa`
     * const empresaWithId_empresaOnly = await prisma.empresa.findMany({ select: { id_empresa: true } })
     * 
     */
    findMany<T extends EmpresaFindManyArgs>(args?: SelectSubset<T, EmpresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empresa.
     * @param {EmpresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends EmpresaCreateArgs>(args: SelectSubset<T, EmpresaCreateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empresas.
     * @param {EmpresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaCreateManyArgs>(args?: SelectSubset<T, EmpresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empresa.
     * @param {EmpresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends EmpresaDeleteArgs>(args: SelectSubset<T, EmpresaDeleteArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empresa.
     * @param {EmpresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaUpdateArgs>(args: SelectSubset<T, EmpresaUpdateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {EmpresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaDeleteManyArgs>(args?: SelectSubset<T, EmpresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaUpdateManyArgs>(args: SelectSubset<T, EmpresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {EmpresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaUpsertArgs>(args: SelectSubset<T, EmpresaUpsertArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends EmpresaCountArgs>(
      args?: Subset<T, EmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empresa model
   */
  readonly fields: EmpresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contrato<T extends Empresa$contratoArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$contratoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findMany"> | Null>
    Muncipio_Empresa<T extends MunicipioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipioDefaultArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empresa model
   */ 
  interface EmpresaFieldRefs {
    readonly id_empresa: FieldRef<"Empresa", 'Int'>
    readonly nit: FieldRef<"Empresa", 'String'>
    readonly codigo: FieldRef<"Empresa", 'Int'>
    readonly nombre: FieldRef<"Empresa", 'String'>
    readonly sigla: FieldRef<"Empresa", 'String'>
    readonly tipo: FieldRef<"Empresa", 'Tipo_Empresa'>
    readonly estado: FieldRef<"Empresa", 'Estado'>
    readonly municipio: FieldRef<"Empresa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Empresa findUnique
   */
  export type EmpresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findUniqueOrThrow
   */
  export type EmpresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findFirst
   */
  export type EmpresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findFirstOrThrow
   */
  export type EmpresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findMany
   */
  export type EmpresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresas to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa create
   */
  export type EmpresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to create a Empresa.
     */
    data: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
  }

  /**
   * Empresa createMany
   */
  export type EmpresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa update
   */
  export type EmpresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to update a Empresa.
     */
    data: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
    /**
     * Choose, which Empresa to update.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa updateMany
   */
  export type EmpresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa upsert
   */
  export type EmpresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The filter to search for the Empresa to update in case it exists.
     */
    where: EmpresaWhereUniqueInput
    /**
     * In case the Empresa found by the `where` argument doesn't exist, create a new Empresa with this data.
     */
    create: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
    /**
     * In case the Empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
  }

  /**
   * Empresa delete
   */
  export type EmpresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter which Empresa to delete.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa deleteMany
   */
  export type EmpresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresas to delete
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa.contrato
   */
  export type Empresa$contratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    where?: ContratoWhereInput
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    cursor?: ContratoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Empresa without action
   */
  export type EmpresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
  }


  /**
   * Model Contrato
   */

  export type AggregateContrato = {
    _count: ContratoCountAggregateOutputType | null
    _avg: ContratoAvgAggregateOutputType | null
    _sum: ContratoSumAggregateOutputType | null
    _min: ContratoMinAggregateOutputType | null
    _max: ContratoMaxAggregateOutputType | null
  }

  export type ContratoAvgAggregateOutputType = {
    id_contrato: number | null
    empresa: number | null
  }

  export type ContratoSumAggregateOutputType = {
    id_contrato: number | null
    empresa: number | null
  }

  export type ContratoMinAggregateOutputType = {
    id_contrato: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: $Enums.Estado | null
    empresa: number | null
  }

  export type ContratoMaxAggregateOutputType = {
    id_contrato: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: $Enums.Estado | null
    empresa: number | null
  }

  export type ContratoCountAggregateOutputType = {
    id_contrato: number
    fecha_inicio: number
    fecha_fin: number
    estado: number
    empresa: number
    _all: number
  }


  export type ContratoAvgAggregateInputType = {
    id_contrato?: true
    empresa?: true
  }

  export type ContratoSumAggregateInputType = {
    id_contrato?: true
    empresa?: true
  }

  export type ContratoMinAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresa?: true
  }

  export type ContratoMaxAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresa?: true
  }

  export type ContratoCountAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresa?: true
    _all?: true
  }

  export type ContratoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contrato to aggregate.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contratoes
    **/
    _count?: true | ContratoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContratoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContratoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContratoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContratoMaxAggregateInputType
  }

  export type GetContratoAggregateType<T extends ContratoAggregateArgs> = {
        [P in keyof T & keyof AggregateContrato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContrato[P]>
      : GetScalarType<T[P], AggregateContrato[P]>
  }




  export type ContratoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratoWhereInput
    orderBy?: ContratoOrderByWithAggregationInput | ContratoOrderByWithAggregationInput[]
    by: ContratoScalarFieldEnum[] | ContratoScalarFieldEnum
    having?: ContratoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContratoCountAggregateInputType | true
    _avg?: ContratoAvgAggregateInputType
    _sum?: ContratoSumAggregateInputType
    _min?: ContratoMinAggregateInputType
    _max?: ContratoMaxAggregateInputType
  }

  export type ContratoGroupByOutputType = {
    id_contrato: number
    fecha_inicio: Date
    fecha_fin: Date
    estado: $Enums.Estado
    empresa: number
    _count: ContratoCountAggregateOutputType | null
    _avg: ContratoAvgAggregateOutputType | null
    _sum: ContratoSumAggregateOutputType | null
    _min: ContratoMinAggregateOutputType | null
    _max: ContratoMaxAggregateOutputType | null
  }

  type GetContratoGroupByPayload<T extends ContratoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContratoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContratoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContratoGroupByOutputType[P]>
            : GetScalarType<T[P], ContratoGroupByOutputType[P]>
        }
      >
    >


  export type ContratoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_contrato?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empresa?: boolean
    tarifa?: boolean | Contrato$tarifaArgs<ExtArgs>
    procedimiento?: boolean | Contrato$procedimientoArgs<ExtArgs>
    Contrato_Empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    _count?: boolean | ContratoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contrato"]>


  export type ContratoSelectScalar = {
    id_contrato?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empresa?: boolean
  }

  export type ContratoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarifa?: boolean | Contrato$tarifaArgs<ExtArgs>
    procedimiento?: boolean | Contrato$procedimientoArgs<ExtArgs>
    Contrato_Empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    _count?: boolean | ContratoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContratoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contrato"
    objects: {
      tarifa: Prisma.$TarifaPayload<ExtArgs>[]
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>[]
      Contrato_Empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_contrato: number
      fecha_inicio: Date
      fecha_fin: Date
      estado: $Enums.Estado
      empresa: number
    }, ExtArgs["result"]["contrato"]>
    composites: {}
  }

  type ContratoGetPayload<S extends boolean | null | undefined | ContratoDefaultArgs> = $Result.GetResult<Prisma.$ContratoPayload, S>

  type ContratoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContratoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContratoCountAggregateInputType | true
    }

  export interface ContratoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contrato'], meta: { name: 'Contrato' } }
    /**
     * Find zero or one Contrato that matches the filter.
     * @param {ContratoFindUniqueArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContratoFindUniqueArgs>(args: SelectSubset<T, ContratoFindUniqueArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contrato that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContratoFindUniqueOrThrowArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContratoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContratoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contrato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindFirstArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContratoFindFirstArgs>(args?: SelectSubset<T, ContratoFindFirstArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contrato that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindFirstOrThrowArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContratoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContratoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contratoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contratoes
     * const contratoes = await prisma.contrato.findMany()
     * 
     * // Get first 10 Contratoes
     * const contratoes = await prisma.contrato.findMany({ take: 10 })
     * 
     * // Only select the `id_contrato`
     * const contratoWithId_contratoOnly = await prisma.contrato.findMany({ select: { id_contrato: true } })
     * 
     */
    findMany<T extends ContratoFindManyArgs>(args?: SelectSubset<T, ContratoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contrato.
     * @param {ContratoCreateArgs} args - Arguments to create a Contrato.
     * @example
     * // Create one Contrato
     * const Contrato = await prisma.contrato.create({
     *   data: {
     *     // ... data to create a Contrato
     *   }
     * })
     * 
     */
    create<T extends ContratoCreateArgs>(args: SelectSubset<T, ContratoCreateArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contratoes.
     * @param {ContratoCreateManyArgs} args - Arguments to create many Contratoes.
     * @example
     * // Create many Contratoes
     * const contrato = await prisma.contrato.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContratoCreateManyArgs>(args?: SelectSubset<T, ContratoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contrato.
     * @param {ContratoDeleteArgs} args - Arguments to delete one Contrato.
     * @example
     * // Delete one Contrato
     * const Contrato = await prisma.contrato.delete({
     *   where: {
     *     // ... filter to delete one Contrato
     *   }
     * })
     * 
     */
    delete<T extends ContratoDeleteArgs>(args: SelectSubset<T, ContratoDeleteArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contrato.
     * @param {ContratoUpdateArgs} args - Arguments to update one Contrato.
     * @example
     * // Update one Contrato
     * const contrato = await prisma.contrato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContratoUpdateArgs>(args: SelectSubset<T, ContratoUpdateArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contratoes.
     * @param {ContratoDeleteManyArgs} args - Arguments to filter Contratoes to delete.
     * @example
     * // Delete a few Contratoes
     * const { count } = await prisma.contrato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContratoDeleteManyArgs>(args?: SelectSubset<T, ContratoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contratoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contratoes
     * const contrato = await prisma.contrato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContratoUpdateManyArgs>(args: SelectSubset<T, ContratoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contrato.
     * @param {ContratoUpsertArgs} args - Arguments to update or create a Contrato.
     * @example
     * // Update or create a Contrato
     * const contrato = await prisma.contrato.upsert({
     *   create: {
     *     // ... data to create a Contrato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contrato we want to update
     *   }
     * })
     */
    upsert<T extends ContratoUpsertArgs>(args: SelectSubset<T, ContratoUpsertArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contratoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoCountArgs} args - Arguments to filter Contratoes to count.
     * @example
     * // Count the number of Contratoes
     * const count = await prisma.contrato.count({
     *   where: {
     *     // ... the filter for the Contratoes we want to count
     *   }
     * })
    **/
    count<T extends ContratoCountArgs>(
      args?: Subset<T, ContratoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContratoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contrato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContratoAggregateArgs>(args: Subset<T, ContratoAggregateArgs>): Prisma.PrismaPromise<GetContratoAggregateType<T>>

    /**
     * Group by Contrato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContratoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContratoGroupByArgs['orderBy'] }
        : { orderBy?: ContratoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContratoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContratoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contrato model
   */
  readonly fields: ContratoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contrato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContratoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tarifa<T extends Contrato$tarifaArgs<ExtArgs> = {}>(args?: Subset<T, Contrato$tarifaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findMany"> | Null>
    procedimiento<T extends Contrato$procedimientoArgs<ExtArgs> = {}>(args?: Subset<T, Contrato$procedimientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany"> | Null>
    Contrato_Empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contrato model
   */ 
  interface ContratoFieldRefs {
    readonly id_contrato: FieldRef<"Contrato", 'Int'>
    readonly fecha_inicio: FieldRef<"Contrato", 'DateTime'>
    readonly fecha_fin: FieldRef<"Contrato", 'DateTime'>
    readonly estado: FieldRef<"Contrato", 'Estado'>
    readonly empresa: FieldRef<"Contrato", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Contrato findUnique
   */
  export type ContratoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato findUniqueOrThrow
   */
  export type ContratoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato findFirst
   */
  export type ContratoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contratoes.
     */
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato findFirstOrThrow
   */
  export type ContratoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contratoes.
     */
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato findMany
   */
  export type ContratoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contratoes to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato create
   */
  export type ContratoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The data needed to create a Contrato.
     */
    data: XOR<ContratoCreateInput, ContratoUncheckedCreateInput>
  }

  /**
   * Contrato createMany
   */
  export type ContratoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contratoes.
     */
    data: ContratoCreateManyInput | ContratoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contrato update
   */
  export type ContratoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The data needed to update a Contrato.
     */
    data: XOR<ContratoUpdateInput, ContratoUncheckedUpdateInput>
    /**
     * Choose, which Contrato to update.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato updateMany
   */
  export type ContratoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contratoes.
     */
    data: XOR<ContratoUpdateManyMutationInput, ContratoUncheckedUpdateManyInput>
    /**
     * Filter which Contratoes to update
     */
    where?: ContratoWhereInput
  }

  /**
   * Contrato upsert
   */
  export type ContratoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The filter to search for the Contrato to update in case it exists.
     */
    where: ContratoWhereUniqueInput
    /**
     * In case the Contrato found by the `where` argument doesn't exist, create a new Contrato with this data.
     */
    create: XOR<ContratoCreateInput, ContratoUncheckedCreateInput>
    /**
     * In case the Contrato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContratoUpdateInput, ContratoUncheckedUpdateInput>
  }

  /**
   * Contrato delete
   */
  export type ContratoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter which Contrato to delete.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato deleteMany
   */
  export type ContratoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contratoes to delete
     */
    where?: ContratoWhereInput
  }

  /**
   * Contrato.tarifa
   */
  export type Contrato$tarifaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    where?: TarifaWhereInput
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    cursor?: TarifaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Contrato.procedimiento
   */
  export type Contrato$procedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    cursor?: ProcedimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Contrato without action
   */
  export type ContratoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
  }


  /**
   * Model Tarifa
   */

  export type AggregateTarifa = {
    _count: TarifaCountAggregateOutputType | null
    _avg: TarifaAvgAggregateOutputType | null
    _sum: TarifaSumAggregateOutputType | null
    _min: TarifaMinAggregateOutputType | null
    _max: TarifaMaxAggregateOutputType | null
  }

  export type TarifaAvgAggregateOutputType = {
    id_tarifa: number | null
    precio: Decimal | null
    examen: number | null
    contrato: number | null
    servicio: number | null
  }

  export type TarifaSumAggregateOutputType = {
    id_tarifa: number | null
    precio: Decimal | null
    examen: number | null
    contrato: number | null
    servicio: number | null
  }

  export type TarifaMinAggregateOutputType = {
    id_tarifa: number | null
    estado: $Enums.Estado | null
    precio: Decimal | null
    createAt: Date | null
    updateAt: Date | null
    examen: number | null
    contrato: number | null
    servicio: number | null
  }

  export type TarifaMaxAggregateOutputType = {
    id_tarifa: number | null
    estado: $Enums.Estado | null
    precio: Decimal | null
    createAt: Date | null
    updateAt: Date | null
    examen: number | null
    contrato: number | null
    servicio: number | null
  }

  export type TarifaCountAggregateOutputType = {
    id_tarifa: number
    estado: number
    precio: number
    createAt: number
    updateAt: number
    examen: number
    contrato: number
    servicio: number
    _all: number
  }


  export type TarifaAvgAggregateInputType = {
    id_tarifa?: true
    precio?: true
    examen?: true
    contrato?: true
    servicio?: true
  }

  export type TarifaSumAggregateInputType = {
    id_tarifa?: true
    precio?: true
    examen?: true
    contrato?: true
    servicio?: true
  }

  export type TarifaMinAggregateInputType = {
    id_tarifa?: true
    estado?: true
    precio?: true
    createAt?: true
    updateAt?: true
    examen?: true
    contrato?: true
    servicio?: true
  }

  export type TarifaMaxAggregateInputType = {
    id_tarifa?: true
    estado?: true
    precio?: true
    createAt?: true
    updateAt?: true
    examen?: true
    contrato?: true
    servicio?: true
  }

  export type TarifaCountAggregateInputType = {
    id_tarifa?: true
    estado?: true
    precio?: true
    createAt?: true
    updateAt?: true
    examen?: true
    contrato?: true
    servicio?: true
    _all?: true
  }

  export type TarifaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tarifa to aggregate.
     */
    where?: TarifaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifas to fetch.
     */
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TarifaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tarifas
    **/
    _count?: true | TarifaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TarifaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TarifaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TarifaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TarifaMaxAggregateInputType
  }

  export type GetTarifaAggregateType<T extends TarifaAggregateArgs> = {
        [P in keyof T & keyof AggregateTarifa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarifa[P]>
      : GetScalarType<T[P], AggregateTarifa[P]>
  }




  export type TarifaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TarifaWhereInput
    orderBy?: TarifaOrderByWithAggregationInput | TarifaOrderByWithAggregationInput[]
    by: TarifaScalarFieldEnum[] | TarifaScalarFieldEnum
    having?: TarifaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TarifaCountAggregateInputType | true
    _avg?: TarifaAvgAggregateInputType
    _sum?: TarifaSumAggregateInputType
    _min?: TarifaMinAggregateInputType
    _max?: TarifaMaxAggregateInputType
  }

  export type TarifaGroupByOutputType = {
    id_tarifa: number
    estado: $Enums.Estado
    precio: Decimal
    createAt: Date
    updateAt: Date
    examen: number
    contrato: number
    servicio: number
    _count: TarifaCountAggregateOutputType | null
    _avg: TarifaAvgAggregateOutputType | null
    _sum: TarifaSumAggregateOutputType | null
    _min: TarifaMinAggregateOutputType | null
    _max: TarifaMaxAggregateOutputType | null
  }

  type GetTarifaGroupByPayload<T extends TarifaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TarifaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TarifaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TarifaGroupByOutputType[P]>
            : GetScalarType<T[P], TarifaGroupByOutputType[P]>
        }
      >
    >


  export type TarifaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tarifa?: boolean
    estado?: boolean
    precio?: boolean
    createAt?: boolean
    updateAt?: boolean
    examen?: boolean
    contrato?: boolean
    servicio?: boolean
    estudio?: boolean | Tarifa$estudioArgs<ExtArgs>
    Tarifa_Examen?: boolean | ExamenDefaultArgs<ExtArgs>
    Tarifa_Contrato?: boolean | ContratoDefaultArgs<ExtArgs>
    Tarifa_Servicio?: boolean | ServicioDefaultArgs<ExtArgs>
    _count?: boolean | TarifaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tarifa"]>


  export type TarifaSelectScalar = {
    id_tarifa?: boolean
    estado?: boolean
    precio?: boolean
    createAt?: boolean
    updateAt?: boolean
    examen?: boolean
    contrato?: boolean
    servicio?: boolean
  }

  export type TarifaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudio?: boolean | Tarifa$estudioArgs<ExtArgs>
    Tarifa_Examen?: boolean | ExamenDefaultArgs<ExtArgs>
    Tarifa_Contrato?: boolean | ContratoDefaultArgs<ExtArgs>
    Tarifa_Servicio?: boolean | ServicioDefaultArgs<ExtArgs>
    _count?: boolean | TarifaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TarifaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tarifa"
    objects: {
      estudio: Prisma.$EstudioPayload<ExtArgs>[]
      Tarifa_Examen: Prisma.$ExamenPayload<ExtArgs>
      Tarifa_Contrato: Prisma.$ContratoPayload<ExtArgs>
      Tarifa_Servicio: Prisma.$ServicioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tarifa: number
      estado: $Enums.Estado
      precio: Prisma.Decimal
      createAt: Date
      updateAt: Date
      examen: number
      contrato: number
      servicio: number
    }, ExtArgs["result"]["tarifa"]>
    composites: {}
  }

  type TarifaGetPayload<S extends boolean | null | undefined | TarifaDefaultArgs> = $Result.GetResult<Prisma.$TarifaPayload, S>

  type TarifaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TarifaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TarifaCountAggregateInputType | true
    }

  export interface TarifaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tarifa'], meta: { name: 'Tarifa' } }
    /**
     * Find zero or one Tarifa that matches the filter.
     * @param {TarifaFindUniqueArgs} args - Arguments to find a Tarifa
     * @example
     * // Get one Tarifa
     * const tarifa = await prisma.tarifa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TarifaFindUniqueArgs>(args: SelectSubset<T, TarifaFindUniqueArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tarifa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TarifaFindUniqueOrThrowArgs} args - Arguments to find a Tarifa
     * @example
     * // Get one Tarifa
     * const tarifa = await prisma.tarifa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TarifaFindUniqueOrThrowArgs>(args: SelectSubset<T, TarifaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tarifa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaFindFirstArgs} args - Arguments to find a Tarifa
     * @example
     * // Get one Tarifa
     * const tarifa = await prisma.tarifa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TarifaFindFirstArgs>(args?: SelectSubset<T, TarifaFindFirstArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tarifa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaFindFirstOrThrowArgs} args - Arguments to find a Tarifa
     * @example
     * // Get one Tarifa
     * const tarifa = await prisma.tarifa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TarifaFindFirstOrThrowArgs>(args?: SelectSubset<T, TarifaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tarifas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tarifas
     * const tarifas = await prisma.tarifa.findMany()
     * 
     * // Get first 10 Tarifas
     * const tarifas = await prisma.tarifa.findMany({ take: 10 })
     * 
     * // Only select the `id_tarifa`
     * const tarifaWithId_tarifaOnly = await prisma.tarifa.findMany({ select: { id_tarifa: true } })
     * 
     */
    findMany<T extends TarifaFindManyArgs>(args?: SelectSubset<T, TarifaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tarifa.
     * @param {TarifaCreateArgs} args - Arguments to create a Tarifa.
     * @example
     * // Create one Tarifa
     * const Tarifa = await prisma.tarifa.create({
     *   data: {
     *     // ... data to create a Tarifa
     *   }
     * })
     * 
     */
    create<T extends TarifaCreateArgs>(args: SelectSubset<T, TarifaCreateArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tarifas.
     * @param {TarifaCreateManyArgs} args - Arguments to create many Tarifas.
     * @example
     * // Create many Tarifas
     * const tarifa = await prisma.tarifa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TarifaCreateManyArgs>(args?: SelectSubset<T, TarifaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tarifa.
     * @param {TarifaDeleteArgs} args - Arguments to delete one Tarifa.
     * @example
     * // Delete one Tarifa
     * const Tarifa = await prisma.tarifa.delete({
     *   where: {
     *     // ... filter to delete one Tarifa
     *   }
     * })
     * 
     */
    delete<T extends TarifaDeleteArgs>(args: SelectSubset<T, TarifaDeleteArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tarifa.
     * @param {TarifaUpdateArgs} args - Arguments to update one Tarifa.
     * @example
     * // Update one Tarifa
     * const tarifa = await prisma.tarifa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TarifaUpdateArgs>(args: SelectSubset<T, TarifaUpdateArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tarifas.
     * @param {TarifaDeleteManyArgs} args - Arguments to filter Tarifas to delete.
     * @example
     * // Delete a few Tarifas
     * const { count } = await prisma.tarifa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TarifaDeleteManyArgs>(args?: SelectSubset<T, TarifaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tarifas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tarifas
     * const tarifa = await prisma.tarifa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TarifaUpdateManyArgs>(args: SelectSubset<T, TarifaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tarifa.
     * @param {TarifaUpsertArgs} args - Arguments to update or create a Tarifa.
     * @example
     * // Update or create a Tarifa
     * const tarifa = await prisma.tarifa.upsert({
     *   create: {
     *     // ... data to create a Tarifa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tarifa we want to update
     *   }
     * })
     */
    upsert<T extends TarifaUpsertArgs>(args: SelectSubset<T, TarifaUpsertArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tarifas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaCountArgs} args - Arguments to filter Tarifas to count.
     * @example
     * // Count the number of Tarifas
     * const count = await prisma.tarifa.count({
     *   where: {
     *     // ... the filter for the Tarifas we want to count
     *   }
     * })
    **/
    count<T extends TarifaCountArgs>(
      args?: Subset<T, TarifaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TarifaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tarifa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TarifaAggregateArgs>(args: Subset<T, TarifaAggregateArgs>): Prisma.PrismaPromise<GetTarifaAggregateType<T>>

    /**
     * Group by Tarifa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TarifaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TarifaGroupByArgs['orderBy'] }
        : { orderBy?: TarifaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TarifaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTarifaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tarifa model
   */
  readonly fields: TarifaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tarifa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TarifaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudio<T extends Tarifa$estudioArgs<ExtArgs> = {}>(args?: Subset<T, Tarifa$estudioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findMany"> | Null>
    Tarifa_Examen<T extends ExamenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamenDefaultArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tarifa_Contrato<T extends ContratoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContratoDefaultArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tarifa_Servicio<T extends ServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicioDefaultArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tarifa model
   */ 
  interface TarifaFieldRefs {
    readonly id_tarifa: FieldRef<"Tarifa", 'Int'>
    readonly estado: FieldRef<"Tarifa", 'Estado'>
    readonly precio: FieldRef<"Tarifa", 'Decimal'>
    readonly createAt: FieldRef<"Tarifa", 'DateTime'>
    readonly updateAt: FieldRef<"Tarifa", 'DateTime'>
    readonly examen: FieldRef<"Tarifa", 'Int'>
    readonly contrato: FieldRef<"Tarifa", 'Int'>
    readonly servicio: FieldRef<"Tarifa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tarifa findUnique
   */
  export type TarifaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifa to fetch.
     */
    where: TarifaWhereUniqueInput
  }

  /**
   * Tarifa findUniqueOrThrow
   */
  export type TarifaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifa to fetch.
     */
    where: TarifaWhereUniqueInput
  }

  /**
   * Tarifa findFirst
   */
  export type TarifaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifa to fetch.
     */
    where?: TarifaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifas to fetch.
     */
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tarifas.
     */
    cursor?: TarifaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tarifas.
     */
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Tarifa findFirstOrThrow
   */
  export type TarifaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifa to fetch.
     */
    where?: TarifaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifas to fetch.
     */
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tarifas.
     */
    cursor?: TarifaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tarifas.
     */
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Tarifa findMany
   */
  export type TarifaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifas to fetch.
     */
    where?: TarifaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifas to fetch.
     */
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tarifas.
     */
    cursor?: TarifaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifas.
     */
    skip?: number
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Tarifa create
   */
  export type TarifaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * The data needed to create a Tarifa.
     */
    data: XOR<TarifaCreateInput, TarifaUncheckedCreateInput>
  }

  /**
   * Tarifa createMany
   */
  export type TarifaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tarifas.
     */
    data: TarifaCreateManyInput | TarifaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tarifa update
   */
  export type TarifaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * The data needed to update a Tarifa.
     */
    data: XOR<TarifaUpdateInput, TarifaUncheckedUpdateInput>
    /**
     * Choose, which Tarifa to update.
     */
    where: TarifaWhereUniqueInput
  }

  /**
   * Tarifa updateMany
   */
  export type TarifaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tarifas.
     */
    data: XOR<TarifaUpdateManyMutationInput, TarifaUncheckedUpdateManyInput>
    /**
     * Filter which Tarifas to update
     */
    where?: TarifaWhereInput
  }

  /**
   * Tarifa upsert
   */
  export type TarifaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * The filter to search for the Tarifa to update in case it exists.
     */
    where: TarifaWhereUniqueInput
    /**
     * In case the Tarifa found by the `where` argument doesn't exist, create a new Tarifa with this data.
     */
    create: XOR<TarifaCreateInput, TarifaUncheckedCreateInput>
    /**
     * In case the Tarifa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TarifaUpdateInput, TarifaUncheckedUpdateInput>
  }

  /**
   * Tarifa delete
   */
  export type TarifaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter which Tarifa to delete.
     */
    where: TarifaWhereUniqueInput
  }

  /**
   * Tarifa deleteMany
   */
  export type TarifaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tarifas to delete
     */
    where?: TarifaWhereInput
  }

  /**
   * Tarifa.estudio
   */
  export type Tarifa$estudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    where?: EstudioWhereInput
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    cursor?: EstudioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Tarifa without action
   */
  export type TarifaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id_usuario: 'id_usuario',
    tipo_identificacion: 'tipo_identificacion',
    identificacion: 'identificacion',
    primer_nombre: 'primer_nombre',
    segundo_nombre: 'segundo_nombre',
    primer_apellido: 'primer_apellido',
    segundo_apellido: 'segundo_apellido',
    fecha_nacimiento: 'fecha_nacimiento',
    sexo: 'sexo',
    email: 'email',
    telefono: 'telefono',
    direccion: 'direccion',
    tipo_usuario: 'tipo_usuario',
    municipio: 'municipio',
    estado: 'estado',
    createAt: 'createAt',
    updateAt: 'updateAt',
    eps: 'eps'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const EpsScalarFieldEnum: {
    id_eps: 'id_eps',
    codigo: 'codigo',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type EpsScalarFieldEnum = (typeof EpsScalarFieldEnum)[keyof typeof EpsScalarFieldEnum]


  export const Tipo_ProcedimientoScalarFieldEnum: {
    id_tipo_procedimiento: 'id_tipo_procedimiento',
    nombre: 'nombre'
  };

  export type Tipo_ProcedimientoScalarFieldEnum = (typeof Tipo_ProcedimientoScalarFieldEnum)[keyof typeof Tipo_ProcedimientoScalarFieldEnum]


  export const ProcedimientoScalarFieldEnum: {
    id_procedimiento: 'id_procedimiento',
    factura: 'factura',
    fecha: 'fecha',
    edad_persona: 'edad_persona',
    createAt: 'createAt',
    updateAt: 'updateAt',
    contrato: 'contrato',
    tipo_procedimiento: 'tipo_procedimiento',
    usuario: 'usuario'
  };

  export type ProcedimientoScalarFieldEnum = (typeof ProcedimientoScalarFieldEnum)[keyof typeof ProcedimientoScalarFieldEnum]


  export const EstudioScalarFieldEnum: {
    id_estudio: 'id_estudio',
    consecutivo: 'consecutivo',
    cantidad: 'cantidad',
    fecha_muestra: 'fecha_muestra',
    fecha_resultado: 'fecha_resultado',
    resultado: 'resultado',
    observacion: 'observacion',
    profesional: 'profesional',
    tarifa: 'tarifa',
    procedimiento: 'procedimiento'
  };

  export type EstudioScalarFieldEnum = (typeof EstudioScalarFieldEnum)[keyof typeof EstudioScalarFieldEnum]


  export const DepartamentoScalarFieldEnum: {
    id_departamento: 'id_departamento',
    nombre: 'nombre'
  };

  export type DepartamentoScalarFieldEnum = (typeof DepartamentoScalarFieldEnum)[keyof typeof DepartamentoScalarFieldEnum]


  export const MunicipioScalarFieldEnum: {
    id_municipio: 'id_municipio',
    nombre: 'nombre',
    departamento: 'departamento'
  };

  export type MunicipioScalarFieldEnum = (typeof MunicipioScalarFieldEnum)[keyof typeof MunicipioScalarFieldEnum]


  export const Tipo_ServicioScalarFieldEnum: {
    id_tipo_servicio: 'id_tipo_servicio',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type Tipo_ServicioScalarFieldEnum = (typeof Tipo_ServicioScalarFieldEnum)[keyof typeof Tipo_ServicioScalarFieldEnum]


  export const ServicioScalarFieldEnum: {
    id_servicio: 'id_servicio',
    nombre: 'nombre',
    precio: 'precio',
    iva: 'iva',
    nivel: 'nivel',
    tipo_servicio: 'tipo_servicio',
    prestador: 'prestador'
  };

  export type ServicioScalarFieldEnum = (typeof ServicioScalarFieldEnum)[keyof typeof ServicioScalarFieldEnum]


  export const ExamenScalarFieldEnum: {
    id_examen: 'id_examen',
    nombre: 'nombre',
    unidades: 'unidades',
    rango_biologico: 'rango_biologico',
    metodo: 'metodo',
    precio: 'precio',
    estado: 'estado',
    tipo_examen: 'tipo_examen'
  };

  export type ExamenScalarFieldEnum = (typeof ExamenScalarFieldEnum)[keyof typeof ExamenScalarFieldEnum]


  export const Tipo_ResultadoScalarFieldEnum: {
    id_tipo_resultado: 'id_tipo_resultado',
    nombre: 'nombre',
    estado: 'estado',
    examen: 'examen'
  };

  export type Tipo_ResultadoScalarFieldEnum = (typeof Tipo_ResultadoScalarFieldEnum)[keyof typeof Tipo_ResultadoScalarFieldEnum]


  export const Tipo_ExamenScalarFieldEnum: {
    id_tipo_examen: 'id_tipo_examen',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type Tipo_ExamenScalarFieldEnum = (typeof Tipo_ExamenScalarFieldEnum)[keyof typeof Tipo_ExamenScalarFieldEnum]


  export const PrestadorScalarFieldEnum: {
    id_prestador: 'id_prestador',
    codigo: 'codigo',
    nit: 'nit',
    razon_social: 'razon_social'
  };

  export type PrestadorScalarFieldEnum = (typeof PrestadorScalarFieldEnum)[keyof typeof PrestadorScalarFieldEnum]


  export const ProfesionalScalarFieldEnum: {
    id_profesional: 'id_profesional',
    identificacion: 'identificacion',
    nombre: 'nombre',
    cargo: 'cargo',
    rol: 'rol',
    email: 'email',
    password: 'password',
    estado: 'estado',
    prestador: 'prestador'
  };

  export type ProfesionalScalarFieldEnum = (typeof ProfesionalScalarFieldEnum)[keyof typeof ProfesionalScalarFieldEnum]


  export const EmpresaScalarFieldEnum: {
    id_empresa: 'id_empresa',
    nit: 'nit',
    codigo: 'codigo',
    nombre: 'nombre',
    sigla: 'sigla',
    tipo: 'tipo',
    estado: 'estado',
    municipio: 'municipio'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const ContratoScalarFieldEnum: {
    id_contrato: 'id_contrato',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    estado: 'estado',
    empresa: 'empresa'
  };

  export type ContratoScalarFieldEnum = (typeof ContratoScalarFieldEnum)[keyof typeof ContratoScalarFieldEnum]


  export const TarifaScalarFieldEnum: {
    id_tarifa: 'id_tarifa',
    estado: 'estado',
    precio: 'precio',
    createAt: 'createAt',
    updateAt: 'updateAt',
    examen: 'examen',
    contrato: 'contrato',
    servicio: 'servicio'
  };

  export type TarifaScalarFieldEnum = (typeof TarifaScalarFieldEnum)[keyof typeof TarifaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Tipo_Ident'
   */
  export type EnumTipo_IdentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Ident'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Sex'
   */
  export type EnumSexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sex'>
    


  /**
   * Reference to a field of type 'Tipo_Usuario'
   */
  export type EnumTipo_UsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Usuario'>
    


  /**
   * Reference to a field of type 'Estado'
   */
  export type EnumEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Estado'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Tipo_Empresa'
   */
  export type EnumTipo_EmpresaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Empresa'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id_usuario?: IntFilter<"Usuario"> | number
    tipo_identificacion?: EnumTipo_IdentFilter<"Usuario"> | $Enums.Tipo_Ident
    identificacion?: StringFilter<"Usuario"> | string
    primer_nombre?: StringFilter<"Usuario"> | string
    segundo_nombre?: StringNullableFilter<"Usuario"> | string | null
    primer_apellido?: StringFilter<"Usuario"> | string
    segundo_apellido?: StringNullableFilter<"Usuario"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Usuario"> | Date | string
    sexo?: EnumSexFilter<"Usuario"> | $Enums.Sex
    email?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    direccion?: StringNullableFilter<"Usuario"> | string | null
    tipo_usuario?: EnumTipo_UsuarioFilter<"Usuario"> | $Enums.Tipo_Usuario
    municipio?: IntFilter<"Usuario"> | number
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    createAt?: DateTimeFilter<"Usuario"> | Date | string
    updateAt?: DateTimeFilter<"Usuario"> | Date | string
    eps?: IntFilter<"Usuario"> | number
    procedimiento?: ProcedimientoListRelationFilter
    Municipio_Usuario?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    Eps_usuario?: XOR<EpsRelationFilter, EpsWhereInput>
  }

  export type UsuarioOrderByWithRelationInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrderInput | SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
    procedimiento?: ProcedimientoOrderByRelationAggregateInput
    Municipio_Usuario?: MunicipioOrderByWithRelationInput
    Eps_usuario?: EpsOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    tipo_identificacion?: EnumTipo_IdentFilter<"Usuario"> | $Enums.Tipo_Ident
    identificacion?: StringFilter<"Usuario"> | string
    primer_nombre?: StringFilter<"Usuario"> | string
    segundo_nombre?: StringNullableFilter<"Usuario"> | string | null
    primer_apellido?: StringFilter<"Usuario"> | string
    segundo_apellido?: StringNullableFilter<"Usuario"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Usuario"> | Date | string
    sexo?: EnumSexFilter<"Usuario"> | $Enums.Sex
    telefono?: StringNullableFilter<"Usuario"> | string | null
    direccion?: StringNullableFilter<"Usuario"> | string | null
    tipo_usuario?: EnumTipo_UsuarioFilter<"Usuario"> | $Enums.Tipo_Usuario
    municipio?: IntFilter<"Usuario"> | number
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    createAt?: DateTimeFilter<"Usuario"> | Date | string
    updateAt?: DateTimeFilter<"Usuario"> | Date | string
    eps?: IntFilter<"Usuario"> | number
    procedimiento?: ProcedimientoListRelationFilter
    Municipio_Usuario?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    Eps_usuario?: XOR<EpsRelationFilter, EpsWhereInput>
  }, "id_usuario" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrderInput | SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"Usuario"> | number
    tipo_identificacion?: EnumTipo_IdentWithAggregatesFilter<"Usuario"> | $Enums.Tipo_Ident
    identificacion?: StringWithAggregatesFilter<"Usuario"> | string
    primer_nombre?: StringWithAggregatesFilter<"Usuario"> | string
    segundo_nombre?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    primer_apellido?: StringWithAggregatesFilter<"Usuario"> | string
    segundo_apellido?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    fecha_nacimiento?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    sexo?: EnumSexWithAggregatesFilter<"Usuario"> | $Enums.Sex
    email?: StringWithAggregatesFilter<"Usuario"> | string
    telefono?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    tipo_usuario?: EnumTipo_UsuarioWithAggregatesFilter<"Usuario"> | $Enums.Tipo_Usuario
    municipio?: IntWithAggregatesFilter<"Usuario"> | number
    estado?: EnumEstadoWithAggregatesFilter<"Usuario"> | $Enums.Estado
    createAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    eps?: IntWithAggregatesFilter<"Usuario"> | number
  }

  export type EpsWhereInput = {
    AND?: EpsWhereInput | EpsWhereInput[]
    OR?: EpsWhereInput[]
    NOT?: EpsWhereInput | EpsWhereInput[]
    id_eps?: IntFilter<"Eps"> | number
    codigo?: StringFilter<"Eps"> | string
    nombre?: StringFilter<"Eps"> | string
    estado?: EnumEstadoFilter<"Eps"> | $Enums.Estado
    usuario?: UsuarioListRelationFilter
  }

  export type EpsOrderByWithRelationInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    usuario?: UsuarioOrderByRelationAggregateInput
  }

  export type EpsWhereUniqueInput = Prisma.AtLeast<{
    id_eps?: number
    AND?: EpsWhereInput | EpsWhereInput[]
    OR?: EpsWhereInput[]
    NOT?: EpsWhereInput | EpsWhereInput[]
    codigo?: StringFilter<"Eps"> | string
    nombre?: StringFilter<"Eps"> | string
    estado?: EnumEstadoFilter<"Eps"> | $Enums.Estado
    usuario?: UsuarioListRelationFilter
  }, "id_eps">

  export type EpsOrderByWithAggregationInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    _count?: EpsCountOrderByAggregateInput
    _avg?: EpsAvgOrderByAggregateInput
    _max?: EpsMaxOrderByAggregateInput
    _min?: EpsMinOrderByAggregateInput
    _sum?: EpsSumOrderByAggregateInput
  }

  export type EpsScalarWhereWithAggregatesInput = {
    AND?: EpsScalarWhereWithAggregatesInput | EpsScalarWhereWithAggregatesInput[]
    OR?: EpsScalarWhereWithAggregatesInput[]
    NOT?: EpsScalarWhereWithAggregatesInput | EpsScalarWhereWithAggregatesInput[]
    id_eps?: IntWithAggregatesFilter<"Eps"> | number
    codigo?: StringWithAggregatesFilter<"Eps"> | string
    nombre?: StringWithAggregatesFilter<"Eps"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Eps"> | $Enums.Estado
  }

  export type Tipo_ProcedimientoWhereInput = {
    AND?: Tipo_ProcedimientoWhereInput | Tipo_ProcedimientoWhereInput[]
    OR?: Tipo_ProcedimientoWhereInput[]
    NOT?: Tipo_ProcedimientoWhereInput | Tipo_ProcedimientoWhereInput[]
    id_tipo_procedimiento?: IntFilter<"Tipo_Procedimiento"> | number
    nombre?: StringFilter<"Tipo_Procedimiento"> | string
    procedimiento?: ProcedimientoListRelationFilter
  }

  export type Tipo_ProcedimientoOrderByWithRelationInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
    procedimiento?: ProcedimientoOrderByRelationAggregateInput
  }

  export type Tipo_ProcedimientoWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_procedimiento?: number
    AND?: Tipo_ProcedimientoWhereInput | Tipo_ProcedimientoWhereInput[]
    OR?: Tipo_ProcedimientoWhereInput[]
    NOT?: Tipo_ProcedimientoWhereInput | Tipo_ProcedimientoWhereInput[]
    nombre?: StringFilter<"Tipo_Procedimiento"> | string
    procedimiento?: ProcedimientoListRelationFilter
  }, "id_tipo_procedimiento">

  export type Tipo_ProcedimientoOrderByWithAggregationInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
    _count?: Tipo_ProcedimientoCountOrderByAggregateInput
    _avg?: Tipo_ProcedimientoAvgOrderByAggregateInput
    _max?: Tipo_ProcedimientoMaxOrderByAggregateInput
    _min?: Tipo_ProcedimientoMinOrderByAggregateInput
    _sum?: Tipo_ProcedimientoSumOrderByAggregateInput
  }

  export type Tipo_ProcedimientoScalarWhereWithAggregatesInput = {
    AND?: Tipo_ProcedimientoScalarWhereWithAggregatesInput | Tipo_ProcedimientoScalarWhereWithAggregatesInput[]
    OR?: Tipo_ProcedimientoScalarWhereWithAggregatesInput[]
    NOT?: Tipo_ProcedimientoScalarWhereWithAggregatesInput | Tipo_ProcedimientoScalarWhereWithAggregatesInput[]
    id_tipo_procedimiento?: IntWithAggregatesFilter<"Tipo_Procedimiento"> | number
    nombre?: StringWithAggregatesFilter<"Tipo_Procedimiento"> | string
  }

  export type ProcedimientoWhereInput = {
    AND?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    OR?: ProcedimientoWhereInput[]
    NOT?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    id_procedimiento?: IntFilter<"Procedimiento"> | number
    factura?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    edad_persona?: StringFilter<"Procedimiento"> | string
    createAt?: DateTimeFilter<"Procedimiento"> | Date | string
    updateAt?: DateTimeFilter<"Procedimiento"> | Date | string
    contrato?: IntFilter<"Procedimiento"> | number
    tipo_procedimiento?: IntFilter<"Procedimiento"> | number
    usuario?: IntFilter<"Procedimiento"> | number
    estudio?: EstudioListRelationFilter
    Procedimeinto_Contrato?: XOR<ContratoRelationFilter, ContratoWhereInput>
    Tipo_Procedimiento_Procedimiento?: XOR<Tipo_ProcedimientoRelationFilter, Tipo_ProcedimientoWhereInput>
    Procedimiento_Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type ProcedimientoOrderByWithRelationInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contrato?: SortOrder
    tipo_procedimiento?: SortOrder
    usuario?: SortOrder
    estudio?: EstudioOrderByRelationAggregateInput
    Procedimeinto_Contrato?: ContratoOrderByWithRelationInput
    Tipo_Procedimiento_Procedimiento?: Tipo_ProcedimientoOrderByWithRelationInput
    Procedimiento_Usuario?: UsuarioOrderByWithRelationInput
  }

  export type ProcedimientoWhereUniqueInput = Prisma.AtLeast<{
    id_procedimiento?: number
    AND?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    OR?: ProcedimientoWhereInput[]
    NOT?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    factura?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    edad_persona?: StringFilter<"Procedimiento"> | string
    createAt?: DateTimeFilter<"Procedimiento"> | Date | string
    updateAt?: DateTimeFilter<"Procedimiento"> | Date | string
    contrato?: IntFilter<"Procedimiento"> | number
    tipo_procedimiento?: IntFilter<"Procedimiento"> | number
    usuario?: IntFilter<"Procedimiento"> | number
    estudio?: EstudioListRelationFilter
    Procedimeinto_Contrato?: XOR<ContratoRelationFilter, ContratoWhereInput>
    Tipo_Procedimiento_Procedimiento?: XOR<Tipo_ProcedimientoRelationFilter, Tipo_ProcedimientoWhereInput>
    Procedimiento_Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id_procedimiento">

  export type ProcedimientoOrderByWithAggregationInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contrato?: SortOrder
    tipo_procedimiento?: SortOrder
    usuario?: SortOrder
    _count?: ProcedimientoCountOrderByAggregateInput
    _avg?: ProcedimientoAvgOrderByAggregateInput
    _max?: ProcedimientoMaxOrderByAggregateInput
    _min?: ProcedimientoMinOrderByAggregateInput
    _sum?: ProcedimientoSumOrderByAggregateInput
  }

  export type ProcedimientoScalarWhereWithAggregatesInput = {
    AND?: ProcedimientoScalarWhereWithAggregatesInput | ProcedimientoScalarWhereWithAggregatesInput[]
    OR?: ProcedimientoScalarWhereWithAggregatesInput[]
    NOT?: ProcedimientoScalarWhereWithAggregatesInput | ProcedimientoScalarWhereWithAggregatesInput[]
    id_procedimiento?: IntWithAggregatesFilter<"Procedimiento"> | number
    factura?: IntWithAggregatesFilter<"Procedimiento"> | number
    fecha?: DateTimeWithAggregatesFilter<"Procedimiento"> | Date | string
    edad_persona?: StringWithAggregatesFilter<"Procedimiento"> | string
    createAt?: DateTimeWithAggregatesFilter<"Procedimiento"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Procedimiento"> | Date | string
    contrato?: IntWithAggregatesFilter<"Procedimiento"> | number
    tipo_procedimiento?: IntWithAggregatesFilter<"Procedimiento"> | number
    usuario?: IntWithAggregatesFilter<"Procedimiento"> | number
  }

  export type EstudioWhereInput = {
    AND?: EstudioWhereInput | EstudioWhereInput[]
    OR?: EstudioWhereInput[]
    NOT?: EstudioWhereInput | EstudioWhereInput[]
    id_estudio?: IntFilter<"Estudio"> | number
    consecutivo?: IntFilter<"Estudio"> | number
    cantidad?: IntFilter<"Estudio"> | number
    fecha_muestra?: DateTimeFilter<"Estudio"> | Date | string
    fecha_resultado?: DateTimeFilter<"Estudio"> | Date | string
    resultado?: StringFilter<"Estudio"> | string
    observacion?: StringFilter<"Estudio"> | string
    profesional?: IntFilter<"Estudio"> | number
    tarifa?: IntFilter<"Estudio"> | number
    procedimiento?: IntFilter<"Estudio"> | number
    Tarifa_Estudio?: XOR<TarifaRelationFilter, TarifaWhereInput>
    Estudio_Procedimiento?: XOR<ProcedimientoRelationFilter, ProcedimientoWhereInput>
  }

  export type EstudioOrderByWithRelationInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    tarifa?: SortOrder
    procedimiento?: SortOrder
    Tarifa_Estudio?: TarifaOrderByWithRelationInput
    Estudio_Procedimiento?: ProcedimientoOrderByWithRelationInput
  }

  export type EstudioWhereUniqueInput = Prisma.AtLeast<{
    id_estudio?: number
    AND?: EstudioWhereInput | EstudioWhereInput[]
    OR?: EstudioWhereInput[]
    NOT?: EstudioWhereInput | EstudioWhereInput[]
    consecutivo?: IntFilter<"Estudio"> | number
    cantidad?: IntFilter<"Estudio"> | number
    fecha_muestra?: DateTimeFilter<"Estudio"> | Date | string
    fecha_resultado?: DateTimeFilter<"Estudio"> | Date | string
    resultado?: StringFilter<"Estudio"> | string
    observacion?: StringFilter<"Estudio"> | string
    profesional?: IntFilter<"Estudio"> | number
    tarifa?: IntFilter<"Estudio"> | number
    procedimiento?: IntFilter<"Estudio"> | number
    Tarifa_Estudio?: XOR<TarifaRelationFilter, TarifaWhereInput>
    Estudio_Procedimiento?: XOR<ProcedimientoRelationFilter, ProcedimientoWhereInput>
  }, "id_estudio">

  export type EstudioOrderByWithAggregationInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    tarifa?: SortOrder
    procedimiento?: SortOrder
    _count?: EstudioCountOrderByAggregateInput
    _avg?: EstudioAvgOrderByAggregateInput
    _max?: EstudioMaxOrderByAggregateInput
    _min?: EstudioMinOrderByAggregateInput
    _sum?: EstudioSumOrderByAggregateInput
  }

  export type EstudioScalarWhereWithAggregatesInput = {
    AND?: EstudioScalarWhereWithAggregatesInput | EstudioScalarWhereWithAggregatesInput[]
    OR?: EstudioScalarWhereWithAggregatesInput[]
    NOT?: EstudioScalarWhereWithAggregatesInput | EstudioScalarWhereWithAggregatesInput[]
    id_estudio?: IntWithAggregatesFilter<"Estudio"> | number
    consecutivo?: IntWithAggregatesFilter<"Estudio"> | number
    cantidad?: IntWithAggregatesFilter<"Estudio"> | number
    fecha_muestra?: DateTimeWithAggregatesFilter<"Estudio"> | Date | string
    fecha_resultado?: DateTimeWithAggregatesFilter<"Estudio"> | Date | string
    resultado?: StringWithAggregatesFilter<"Estudio"> | string
    observacion?: StringWithAggregatesFilter<"Estudio"> | string
    profesional?: IntWithAggregatesFilter<"Estudio"> | number
    tarifa?: IntWithAggregatesFilter<"Estudio"> | number
    procedimiento?: IntWithAggregatesFilter<"Estudio"> | number
  }

  export type DepartamentoWhereInput = {
    AND?: DepartamentoWhereInput | DepartamentoWhereInput[]
    OR?: DepartamentoWhereInput[]
    NOT?: DepartamentoWhereInput | DepartamentoWhereInput[]
    id_departamento?: IntFilter<"Departamento"> | number
    nombre?: StringFilter<"Departamento"> | string
    municipio?: MunicipioListRelationFilter
  }

  export type DepartamentoOrderByWithRelationInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
    municipio?: MunicipioOrderByRelationAggregateInput
  }

  export type DepartamentoWhereUniqueInput = Prisma.AtLeast<{
    id_departamento?: number
    AND?: DepartamentoWhereInput | DepartamentoWhereInput[]
    OR?: DepartamentoWhereInput[]
    NOT?: DepartamentoWhereInput | DepartamentoWhereInput[]
    nombre?: StringFilter<"Departamento"> | string
    municipio?: MunicipioListRelationFilter
  }, "id_departamento">

  export type DepartamentoOrderByWithAggregationInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
    _count?: DepartamentoCountOrderByAggregateInput
    _avg?: DepartamentoAvgOrderByAggregateInput
    _max?: DepartamentoMaxOrderByAggregateInput
    _min?: DepartamentoMinOrderByAggregateInput
    _sum?: DepartamentoSumOrderByAggregateInput
  }

  export type DepartamentoScalarWhereWithAggregatesInput = {
    AND?: DepartamentoScalarWhereWithAggregatesInput | DepartamentoScalarWhereWithAggregatesInput[]
    OR?: DepartamentoScalarWhereWithAggregatesInput[]
    NOT?: DepartamentoScalarWhereWithAggregatesInput | DepartamentoScalarWhereWithAggregatesInput[]
    id_departamento?: IntWithAggregatesFilter<"Departamento"> | number
    nombre?: StringWithAggregatesFilter<"Departamento"> | string
  }

  export type MunicipioWhereInput = {
    AND?: MunicipioWhereInput | MunicipioWhereInput[]
    OR?: MunicipioWhereInput[]
    NOT?: MunicipioWhereInput | MunicipioWhereInput[]
    id_municipio?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
    departamento?: IntFilter<"Municipio"> | number
    suario?: UsuarioListRelationFilter
    empresa?: EmpresaListRelationFilter
    Departamentos_Municipio?: XOR<DepartamentoRelationFilter, DepartamentoWhereInput>
  }

  export type MunicipioOrderByWithRelationInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
    suario?: UsuarioOrderByRelationAggregateInput
    empresa?: EmpresaOrderByRelationAggregateInput
    Departamentos_Municipio?: DepartamentoOrderByWithRelationInput
  }

  export type MunicipioWhereUniqueInput = Prisma.AtLeast<{
    id_municipio?: number
    AND?: MunicipioWhereInput | MunicipioWhereInput[]
    OR?: MunicipioWhereInput[]
    NOT?: MunicipioWhereInput | MunicipioWhereInput[]
    nombre?: StringFilter<"Municipio"> | string
    departamento?: IntFilter<"Municipio"> | number
    suario?: UsuarioListRelationFilter
    empresa?: EmpresaListRelationFilter
    Departamentos_Municipio?: XOR<DepartamentoRelationFilter, DepartamentoWhereInput>
  }, "id_municipio">

  export type MunicipioOrderByWithAggregationInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
    _count?: MunicipioCountOrderByAggregateInput
    _avg?: MunicipioAvgOrderByAggregateInput
    _max?: MunicipioMaxOrderByAggregateInput
    _min?: MunicipioMinOrderByAggregateInput
    _sum?: MunicipioSumOrderByAggregateInput
  }

  export type MunicipioScalarWhereWithAggregatesInput = {
    AND?: MunicipioScalarWhereWithAggregatesInput | MunicipioScalarWhereWithAggregatesInput[]
    OR?: MunicipioScalarWhereWithAggregatesInput[]
    NOT?: MunicipioScalarWhereWithAggregatesInput | MunicipioScalarWhereWithAggregatesInput[]
    id_municipio?: IntWithAggregatesFilter<"Municipio"> | number
    nombre?: StringWithAggregatesFilter<"Municipio"> | string
    departamento?: IntWithAggregatesFilter<"Municipio"> | number
  }

  export type Tipo_ServicioWhereInput = {
    AND?: Tipo_ServicioWhereInput | Tipo_ServicioWhereInput[]
    OR?: Tipo_ServicioWhereInput[]
    NOT?: Tipo_ServicioWhereInput | Tipo_ServicioWhereInput[]
    id_tipo_servicio?: IntFilter<"Tipo_Servicio"> | number
    nombre?: StringFilter<"Tipo_Servicio"> | string
    estado?: EnumEstadoFilter<"Tipo_Servicio"> | $Enums.Estado
    servicio?: ServicioListRelationFilter
  }

  export type Tipo_ServicioOrderByWithRelationInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    servicio?: ServicioOrderByRelationAggregateInput
  }

  export type Tipo_ServicioWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_servicio?: number
    AND?: Tipo_ServicioWhereInput | Tipo_ServicioWhereInput[]
    OR?: Tipo_ServicioWhereInput[]
    NOT?: Tipo_ServicioWhereInput | Tipo_ServicioWhereInput[]
    nombre?: StringFilter<"Tipo_Servicio"> | string
    estado?: EnumEstadoFilter<"Tipo_Servicio"> | $Enums.Estado
    servicio?: ServicioListRelationFilter
  }, "id_tipo_servicio">

  export type Tipo_ServicioOrderByWithAggregationInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    _count?: Tipo_ServicioCountOrderByAggregateInput
    _avg?: Tipo_ServicioAvgOrderByAggregateInput
    _max?: Tipo_ServicioMaxOrderByAggregateInput
    _min?: Tipo_ServicioMinOrderByAggregateInput
    _sum?: Tipo_ServicioSumOrderByAggregateInput
  }

  export type Tipo_ServicioScalarWhereWithAggregatesInput = {
    AND?: Tipo_ServicioScalarWhereWithAggregatesInput | Tipo_ServicioScalarWhereWithAggregatesInput[]
    OR?: Tipo_ServicioScalarWhereWithAggregatesInput[]
    NOT?: Tipo_ServicioScalarWhereWithAggregatesInput | Tipo_ServicioScalarWhereWithAggregatesInput[]
    id_tipo_servicio?: IntWithAggregatesFilter<"Tipo_Servicio"> | number
    nombre?: StringWithAggregatesFilter<"Tipo_Servicio"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Tipo_Servicio"> | $Enums.Estado
  }

  export type ServicioWhereInput = {
    AND?: ServicioWhereInput | ServicioWhereInput[]
    OR?: ServicioWhereInput[]
    NOT?: ServicioWhereInput | ServicioWhereInput[]
    id_servicio?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    nivel?: IntFilter<"Servicio"> | number
    tipo_servicio?: IntFilter<"Servicio"> | number
    prestador?: IntFilter<"Servicio"> | number
    tarifa?: TarifaListRelationFilter
    Servicio_Tipo_Servicio?: XOR<Tipo_ServicioRelationFilter, Tipo_ServicioWhereInput>
    Prestador_Servicio?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }

  export type ServicioOrderByWithRelationInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tipo_servicio?: SortOrder
    prestador?: SortOrder
    tarifa?: TarifaOrderByRelationAggregateInput
    Servicio_Tipo_Servicio?: Tipo_ServicioOrderByWithRelationInput
    Prestador_Servicio?: PrestadorOrderByWithRelationInput
  }

  export type ServicioWhereUniqueInput = Prisma.AtLeast<{
    id_servicio?: number
    AND?: ServicioWhereInput | ServicioWhereInput[]
    OR?: ServicioWhereInput[]
    NOT?: ServicioWhereInput | ServicioWhereInput[]
    nombre?: StringFilter<"Servicio"> | string
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    nivel?: IntFilter<"Servicio"> | number
    tipo_servicio?: IntFilter<"Servicio"> | number
    prestador?: IntFilter<"Servicio"> | number
    tarifa?: TarifaListRelationFilter
    Servicio_Tipo_Servicio?: XOR<Tipo_ServicioRelationFilter, Tipo_ServicioWhereInput>
    Prestador_Servicio?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }, "id_servicio">

  export type ServicioOrderByWithAggregationInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tipo_servicio?: SortOrder
    prestador?: SortOrder
    _count?: ServicioCountOrderByAggregateInput
    _avg?: ServicioAvgOrderByAggregateInput
    _max?: ServicioMaxOrderByAggregateInput
    _min?: ServicioMinOrderByAggregateInput
    _sum?: ServicioSumOrderByAggregateInput
  }

  export type ServicioScalarWhereWithAggregatesInput = {
    AND?: ServicioScalarWhereWithAggregatesInput | ServicioScalarWhereWithAggregatesInput[]
    OR?: ServicioScalarWhereWithAggregatesInput[]
    NOT?: ServicioScalarWhereWithAggregatesInput | ServicioScalarWhereWithAggregatesInput[]
    id_servicio?: IntWithAggregatesFilter<"Servicio"> | number
    nombre?: StringWithAggregatesFilter<"Servicio"> | string
    precio?: DecimalWithAggregatesFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalWithAggregatesFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    nivel?: IntWithAggregatesFilter<"Servicio"> | number
    tipo_servicio?: IntWithAggregatesFilter<"Servicio"> | number
    prestador?: IntWithAggregatesFilter<"Servicio"> | number
  }

  export type ExamenWhereInput = {
    AND?: ExamenWhereInput | ExamenWhereInput[]
    OR?: ExamenWhereInput[]
    NOT?: ExamenWhereInput | ExamenWhereInput[]
    id_examen?: IntFilter<"Examen"> | number
    nombre?: StringFilter<"Examen"> | string
    unidades?: StringFilter<"Examen"> | string
    rango_biologico?: StringFilter<"Examen"> | string
    metodo?: StringFilter<"Examen"> | string
    precio?: DecimalFilter<"Examen"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Examen"> | $Enums.Estado
    tipo_examen?: IntFilter<"Examen"> | number
    tipo_resultado?: Tipo_ResultadoListRelationFilter
    tarifa?: TarifaListRelationFilter
    examen_tipo_examen?: XOR<Tipo_ExamenRelationFilter, Tipo_ExamenWhereInput>
  }

  export type ExamenOrderByWithRelationInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examen?: SortOrder
    tipo_resultado?: Tipo_ResultadoOrderByRelationAggregateInput
    tarifa?: TarifaOrderByRelationAggregateInput
    examen_tipo_examen?: Tipo_ExamenOrderByWithRelationInput
  }

  export type ExamenWhereUniqueInput = Prisma.AtLeast<{
    id_examen?: number
    AND?: ExamenWhereInput | ExamenWhereInput[]
    OR?: ExamenWhereInput[]
    NOT?: ExamenWhereInput | ExamenWhereInput[]
    nombre?: StringFilter<"Examen"> | string
    unidades?: StringFilter<"Examen"> | string
    rango_biologico?: StringFilter<"Examen"> | string
    metodo?: StringFilter<"Examen"> | string
    precio?: DecimalFilter<"Examen"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Examen"> | $Enums.Estado
    tipo_examen?: IntFilter<"Examen"> | number
    tipo_resultado?: Tipo_ResultadoListRelationFilter
    tarifa?: TarifaListRelationFilter
    examen_tipo_examen?: XOR<Tipo_ExamenRelationFilter, Tipo_ExamenWhereInput>
  }, "id_examen">

  export type ExamenOrderByWithAggregationInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examen?: SortOrder
    _count?: ExamenCountOrderByAggregateInput
    _avg?: ExamenAvgOrderByAggregateInput
    _max?: ExamenMaxOrderByAggregateInput
    _min?: ExamenMinOrderByAggregateInput
    _sum?: ExamenSumOrderByAggregateInput
  }

  export type ExamenScalarWhereWithAggregatesInput = {
    AND?: ExamenScalarWhereWithAggregatesInput | ExamenScalarWhereWithAggregatesInput[]
    OR?: ExamenScalarWhereWithAggregatesInput[]
    NOT?: ExamenScalarWhereWithAggregatesInput | ExamenScalarWhereWithAggregatesInput[]
    id_examen?: IntWithAggregatesFilter<"Examen"> | number
    nombre?: StringWithAggregatesFilter<"Examen"> | string
    unidades?: StringWithAggregatesFilter<"Examen"> | string
    rango_biologico?: StringWithAggregatesFilter<"Examen"> | string
    metodo?: StringWithAggregatesFilter<"Examen"> | string
    precio?: DecimalWithAggregatesFilter<"Examen"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoWithAggregatesFilter<"Examen"> | $Enums.Estado
    tipo_examen?: IntWithAggregatesFilter<"Examen"> | number
  }

  export type Tipo_ResultadoWhereInput = {
    AND?: Tipo_ResultadoWhereInput | Tipo_ResultadoWhereInput[]
    OR?: Tipo_ResultadoWhereInput[]
    NOT?: Tipo_ResultadoWhereInput | Tipo_ResultadoWhereInput[]
    id_tipo_resultado?: IntFilter<"Tipo_Resultado"> | number
    nombre?: StringFilter<"Tipo_Resultado"> | string
    estado?: EnumEstadoFilter<"Tipo_Resultado"> | $Enums.Estado
    examen?: IntFilter<"Tipo_Resultado"> | number
    Tipo_Resultado_examen?: XOR<ExamenRelationFilter, ExamenWhereInput>
  }

  export type Tipo_ResultadoOrderByWithRelationInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examen?: SortOrder
    Tipo_Resultado_examen?: ExamenOrderByWithRelationInput
  }

  export type Tipo_ResultadoWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_resultado?: number
    AND?: Tipo_ResultadoWhereInput | Tipo_ResultadoWhereInput[]
    OR?: Tipo_ResultadoWhereInput[]
    NOT?: Tipo_ResultadoWhereInput | Tipo_ResultadoWhereInput[]
    nombre?: StringFilter<"Tipo_Resultado"> | string
    estado?: EnumEstadoFilter<"Tipo_Resultado"> | $Enums.Estado
    examen?: IntFilter<"Tipo_Resultado"> | number
    Tipo_Resultado_examen?: XOR<ExamenRelationFilter, ExamenWhereInput>
  }, "id_tipo_resultado">

  export type Tipo_ResultadoOrderByWithAggregationInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examen?: SortOrder
    _count?: Tipo_ResultadoCountOrderByAggregateInput
    _avg?: Tipo_ResultadoAvgOrderByAggregateInput
    _max?: Tipo_ResultadoMaxOrderByAggregateInput
    _min?: Tipo_ResultadoMinOrderByAggregateInput
    _sum?: Tipo_ResultadoSumOrderByAggregateInput
  }

  export type Tipo_ResultadoScalarWhereWithAggregatesInput = {
    AND?: Tipo_ResultadoScalarWhereWithAggregatesInput | Tipo_ResultadoScalarWhereWithAggregatesInput[]
    OR?: Tipo_ResultadoScalarWhereWithAggregatesInput[]
    NOT?: Tipo_ResultadoScalarWhereWithAggregatesInput | Tipo_ResultadoScalarWhereWithAggregatesInput[]
    id_tipo_resultado?: IntWithAggregatesFilter<"Tipo_Resultado"> | number
    nombre?: StringWithAggregatesFilter<"Tipo_Resultado"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Tipo_Resultado"> | $Enums.Estado
    examen?: IntWithAggregatesFilter<"Tipo_Resultado"> | number
  }

  export type Tipo_ExamenWhereInput = {
    AND?: Tipo_ExamenWhereInput | Tipo_ExamenWhereInput[]
    OR?: Tipo_ExamenWhereInput[]
    NOT?: Tipo_ExamenWhereInput | Tipo_ExamenWhereInput[]
    id_tipo_examen?: IntFilter<"Tipo_Examen"> | number
    nombre?: StringFilter<"Tipo_Examen"> | string
    estado?: EnumEstadoFilter<"Tipo_Examen"> | $Enums.Estado
    examen?: ExamenListRelationFilter
  }

  export type Tipo_ExamenOrderByWithRelationInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examen?: ExamenOrderByRelationAggregateInput
  }

  export type Tipo_ExamenWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_examen?: number
    AND?: Tipo_ExamenWhereInput | Tipo_ExamenWhereInput[]
    OR?: Tipo_ExamenWhereInput[]
    NOT?: Tipo_ExamenWhereInput | Tipo_ExamenWhereInput[]
    nombre?: StringFilter<"Tipo_Examen"> | string
    estado?: EnumEstadoFilter<"Tipo_Examen"> | $Enums.Estado
    examen?: ExamenListRelationFilter
  }, "id_tipo_examen">

  export type Tipo_ExamenOrderByWithAggregationInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    _count?: Tipo_ExamenCountOrderByAggregateInput
    _avg?: Tipo_ExamenAvgOrderByAggregateInput
    _max?: Tipo_ExamenMaxOrderByAggregateInput
    _min?: Tipo_ExamenMinOrderByAggregateInput
    _sum?: Tipo_ExamenSumOrderByAggregateInput
  }

  export type Tipo_ExamenScalarWhereWithAggregatesInput = {
    AND?: Tipo_ExamenScalarWhereWithAggregatesInput | Tipo_ExamenScalarWhereWithAggregatesInput[]
    OR?: Tipo_ExamenScalarWhereWithAggregatesInput[]
    NOT?: Tipo_ExamenScalarWhereWithAggregatesInput | Tipo_ExamenScalarWhereWithAggregatesInput[]
    id_tipo_examen?: IntWithAggregatesFilter<"Tipo_Examen"> | number
    nombre?: StringWithAggregatesFilter<"Tipo_Examen"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Tipo_Examen"> | $Enums.Estado
  }

  export type PrestadorWhereInput = {
    AND?: PrestadorWhereInput | PrestadorWhereInput[]
    OR?: PrestadorWhereInput[]
    NOT?: PrestadorWhereInput | PrestadorWhereInput[]
    id_prestador?: IntFilter<"Prestador"> | number
    codigo?: BigIntFilter<"Prestador"> | bigint | number
    nit?: StringFilter<"Prestador"> | string
    razon_social?: StringFilter<"Prestador"> | string
    servicio?: ServicioListRelationFilter
    profesional?: ProfesionalListRelationFilter
  }

  export type PrestadorOrderByWithRelationInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
    servicio?: ServicioOrderByRelationAggregateInput
    profesional?: ProfesionalOrderByRelationAggregateInput
  }

  export type PrestadorWhereUniqueInput = Prisma.AtLeast<{
    id_prestador?: number
    AND?: PrestadorWhereInput | PrestadorWhereInput[]
    OR?: PrestadorWhereInput[]
    NOT?: PrestadorWhereInput | PrestadorWhereInput[]
    codigo?: BigIntFilter<"Prestador"> | bigint | number
    nit?: StringFilter<"Prestador"> | string
    razon_social?: StringFilter<"Prestador"> | string
    servicio?: ServicioListRelationFilter
    profesional?: ProfesionalListRelationFilter
  }, "id_prestador">

  export type PrestadorOrderByWithAggregationInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
    _count?: PrestadorCountOrderByAggregateInput
    _avg?: PrestadorAvgOrderByAggregateInput
    _max?: PrestadorMaxOrderByAggregateInput
    _min?: PrestadorMinOrderByAggregateInput
    _sum?: PrestadorSumOrderByAggregateInput
  }

  export type PrestadorScalarWhereWithAggregatesInput = {
    AND?: PrestadorScalarWhereWithAggregatesInput | PrestadorScalarWhereWithAggregatesInput[]
    OR?: PrestadorScalarWhereWithAggregatesInput[]
    NOT?: PrestadorScalarWhereWithAggregatesInput | PrestadorScalarWhereWithAggregatesInput[]
    id_prestador?: IntWithAggregatesFilter<"Prestador"> | number
    codigo?: BigIntWithAggregatesFilter<"Prestador"> | bigint | number
    nit?: StringWithAggregatesFilter<"Prestador"> | string
    razon_social?: StringWithAggregatesFilter<"Prestador"> | string
  }

  export type ProfesionalWhereInput = {
    AND?: ProfesionalWhereInput | ProfesionalWhereInput[]
    OR?: ProfesionalWhereInput[]
    NOT?: ProfesionalWhereInput | ProfesionalWhereInput[]
    id_profesional?: IntFilter<"Profesional"> | number
    identificacion?: BigIntFilter<"Profesional"> | bigint | number
    nombre?: StringFilter<"Profesional"> | string
    cargo?: StringFilter<"Profesional"> | string
    rol?: EnumRolFilter<"Profesional"> | $Enums.Rol
    email?: StringFilter<"Profesional"> | string
    password?: StringFilter<"Profesional"> | string
    estado?: EnumEstadoFilter<"Profesional"> | $Enums.Estado
    prestador?: IntFilter<"Profesional"> | number
    Propefisonal_Presatador?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }

  export type ProfesionalOrderByWithRelationInput = {
    id_profesional?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestador?: SortOrder
    Propefisonal_Presatador?: PrestadorOrderByWithRelationInput
  }

  export type ProfesionalWhereUniqueInput = Prisma.AtLeast<{
    id_profesional?: number
    AND?: ProfesionalWhereInput | ProfesionalWhereInput[]
    OR?: ProfesionalWhereInput[]
    NOT?: ProfesionalWhereInput | ProfesionalWhereInput[]
    identificacion?: BigIntFilter<"Profesional"> | bigint | number
    nombre?: StringFilter<"Profesional"> | string
    cargo?: StringFilter<"Profesional"> | string
    rol?: EnumRolFilter<"Profesional"> | $Enums.Rol
    email?: StringFilter<"Profesional"> | string
    password?: StringFilter<"Profesional"> | string
    estado?: EnumEstadoFilter<"Profesional"> | $Enums.Estado
    prestador?: IntFilter<"Profesional"> | number
    Propefisonal_Presatador?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }, "id_profesional">

  export type ProfesionalOrderByWithAggregationInput = {
    id_profesional?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestador?: SortOrder
    _count?: ProfesionalCountOrderByAggregateInput
    _avg?: ProfesionalAvgOrderByAggregateInput
    _max?: ProfesionalMaxOrderByAggregateInput
    _min?: ProfesionalMinOrderByAggregateInput
    _sum?: ProfesionalSumOrderByAggregateInput
  }

  export type ProfesionalScalarWhereWithAggregatesInput = {
    AND?: ProfesionalScalarWhereWithAggregatesInput | ProfesionalScalarWhereWithAggregatesInput[]
    OR?: ProfesionalScalarWhereWithAggregatesInput[]
    NOT?: ProfesionalScalarWhereWithAggregatesInput | ProfesionalScalarWhereWithAggregatesInput[]
    id_profesional?: IntWithAggregatesFilter<"Profesional"> | number
    identificacion?: BigIntWithAggregatesFilter<"Profesional"> | bigint | number
    nombre?: StringWithAggregatesFilter<"Profesional"> | string
    cargo?: StringWithAggregatesFilter<"Profesional"> | string
    rol?: EnumRolWithAggregatesFilter<"Profesional"> | $Enums.Rol
    email?: StringWithAggregatesFilter<"Profesional"> | string
    password?: StringWithAggregatesFilter<"Profesional"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Profesional"> | $Enums.Estado
    prestador?: IntWithAggregatesFilter<"Profesional"> | number
  }

  export type EmpresaWhereInput = {
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    id_empresa?: IntFilter<"Empresa"> | number
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipio?: IntFilter<"Empresa"> | number
    contrato?: ContratoListRelationFilter
    Muncipio_Empresa?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
  }

  export type EmpresaOrderByWithRelationInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
    contrato?: ContratoOrderByRelationAggregateInput
    Muncipio_Empresa?: MunicipioOrderByWithRelationInput
  }

  export type EmpresaWhereUniqueInput = Prisma.AtLeast<{
    id_empresa?: number
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipio?: IntFilter<"Empresa"> | number
    contrato?: ContratoListRelationFilter
    Muncipio_Empresa?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
  }, "id_empresa">

  export type EmpresaOrderByWithAggregationInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
    _count?: EmpresaCountOrderByAggregateInput
    _avg?: EmpresaAvgOrderByAggregateInput
    _max?: EmpresaMaxOrderByAggregateInput
    _min?: EmpresaMinOrderByAggregateInput
    _sum?: EmpresaSumOrderByAggregateInput
  }

  export type EmpresaScalarWhereWithAggregatesInput = {
    AND?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    OR?: EmpresaScalarWhereWithAggregatesInput[]
    NOT?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    id_empresa?: IntWithAggregatesFilter<"Empresa"> | number
    nit?: StringWithAggregatesFilter<"Empresa"> | string
    codigo?: IntWithAggregatesFilter<"Empresa"> | number
    nombre?: StringWithAggregatesFilter<"Empresa"> | string
    sigla?: StringWithAggregatesFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaWithAggregatesFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoWithAggregatesFilter<"Empresa"> | $Enums.Estado
    municipio?: IntWithAggregatesFilter<"Empresa"> | number
  }

  export type ContratoWhereInput = {
    AND?: ContratoWhereInput | ContratoWhereInput[]
    OR?: ContratoWhereInput[]
    NOT?: ContratoWhereInput | ContratoWhereInput[]
    id_contrato?: IntFilter<"Contrato"> | number
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresa?: IntFilter<"Contrato"> | number
    tarifa?: TarifaListRelationFilter
    procedimiento?: ProcedimientoListRelationFilter
    Contrato_Empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type ContratoOrderByWithRelationInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
    tarifa?: TarifaOrderByRelationAggregateInput
    procedimiento?: ProcedimientoOrderByRelationAggregateInput
    Contrato_Empresa?: EmpresaOrderByWithRelationInput
  }

  export type ContratoWhereUniqueInput = Prisma.AtLeast<{
    id_contrato?: number
    AND?: ContratoWhereInput | ContratoWhereInput[]
    OR?: ContratoWhereInput[]
    NOT?: ContratoWhereInput | ContratoWhereInput[]
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresa?: IntFilter<"Contrato"> | number
    tarifa?: TarifaListRelationFilter
    procedimiento?: ProcedimientoListRelationFilter
    Contrato_Empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id_contrato">

  export type ContratoOrderByWithAggregationInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
    _count?: ContratoCountOrderByAggregateInput
    _avg?: ContratoAvgOrderByAggregateInput
    _max?: ContratoMaxOrderByAggregateInput
    _min?: ContratoMinOrderByAggregateInput
    _sum?: ContratoSumOrderByAggregateInput
  }

  export type ContratoScalarWhereWithAggregatesInput = {
    AND?: ContratoScalarWhereWithAggregatesInput | ContratoScalarWhereWithAggregatesInput[]
    OR?: ContratoScalarWhereWithAggregatesInput[]
    NOT?: ContratoScalarWhereWithAggregatesInput | ContratoScalarWhereWithAggregatesInput[]
    id_contrato?: IntWithAggregatesFilter<"Contrato"> | number
    fecha_inicio?: DateTimeWithAggregatesFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeWithAggregatesFilter<"Contrato"> | Date | string
    estado?: EnumEstadoWithAggregatesFilter<"Contrato"> | $Enums.Estado
    empresa?: IntWithAggregatesFilter<"Contrato"> | number
  }

  export type TarifaWhereInput = {
    AND?: TarifaWhereInput | TarifaWhereInput[]
    OR?: TarifaWhereInput[]
    NOT?: TarifaWhereInput | TarifaWhereInput[]
    id_tarifa?: IntFilter<"Tarifa"> | number
    estado?: EnumEstadoFilter<"Tarifa"> | $Enums.Estado
    precio?: DecimalFilter<"Tarifa"> | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFilter<"Tarifa"> | Date | string
    updateAt?: DateTimeFilter<"Tarifa"> | Date | string
    examen?: IntFilter<"Tarifa"> | number
    contrato?: IntFilter<"Tarifa"> | number
    servicio?: IntFilter<"Tarifa"> | number
    estudio?: EstudioListRelationFilter
    Tarifa_Examen?: XOR<ExamenRelationFilter, ExamenWhereInput>
    Tarifa_Contrato?: XOR<ContratoRelationFilter, ContratoWhereInput>
    Tarifa_Servicio?: XOR<ServicioRelationFilter, ServicioWhereInput>
  }

  export type TarifaOrderByWithRelationInput = {
    id_tarifa?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    examen?: SortOrder
    contrato?: SortOrder
    servicio?: SortOrder
    estudio?: EstudioOrderByRelationAggregateInput
    Tarifa_Examen?: ExamenOrderByWithRelationInput
    Tarifa_Contrato?: ContratoOrderByWithRelationInput
    Tarifa_Servicio?: ServicioOrderByWithRelationInput
  }

  export type TarifaWhereUniqueInput = Prisma.AtLeast<{
    id_tarifa?: number
    AND?: TarifaWhereInput | TarifaWhereInput[]
    OR?: TarifaWhereInput[]
    NOT?: TarifaWhereInput | TarifaWhereInput[]
    estado?: EnumEstadoFilter<"Tarifa"> | $Enums.Estado
    precio?: DecimalFilter<"Tarifa"> | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFilter<"Tarifa"> | Date | string
    updateAt?: DateTimeFilter<"Tarifa"> | Date | string
    examen?: IntFilter<"Tarifa"> | number
    contrato?: IntFilter<"Tarifa"> | number
    servicio?: IntFilter<"Tarifa"> | number
    estudio?: EstudioListRelationFilter
    Tarifa_Examen?: XOR<ExamenRelationFilter, ExamenWhereInput>
    Tarifa_Contrato?: XOR<ContratoRelationFilter, ContratoWhereInput>
    Tarifa_Servicio?: XOR<ServicioRelationFilter, ServicioWhereInput>
  }, "id_tarifa">

  export type TarifaOrderByWithAggregationInput = {
    id_tarifa?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    examen?: SortOrder
    contrato?: SortOrder
    servicio?: SortOrder
    _count?: TarifaCountOrderByAggregateInput
    _avg?: TarifaAvgOrderByAggregateInput
    _max?: TarifaMaxOrderByAggregateInput
    _min?: TarifaMinOrderByAggregateInput
    _sum?: TarifaSumOrderByAggregateInput
  }

  export type TarifaScalarWhereWithAggregatesInput = {
    AND?: TarifaScalarWhereWithAggregatesInput | TarifaScalarWhereWithAggregatesInput[]
    OR?: TarifaScalarWhereWithAggregatesInput[]
    NOT?: TarifaScalarWhereWithAggregatesInput | TarifaScalarWhereWithAggregatesInput[]
    id_tarifa?: IntWithAggregatesFilter<"Tarifa"> | number
    estado?: EnumEstadoWithAggregatesFilter<"Tarifa"> | $Enums.Estado
    precio?: DecimalWithAggregatesFilter<"Tarifa"> | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeWithAggregatesFilter<"Tarifa"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Tarifa"> | Date | string
    examen?: IntWithAggregatesFilter<"Tarifa"> | number
    contrato?: IntWithAggregatesFilter<"Tarifa"> | number
    servicio?: IntWithAggregatesFilter<"Tarifa"> | number
  }

  export type UsuarioCreateInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_UsuarioInput
    Municipio_Usuario: MunicipioCreateNestedOneWithoutSuarioInput
    Eps_usuario: EpsCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_UsuarioInput
  }

  export type UsuarioUpdateInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_UsuarioNestedInput
    Municipio_Usuario?: MunicipioUpdateOneRequiredWithoutSuarioNestedInput
    Eps_usuario?: EpsUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
  }

  export type UsuarioUpdateManyMutationInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
  }

  export type EpsCreateInput = {
    codigo: string
    nombre: string
    estado: $Enums.Estado
    usuario?: UsuarioCreateNestedManyWithoutEps_usuarioInput
  }

  export type EpsUncheckedCreateInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
    usuario?: UsuarioUncheckedCreateNestedManyWithoutEps_usuarioInput
  }

  export type EpsUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    usuario?: UsuarioUpdateManyWithoutEps_usuarioNestedInput
  }

  export type EpsUncheckedUpdateInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    usuario?: UsuarioUncheckedUpdateManyWithoutEps_usuarioNestedInput
  }

  export type EpsCreateManyInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
  }

  export type EpsUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EpsUncheckedUpdateManyInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ProcedimientoCreateInput = {
    nombre: string
    procedimiento?: ProcedimientoCreateNestedManyWithoutTipo_Procedimiento_ProcedimientoInput
  }

  export type Tipo_ProcedimientoUncheckedCreateInput = {
    id_tipo_procedimiento?: number
    nombre: string
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutTipo_Procedimiento_ProcedimientoInput
  }

  export type Tipo_ProcedimientoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    procedimiento?: ProcedimientoUpdateManyWithoutTipo_Procedimiento_ProcedimientoNestedInput
  }

  export type Tipo_ProcedimientoUncheckedUpdateInput = {
    id_tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutTipo_Procedimiento_ProcedimientoNestedInput
  }

  export type Tipo_ProcedimientoCreateManyInput = {
    id_tipo_procedimiento?: number
    nombre: string
  }

  export type Tipo_ProcedimientoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type Tipo_ProcedimientoUncheckedUpdateManyInput = {
    id_tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProcedimientoCreateInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutEstudio_ProcedimientoInput
    Procedimeinto_Contrato: ContratoCreateNestedOneWithoutProcedimientoInput
    Tipo_Procedimiento_Procedimiento: Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput
    Procedimiento_Usuario: UsuarioCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    tipo_procedimiento: number
    usuario: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutEstudio_ProcedimientoInput
  }

  export type ProcedimientoUpdateInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutEstudio_ProcedimientoNestedInput
    Procedimeinto_Contrato?: ContratoUpdateOneRequiredWithoutProcedimientoNestedInput
    Tipo_Procedimiento_Procedimiento?: Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput
    Procedimiento_Usuario?: UsuarioUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutEstudio_ProcedimientoNestedInput
  }

  export type ProcedimientoCreateManyInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    tipo_procedimiento: number
    usuario: number
  }

  export type ProcedimientoUpdateManyMutationInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedimientoUncheckedUpdateManyInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateInput = {
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    Tarifa_Estudio: TarifaCreateNestedOneWithoutEstudioInput
    Estudio_Procedimiento: ProcedimientoCreateNestedOneWithoutEstudioInput
  }

  export type EstudioUncheckedCreateInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    tarifa: number
    procedimiento: number
  }

  export type EstudioUpdateInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    Tarifa_Estudio?: TarifaUpdateOneRequiredWithoutEstudioNestedInput
    Estudio_Procedimiento?: ProcedimientoUpdateOneRequiredWithoutEstudioNestedInput
  }

  export type EstudioUncheckedUpdateInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
    procedimiento?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateManyInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    tarifa: number
    procedimiento: number
  }

  export type EstudioUpdateManyMutationInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioUncheckedUpdateManyInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
    procedimiento?: IntFieldUpdateOperationsInput | number
  }

  export type DepartamentoCreateInput = {
    nombre: string
    municipio?: MunicipioCreateNestedManyWithoutDepartamentos_MunicipioInput
  }

  export type DepartamentoUncheckedCreateInput = {
    id_departamento?: number
    nombre: string
    municipio?: MunicipioUncheckedCreateNestedManyWithoutDepartamentos_MunicipioInput
  }

  export type DepartamentoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    municipio?: MunicipioUpdateManyWithoutDepartamentos_MunicipioNestedInput
  }

  export type DepartamentoUncheckedUpdateInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    municipio?: MunicipioUncheckedUpdateManyWithoutDepartamentos_MunicipioNestedInput
  }

  export type DepartamentoCreateManyInput = {
    id_departamento?: number
    nombre: string
  }

  export type DepartamentoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentoUncheckedUpdateManyInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipioCreateInput = {
    nombre: string
    suario?: UsuarioCreateNestedManyWithoutMunicipio_UsuarioInput
    empresa?: EmpresaCreateNestedManyWithoutMuncipio_EmpresaInput
    Departamentos_Municipio: DepartamentoCreateNestedOneWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateInput = {
    id_municipio?: number
    nombre: string
    departamento: number
    suario?: UsuarioUncheckedCreateNestedManyWithoutMunicipio_UsuarioInput
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMuncipio_EmpresaInput
  }

  export type MunicipioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    suario?: UsuarioUpdateManyWithoutMunicipio_UsuarioNestedInput
    empresa?: EmpresaUpdateManyWithoutMuncipio_EmpresaNestedInput
    Departamentos_Municipio?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: IntFieldUpdateOperationsInput | number
    suario?: UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioNestedInput
    empresa?: EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaNestedInput
  }

  export type MunicipioCreateManyInput = {
    id_municipio?: number
    nombre: string
    departamento: number
  }

  export type MunicipioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipioUncheckedUpdateManyInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ServicioCreateInput = {
    nombre: string
    estado: $Enums.Estado
    servicio?: ServicioCreateNestedManyWithoutServicio_Tipo_ServicioInput
  }

  export type Tipo_ServicioUncheckedCreateInput = {
    id_tipo_servicio?: number
    nombre: string
    estado: $Enums.Estado
    servicio?: ServicioUncheckedCreateNestedManyWithoutServicio_Tipo_ServicioInput
  }

  export type Tipo_ServicioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUpdateManyWithoutServicio_Tipo_ServicioNestedInput
  }

  export type Tipo_ServicioUncheckedUpdateInput = {
    id_tipo_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUncheckedUpdateManyWithoutServicio_Tipo_ServicioNestedInput
  }

  export type Tipo_ServicioCreateManyInput = {
    id_tipo_servicio?: number
    nombre: string
    estado: $Enums.Estado
  }

  export type Tipo_ServicioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ServicioUncheckedUpdateManyInput = {
    id_tipo_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ServicioCreateInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ServicioInput
    Servicio_Tipo_Servicio: Tipo_ServicioCreateNestedOneWithoutServicioInput
    Prestador_Servicio: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tipo_servicio: number
    prestador: number
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ServicioInput
  }

  export type ServicioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUpdateManyWithoutTarifa_ServicioNestedInput
    Servicio_Tipo_Servicio?: Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput
    Prestador_Servicio?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tipo_servicio?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ServicioNestedInput
  }

  export type ServicioCreateManyInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tipo_servicio: number
    prestador: number
  }

  export type ServicioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioUncheckedUpdateManyInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tipo_servicio?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type ExamenCreateInput = {
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tipo_resultado?: Tipo_ResultadoCreateNestedManyWithoutTipo_Resultado_examenInput
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ExamenInput
    examen_tipo_examen: Tipo_ExamenCreateNestedOneWithoutExamenInput
  }

  export type ExamenUncheckedCreateInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tipo_examen: number
    tipo_resultado?: Tipo_ResultadoUncheckedCreateNestedManyWithoutTipo_Resultado_examenInput
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ExamenInput
  }

  export type ExamenUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_resultado?: Tipo_ResultadoUpdateManyWithoutTipo_Resultado_examenNestedInput
    tarifa?: TarifaUpdateManyWithoutTarifa_ExamenNestedInput
    examen_tipo_examen?: Tipo_ExamenUpdateOneRequiredWithoutExamenNestedInput
  }

  export type ExamenUncheckedUpdateInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examen?: IntFieldUpdateOperationsInput | number
    tipo_resultado?: Tipo_ResultadoUncheckedUpdateManyWithoutTipo_Resultado_examenNestedInput
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ExamenNestedInput
  }

  export type ExamenCreateManyInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tipo_examen: number
  }

  export type ExamenUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ExamenUncheckedUpdateManyInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examen?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ResultadoCreateInput = {
    nombre: string
    estado: $Enums.Estado
    Tipo_Resultado_examen: ExamenCreateNestedOneWithoutTipo_resultadoInput
  }

  export type Tipo_ResultadoUncheckedCreateInput = {
    id_tipo_resultado?: number
    nombre: string
    estado: $Enums.Estado
    examen: number
  }

  export type Tipo_ResultadoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    Tipo_Resultado_examen?: ExamenUpdateOneRequiredWithoutTipo_resultadoNestedInput
  }

  export type Tipo_ResultadoUncheckedUpdateInput = {
    id_tipo_resultado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examen?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ResultadoCreateManyInput = {
    id_tipo_resultado?: number
    nombre: string
    estado: $Enums.Estado
    examen: number
  }

  export type Tipo_ResultadoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ResultadoUncheckedUpdateManyInput = {
    id_tipo_resultado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examen?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ExamenCreateInput = {
    nombre: string
    estado: $Enums.Estado
    examen?: ExamenCreateNestedManyWithoutExamen_tipo_examenInput
  }

  export type Tipo_ExamenUncheckedCreateInput = {
    id_tipo_examen?: number
    nombre: string
    estado: $Enums.Estado
    examen?: ExamenUncheckedCreateNestedManyWithoutExamen_tipo_examenInput
  }

  export type Tipo_ExamenUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examen?: ExamenUpdateManyWithoutExamen_tipo_examenNestedInput
  }

  export type Tipo_ExamenUncheckedUpdateInput = {
    id_tipo_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examen?: ExamenUncheckedUpdateManyWithoutExamen_tipo_examenNestedInput
  }

  export type Tipo_ExamenCreateManyInput = {
    id_tipo_examen?: number
    nombre: string
    estado: $Enums.Estado
  }

  export type Tipo_ExamenUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ExamenUncheckedUpdateManyInput = {
    id_tipo_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PrestadorCreateInput = {
    codigo: bigint | number
    nit: string
    razon_social: string
    servicio?: ServicioCreateNestedManyWithoutPrestador_ServicioInput
    profesional?: ProfesionalCreateNestedManyWithoutPropefisonal_PresatadorInput
  }

  export type PrestadorUncheckedCreateInput = {
    id_prestador?: number
    codigo: bigint | number
    nit: string
    razon_social: string
    servicio?: ServicioUncheckedCreateNestedManyWithoutPrestador_ServicioInput
    profesional?: ProfesionalUncheckedCreateNestedManyWithoutPropefisonal_PresatadorInput
  }

  export type PrestadorUpdateInput = {
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    servicio?: ServicioUpdateManyWithoutPrestador_ServicioNestedInput
    profesional?: ProfesionalUpdateManyWithoutPropefisonal_PresatadorNestedInput
  }

  export type PrestadorUncheckedUpdateInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    servicio?: ServicioUncheckedUpdateManyWithoutPrestador_ServicioNestedInput
    profesional?: ProfesionalUncheckedUpdateManyWithoutPropefisonal_PresatadorNestedInput
  }

  export type PrestadorCreateManyInput = {
    id_prestador?: number
    codigo: bigint | number
    nit: string
    razon_social: string
  }

  export type PrestadorUpdateManyMutationInput = {
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
  }

  export type PrestadorUncheckedUpdateManyInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
  }

  export type ProfesionalCreateInput = {
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado: $Enums.Estado
    Propefisonal_Presatador: PrestadorCreateNestedOneWithoutProfesionalInput
  }

  export type ProfesionalUncheckedCreateInput = {
    id_profesional?: number
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado: $Enums.Estado
    prestador: number
  }

  export type ProfesionalUpdateInput = {
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    Propefisonal_Presatador?: PrestadorUpdateOneRequiredWithoutProfesionalNestedInput
  }

  export type ProfesionalUncheckedUpdateInput = {
    id_profesional?: IntFieldUpdateOperationsInput | number
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type ProfesionalCreateManyInput = {
    id_profesional?: number
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado: $Enums.Estado
    prestador: number
  }

  export type ProfesionalUpdateManyMutationInput = {
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ProfesionalUncheckedUpdateManyInput = {
    id_profesional?: IntFieldUpdateOperationsInput | number
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type EmpresaCreateInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    contrato?: ContratoCreateNestedManyWithoutContrato_EmpresaInput
    Muncipio_Empresa: MunicipioCreateNestedOneWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipio: number
    contrato?: ContratoUncheckedCreateNestedManyWithoutContrato_EmpresaInput
  }

  export type EmpresaUpdateInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: ContratoUpdateManyWithoutContrato_EmpresaNestedInput
    Muncipio_Empresa?: MunicipioUpdateOneRequiredWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: IntFieldUpdateOperationsInput | number
    contrato?: ContratoUncheckedUpdateManyWithoutContrato_EmpresaNestedInput
  }

  export type EmpresaCreateManyInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipio: number
  }

  export type EmpresaUpdateManyMutationInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EmpresaUncheckedUpdateManyInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: IntFieldUpdateOperationsInput | number
  }

  export type ContratoCreateInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ContratoInput
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimeinto_ContratoInput
    Contrato_Empresa: EmpresaCreateNestedOneWithoutContratoInput
  }

  export type ContratoUncheckedCreateInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    empresa: number
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ContratoInput
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimeinto_ContratoInput
  }

  export type ContratoUpdateInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tarifa?: TarifaUpdateManyWithoutTarifa_ContratoNestedInput
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimeinto_ContratoNestedInput
    Contrato_Empresa?: EmpresaUpdateOneRequiredWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ContratoNestedInput
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimeinto_ContratoNestedInput
  }

  export type ContratoCreateManyInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    empresa: number
  }

  export type ContratoUpdateManyMutationInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ContratoUncheckedUpdateManyInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: IntFieldUpdateOperationsInput | number
  }

  export type TarifaCreateInput = {
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutTarifa_EstudioInput
    Tarifa_Examen: ExamenCreateNestedOneWithoutTarifaInput
    Tarifa_Contrato: ContratoCreateNestedOneWithoutTarifaInput
    Tarifa_Servicio: ServicioCreateNestedOneWithoutTarifaInput
  }

  export type TarifaUncheckedCreateInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    examen: number
    contrato: number
    servicio: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutTarifa_EstudioInput
  }

  export type TarifaUpdateInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutTarifa_EstudioNestedInput
    Tarifa_Examen?: ExamenUpdateOneRequiredWithoutTarifaNestedInput
    Tarifa_Contrato?: ContratoUpdateOneRequiredWithoutTarifaNestedInput
    Tarifa_Servicio?: ServicioUpdateOneRequiredWithoutTarifaNestedInput
  }

  export type TarifaUncheckedUpdateInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examen?: IntFieldUpdateOperationsInput | number
    contrato?: IntFieldUpdateOperationsInput | number
    servicio?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutTarifa_EstudioNestedInput
  }

  export type TarifaCreateManyInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    examen: number
    contrato: number
    servicio: number
  }

  export type TarifaUpdateManyMutationInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TarifaUncheckedUpdateManyInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examen?: IntFieldUpdateOperationsInput | number
    contrato?: IntFieldUpdateOperationsInput | number
    servicio?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumTipo_IdentFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentFilter<$PrismaModel> | $Enums.Tipo_Ident
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumSexFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexFilter<$PrismaModel> | $Enums.Sex
  }

  export type EnumTipo_UsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Usuario | EnumTipo_UsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Usuario[]
    notIn?: $Enums.Tipo_Usuario[]
    not?: NestedEnumTipo_UsuarioFilter<$PrismaModel> | $Enums.Tipo_Usuario
  }

  export type EnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type ProcedimientoListRelationFilter = {
    every?: ProcedimientoWhereInput
    some?: ProcedimientoWhereInput
    none?: ProcedimientoWhereInput
  }

  export type MunicipioRelationFilter = {
    is?: MunicipioWhereInput
    isNot?: MunicipioWhereInput
  }

  export type EpsRelationFilter = {
    is?: EpsWhereInput
    isNot?: EpsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProcedimientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    municipio?: SortOrder
    eps?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    municipio?: SortOrder
    eps?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTipo_IdentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Ident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_IdentFilter<$PrismaModel>
    _max?: NestedEnumTipo_IdentFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexWithAggregatesFilter<$PrismaModel> | $Enums.Sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexFilter<$PrismaModel>
    _max?: NestedEnumSexFilter<$PrismaModel>
  }

  export type EnumTipo_UsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Usuario | EnumTipo_UsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Usuario[]
    notIn?: $Enums.Tipo_Usuario[]
    not?: NestedEnumTipo_UsuarioWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Usuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_UsuarioFilter<$PrismaModel>
    _max?: NestedEnumTipo_UsuarioFilter<$PrismaModel>
  }

  export type EnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EpsCountOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsAvgOrderByAggregateInput = {
    id_eps?: SortOrder
  }

  export type EpsMaxOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsMinOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsSumOrderByAggregateInput = {
    id_eps?: SortOrder
  }

  export type Tipo_ProcedimientoCountOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
  }

  export type Tipo_ProcedimientoAvgOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
  }

  export type Tipo_ProcedimientoMaxOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
  }

  export type Tipo_ProcedimientoMinOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
  }

  export type Tipo_ProcedimientoSumOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
  }

  export type EstudioListRelationFilter = {
    every?: EstudioWhereInput
    some?: EstudioWhereInput
    none?: EstudioWhereInput
  }

  export type ContratoRelationFilter = {
    is?: ContratoWhereInput
    isNot?: ContratoWhereInput
  }

  export type Tipo_ProcedimientoRelationFilter = {
    is?: Tipo_ProcedimientoWhereInput
    isNot?: Tipo_ProcedimientoWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type EstudioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcedimientoCountOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contrato?: SortOrder
    tipo_procedimiento?: SortOrder
    usuario?: SortOrder
  }

  export type ProcedimientoAvgOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    contrato?: SortOrder
    tipo_procedimiento?: SortOrder
    usuario?: SortOrder
  }

  export type ProcedimientoMaxOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contrato?: SortOrder
    tipo_procedimiento?: SortOrder
    usuario?: SortOrder
  }

  export type ProcedimientoMinOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contrato?: SortOrder
    tipo_procedimiento?: SortOrder
    usuario?: SortOrder
  }

  export type ProcedimientoSumOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    contrato?: SortOrder
    tipo_procedimiento?: SortOrder
    usuario?: SortOrder
  }

  export type TarifaRelationFilter = {
    is?: TarifaWhereInput
    isNot?: TarifaWhereInput
  }

  export type ProcedimientoRelationFilter = {
    is?: ProcedimientoWhereInput
    isNot?: ProcedimientoWhereInput
  }

  export type EstudioCountOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    tarifa?: SortOrder
    procedimiento?: SortOrder
  }

  export type EstudioAvgOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    profesional?: SortOrder
    tarifa?: SortOrder
    procedimiento?: SortOrder
  }

  export type EstudioMaxOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    tarifa?: SortOrder
    procedimiento?: SortOrder
  }

  export type EstudioMinOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    tarifa?: SortOrder
    procedimiento?: SortOrder
  }

  export type EstudioSumOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    profesional?: SortOrder
    tarifa?: SortOrder
    procedimiento?: SortOrder
  }

  export type MunicipioListRelationFilter = {
    every?: MunicipioWhereInput
    some?: MunicipioWhereInput
    none?: MunicipioWhereInput
  }

  export type MunicipioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartamentoCountOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoAvgOrderByAggregateInput = {
    id_departamento?: SortOrder
  }

  export type DepartamentoMaxOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoMinOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoSumOrderByAggregateInput = {
    id_departamento?: SortOrder
  }

  export type EmpresaListRelationFilter = {
    every?: EmpresaWhereInput
    some?: EmpresaWhereInput
    none?: EmpresaWhereInput
  }

  export type DepartamentoRelationFilter = {
    is?: DepartamentoWhereInput
    isNot?: DepartamentoWhereInput
  }

  export type EmpresaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipioCountOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
  }

  export type MunicipioAvgOrderByAggregateInput = {
    id_municipio?: SortOrder
    departamento?: SortOrder
  }

  export type MunicipioMaxOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
  }

  export type MunicipioMinOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
  }

  export type MunicipioSumOrderByAggregateInput = {
    id_municipio?: SortOrder
    departamento?: SortOrder
  }

  export type ServicioListRelationFilter = {
    every?: ServicioWhereInput
    some?: ServicioWhereInput
    none?: ServicioWhereInput
  }

  export type ServicioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Tipo_ServicioCountOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ServicioAvgOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
  }

  export type Tipo_ServicioMaxOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ServicioMinOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ServicioSumOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TarifaListRelationFilter = {
    every?: TarifaWhereInput
    some?: TarifaWhereInput
    none?: TarifaWhereInput
  }

  export type Tipo_ServicioRelationFilter = {
    is?: Tipo_ServicioWhereInput
    isNot?: Tipo_ServicioWhereInput
  }

  export type PrestadorRelationFilter = {
    is?: PrestadorWhereInput
    isNot?: PrestadorWhereInput
  }

  export type TarifaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicioCountOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tipo_servicio?: SortOrder
    prestador?: SortOrder
  }

  export type ServicioAvgOrderByAggregateInput = {
    id_servicio?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tipo_servicio?: SortOrder
    prestador?: SortOrder
  }

  export type ServicioMaxOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tipo_servicio?: SortOrder
    prestador?: SortOrder
  }

  export type ServicioMinOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tipo_servicio?: SortOrder
    prestador?: SortOrder
  }

  export type ServicioSumOrderByAggregateInput = {
    id_servicio?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tipo_servicio?: SortOrder
    prestador?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Tipo_ResultadoListRelationFilter = {
    every?: Tipo_ResultadoWhereInput
    some?: Tipo_ResultadoWhereInput
    none?: Tipo_ResultadoWhereInput
  }

  export type Tipo_ExamenRelationFilter = {
    is?: Tipo_ExamenWhereInput
    isNot?: Tipo_ExamenWhereInput
  }

  export type Tipo_ResultadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamenCountOrderByAggregateInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examen?: SortOrder
  }

  export type ExamenAvgOrderByAggregateInput = {
    id_examen?: SortOrder
    precio?: SortOrder
    tipo_examen?: SortOrder
  }

  export type ExamenMaxOrderByAggregateInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examen?: SortOrder
  }

  export type ExamenMinOrderByAggregateInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examen?: SortOrder
  }

  export type ExamenSumOrderByAggregateInput = {
    id_examen?: SortOrder
    precio?: SortOrder
    tipo_examen?: SortOrder
  }

  export type ExamenRelationFilter = {
    is?: ExamenWhereInput
    isNot?: ExamenWhereInput
  }

  export type Tipo_ResultadoCountOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examen?: SortOrder
  }

  export type Tipo_ResultadoAvgOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    examen?: SortOrder
  }

  export type Tipo_ResultadoMaxOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examen?: SortOrder
  }

  export type Tipo_ResultadoMinOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examen?: SortOrder
  }

  export type Tipo_ResultadoSumOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    examen?: SortOrder
  }

  export type ExamenListRelationFilter = {
    every?: ExamenWhereInput
    some?: ExamenWhereInput
    none?: ExamenWhereInput
  }

  export type ExamenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Tipo_ExamenCountOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ExamenAvgOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
  }

  export type Tipo_ExamenMaxOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ExamenMinOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ExamenSumOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type ProfesionalListRelationFilter = {
    every?: ProfesionalWhereInput
    some?: ProfesionalWhereInput
    none?: ProfesionalWhereInput
  }

  export type ProfesionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrestadorCountOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
  }

  export type PrestadorAvgOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
  }

  export type PrestadorMaxOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
  }

  export type PrestadorMinOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
  }

  export type PrestadorSumOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type ProfesionalCountOrderByAggregateInput = {
    id_profesional?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestador?: SortOrder
  }

  export type ProfesionalAvgOrderByAggregateInput = {
    id_profesional?: SortOrder
    identificacion?: SortOrder
    prestador?: SortOrder
  }

  export type ProfesionalMaxOrderByAggregateInput = {
    id_profesional?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestador?: SortOrder
  }

  export type ProfesionalMinOrderByAggregateInput = {
    id_profesional?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestador?: SortOrder
  }

  export type ProfesionalSumOrderByAggregateInput = {
    id_profesional?: SortOrder
    identificacion?: SortOrder
    prestador?: SortOrder
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type EnumTipo_EmpresaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaFilter<$PrismaModel> | $Enums.Tipo_Empresa
  }

  export type ContratoListRelationFilter = {
    every?: ContratoWhereInput
    some?: ContratoWhereInput
    none?: ContratoWhereInput
  }

  export type ContratoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaCountOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
  }

  export type EmpresaAvgOrderByAggregateInput = {
    id_empresa?: SortOrder
    codigo?: SortOrder
    municipio?: SortOrder
  }

  export type EmpresaMaxOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
  }

  export type EmpresaMinOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
  }

  export type EmpresaSumOrderByAggregateInput = {
    id_empresa?: SortOrder
    codigo?: SortOrder
    municipio?: SortOrder
  }

  export type EnumTipo_EmpresaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Empresa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
    _max?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
  }

  export type EmpresaRelationFilter = {
    is?: EmpresaWhereInput
    isNot?: EmpresaWhereInput
  }

  export type ContratoCountOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoAvgOrderByAggregateInput = {
    id_contrato?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoMaxOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoMinOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoSumOrderByAggregateInput = {
    id_contrato?: SortOrder
    empresa?: SortOrder
  }

  export type ServicioRelationFilter = {
    is?: ServicioWhereInput
    isNot?: ServicioWhereInput
  }

  export type TarifaCountOrderByAggregateInput = {
    id_tarifa?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    examen?: SortOrder
    contrato?: SortOrder
    servicio?: SortOrder
  }

  export type TarifaAvgOrderByAggregateInput = {
    id_tarifa?: SortOrder
    precio?: SortOrder
    examen?: SortOrder
    contrato?: SortOrder
    servicio?: SortOrder
  }

  export type TarifaMaxOrderByAggregateInput = {
    id_tarifa?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    examen?: SortOrder
    contrato?: SortOrder
    servicio?: SortOrder
  }

  export type TarifaMinOrderByAggregateInput = {
    id_tarifa?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    examen?: SortOrder
    contrato?: SortOrder
    servicio?: SortOrder
  }

  export type TarifaSumOrderByAggregateInput = {
    id_tarifa?: SortOrder
    precio?: SortOrder
    examen?: SortOrder
    contrato?: SortOrder
    servicio?: SortOrder
  }

  export type ProcedimientoCreateNestedManyWithoutProcedimiento_UsuarioInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput> | ProcedimientoCreateWithoutProcedimiento_UsuarioInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput | ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type MunicipioCreateNestedOneWithoutSuarioInput = {
    create?: XOR<MunicipioCreateWithoutSuarioInput, MunicipioUncheckedCreateWithoutSuarioInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutSuarioInput
    connect?: MunicipioWhereUniqueInput
  }

  export type EpsCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EpsCreateWithoutUsuarioInput, EpsUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EpsCreateOrConnectWithoutUsuarioInput
    connect?: EpsWhereUniqueInput
  }

  export type ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_UsuarioInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput> | ProcedimientoCreateWithoutProcedimiento_UsuarioInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput | ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type EnumTipo_IdentFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Ident
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumSexFieldUpdateOperationsInput = {
    set?: $Enums.Sex
  }

  export type EnumTipo_UsuarioFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Usuario
  }

  export type EnumEstadoFieldUpdateOperationsInput = {
    set?: $Enums.Estado
  }

  export type ProcedimientoUpdateManyWithoutProcedimiento_UsuarioNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput> | ProcedimientoCreateWithoutProcedimiento_UsuarioInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput | ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput | ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput | ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput | ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type MunicipioUpdateOneRequiredWithoutSuarioNestedInput = {
    create?: XOR<MunicipioCreateWithoutSuarioInput, MunicipioUncheckedCreateWithoutSuarioInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutSuarioInput
    upsert?: MunicipioUpsertWithoutSuarioInput
    connect?: MunicipioWhereUniqueInput
    update?: XOR<XOR<MunicipioUpdateToOneWithWhereWithoutSuarioInput, MunicipioUpdateWithoutSuarioInput>, MunicipioUncheckedUpdateWithoutSuarioInput>
  }

  export type EpsUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<EpsCreateWithoutUsuarioInput, EpsUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EpsCreateOrConnectWithoutUsuarioInput
    upsert?: EpsUpsertWithoutUsuarioInput
    connect?: EpsWhereUniqueInput
    update?: XOR<XOR<EpsUpdateToOneWithWhereWithoutUsuarioInput, EpsUpdateWithoutUsuarioInput>, EpsUncheckedUpdateWithoutUsuarioInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput> | ProcedimientoCreateWithoutProcedimiento_UsuarioInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput | ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput | ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput | ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput | ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type UsuarioCreateNestedManyWithoutEps_usuarioInput = {
    create?: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput> | UsuarioCreateWithoutEps_usuarioInput[] | UsuarioUncheckedCreateWithoutEps_usuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEps_usuarioInput | UsuarioCreateOrConnectWithoutEps_usuarioInput[]
    createMany?: UsuarioCreateManyEps_usuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutEps_usuarioInput = {
    create?: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput> | UsuarioCreateWithoutEps_usuarioInput[] | UsuarioUncheckedCreateWithoutEps_usuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEps_usuarioInput | UsuarioCreateOrConnectWithoutEps_usuarioInput[]
    createMany?: UsuarioCreateManyEps_usuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUpdateManyWithoutEps_usuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput> | UsuarioCreateWithoutEps_usuarioInput[] | UsuarioUncheckedCreateWithoutEps_usuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEps_usuarioInput | UsuarioCreateOrConnectWithoutEps_usuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput | UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput[]
    createMany?: UsuarioCreateManyEps_usuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput | UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutEps_usuarioInput | UsuarioUpdateManyWithWhereWithoutEps_usuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutEps_usuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput> | UsuarioCreateWithoutEps_usuarioInput[] | UsuarioUncheckedCreateWithoutEps_usuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEps_usuarioInput | UsuarioCreateOrConnectWithoutEps_usuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput | UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput[]
    createMany?: UsuarioCreateManyEps_usuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput | UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutEps_usuarioInput | UsuarioUpdateManyWithWhereWithoutEps_usuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type ProcedimientoCreateNestedManyWithoutTipo_Procedimiento_ProcedimientoInput = {
    create?: XOR<ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput> | ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput[] | ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput[]
    createMany?: ProcedimientoCreateManyTipo_Procedimiento_ProcedimientoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type ProcedimientoUncheckedCreateNestedManyWithoutTipo_Procedimiento_ProcedimientoInput = {
    create?: XOR<ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput> | ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput[] | ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput[]
    createMany?: ProcedimientoCreateManyTipo_Procedimiento_ProcedimientoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type ProcedimientoUpdateManyWithoutTipo_Procedimiento_ProcedimientoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput> | ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput[] | ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoUpsertWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput[]
    createMany?: ProcedimientoCreateManyTipo_Procedimiento_ProcedimientoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoUpdateWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoUpdateManyWithWhereWithoutTipo_Procedimiento_ProcedimientoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type ProcedimientoUncheckedUpdateManyWithoutTipo_Procedimiento_ProcedimientoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput> | ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput[] | ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoUpsertWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput[]
    createMany?: ProcedimientoCreateManyTipo_Procedimiento_ProcedimientoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoUpdateWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutTipo_Procedimiento_ProcedimientoInput | ProcedimientoUpdateManyWithWhereWithoutTipo_Procedimiento_ProcedimientoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type EstudioCreateNestedManyWithoutEstudio_ProcedimientoInput = {
    create?: XOR<EstudioCreateWithoutEstudio_ProcedimientoInput, EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput> | EstudioCreateWithoutEstudio_ProcedimientoInput[] | EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput | EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput[]
    createMany?: EstudioCreateManyEstudio_ProcedimientoInputEnvelope
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
  }

  export type ContratoCreateNestedOneWithoutProcedimientoInput = {
    create?: XOR<ContratoCreateWithoutProcedimientoInput, ContratoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: ContratoCreateOrConnectWithoutProcedimientoInput
    connect?: ContratoWhereUniqueInput
  }

  export type Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput = {
    create?: XOR<Tipo_ProcedimientoCreateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: Tipo_ProcedimientoCreateOrConnectWithoutProcedimientoInput
    connect?: Tipo_ProcedimientoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutProcedimientoInput = {
    create?: XOR<UsuarioCreateWithoutProcedimientoInput, UsuarioUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProcedimientoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EstudioUncheckedCreateNestedManyWithoutEstudio_ProcedimientoInput = {
    create?: XOR<EstudioCreateWithoutEstudio_ProcedimientoInput, EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput> | EstudioCreateWithoutEstudio_ProcedimientoInput[] | EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput | EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput[]
    createMany?: EstudioCreateManyEstudio_ProcedimientoInputEnvelope
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
  }

  export type EstudioUpdateManyWithoutEstudio_ProcedimientoNestedInput = {
    create?: XOR<EstudioCreateWithoutEstudio_ProcedimientoInput, EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput> | EstudioCreateWithoutEstudio_ProcedimientoInput[] | EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput | EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput[]
    upsert?: EstudioUpsertWithWhereUniqueWithoutEstudio_ProcedimientoInput | EstudioUpsertWithWhereUniqueWithoutEstudio_ProcedimientoInput[]
    createMany?: EstudioCreateManyEstudio_ProcedimientoInputEnvelope
    set?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    disconnect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    delete?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    update?: EstudioUpdateWithWhereUniqueWithoutEstudio_ProcedimientoInput | EstudioUpdateWithWhereUniqueWithoutEstudio_ProcedimientoInput[]
    updateMany?: EstudioUpdateManyWithWhereWithoutEstudio_ProcedimientoInput | EstudioUpdateManyWithWhereWithoutEstudio_ProcedimientoInput[]
    deleteMany?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
  }

  export type ContratoUpdateOneRequiredWithoutProcedimientoNestedInput = {
    create?: XOR<ContratoCreateWithoutProcedimientoInput, ContratoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: ContratoCreateOrConnectWithoutProcedimientoInput
    upsert?: ContratoUpsertWithoutProcedimientoInput
    connect?: ContratoWhereUniqueInput
    update?: XOR<XOR<ContratoUpdateToOneWithWhereWithoutProcedimientoInput, ContratoUpdateWithoutProcedimientoInput>, ContratoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput = {
    create?: XOR<Tipo_ProcedimientoCreateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: Tipo_ProcedimientoCreateOrConnectWithoutProcedimientoInput
    upsert?: Tipo_ProcedimientoUpsertWithoutProcedimientoInput
    connect?: Tipo_ProcedimientoWhereUniqueInput
    update?: XOR<XOR<Tipo_ProcedimientoUpdateToOneWithWhereWithoutProcedimientoInput, Tipo_ProcedimientoUpdateWithoutProcedimientoInput>, Tipo_ProcedimientoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type UsuarioUpdateOneRequiredWithoutProcedimientoNestedInput = {
    create?: XOR<UsuarioCreateWithoutProcedimientoInput, UsuarioUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProcedimientoInput
    upsert?: UsuarioUpsertWithoutProcedimientoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutProcedimientoInput, UsuarioUpdateWithoutProcedimientoInput>, UsuarioUncheckedUpdateWithoutProcedimientoInput>
  }

  export type EstudioUncheckedUpdateManyWithoutEstudio_ProcedimientoNestedInput = {
    create?: XOR<EstudioCreateWithoutEstudio_ProcedimientoInput, EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput> | EstudioCreateWithoutEstudio_ProcedimientoInput[] | EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput | EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput[]
    upsert?: EstudioUpsertWithWhereUniqueWithoutEstudio_ProcedimientoInput | EstudioUpsertWithWhereUniqueWithoutEstudio_ProcedimientoInput[]
    createMany?: EstudioCreateManyEstudio_ProcedimientoInputEnvelope
    set?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    disconnect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    delete?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    update?: EstudioUpdateWithWhereUniqueWithoutEstudio_ProcedimientoInput | EstudioUpdateWithWhereUniqueWithoutEstudio_ProcedimientoInput[]
    updateMany?: EstudioUpdateManyWithWhereWithoutEstudio_ProcedimientoInput | EstudioUpdateManyWithWhereWithoutEstudio_ProcedimientoInput[]
    deleteMany?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
  }

  export type TarifaCreateNestedOneWithoutEstudioInput = {
    create?: XOR<TarifaCreateWithoutEstudioInput, TarifaUncheckedCreateWithoutEstudioInput>
    connectOrCreate?: TarifaCreateOrConnectWithoutEstudioInput
    connect?: TarifaWhereUniqueInput
  }

  export type ProcedimientoCreateNestedOneWithoutEstudioInput = {
    create?: XOR<ProcedimientoCreateWithoutEstudioInput, ProcedimientoUncheckedCreateWithoutEstudioInput>
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutEstudioInput
    connect?: ProcedimientoWhereUniqueInput
  }

  export type TarifaUpdateOneRequiredWithoutEstudioNestedInput = {
    create?: XOR<TarifaCreateWithoutEstudioInput, TarifaUncheckedCreateWithoutEstudioInput>
    connectOrCreate?: TarifaCreateOrConnectWithoutEstudioInput
    upsert?: TarifaUpsertWithoutEstudioInput
    connect?: TarifaWhereUniqueInput
    update?: XOR<XOR<TarifaUpdateToOneWithWhereWithoutEstudioInput, TarifaUpdateWithoutEstudioInput>, TarifaUncheckedUpdateWithoutEstudioInput>
  }

  export type ProcedimientoUpdateOneRequiredWithoutEstudioNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutEstudioInput, ProcedimientoUncheckedCreateWithoutEstudioInput>
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutEstudioInput
    upsert?: ProcedimientoUpsertWithoutEstudioInput
    connect?: ProcedimientoWhereUniqueInput
    update?: XOR<XOR<ProcedimientoUpdateToOneWithWhereWithoutEstudioInput, ProcedimientoUpdateWithoutEstudioInput>, ProcedimientoUncheckedUpdateWithoutEstudioInput>
  }

  export type MunicipioCreateNestedManyWithoutDepartamentos_MunicipioInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput> | MunicipioCreateWithoutDepartamentos_MunicipioInput[] | MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput | MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput[]
    createMany?: MunicipioCreateManyDepartamentos_MunicipioInputEnvelope
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
  }

  export type MunicipioUncheckedCreateNestedManyWithoutDepartamentos_MunicipioInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput> | MunicipioCreateWithoutDepartamentos_MunicipioInput[] | MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput | MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput[]
    createMany?: MunicipioCreateManyDepartamentos_MunicipioInputEnvelope
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
  }

  export type MunicipioUpdateManyWithoutDepartamentos_MunicipioNestedInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput> | MunicipioCreateWithoutDepartamentos_MunicipioInput[] | MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput | MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput[]
    upsert?: MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput | MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput[]
    createMany?: MunicipioCreateManyDepartamentos_MunicipioInputEnvelope
    set?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    disconnect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    delete?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    update?: MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput | MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput[]
    updateMany?: MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput | MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput[]
    deleteMany?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
  }

  export type MunicipioUncheckedUpdateManyWithoutDepartamentos_MunicipioNestedInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput> | MunicipioCreateWithoutDepartamentos_MunicipioInput[] | MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput | MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput[]
    upsert?: MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput | MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput[]
    createMany?: MunicipioCreateManyDepartamentos_MunicipioInputEnvelope
    set?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    disconnect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    delete?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    update?: MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput | MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput[]
    updateMany?: MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput | MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput[]
    deleteMany?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
  }

  export type UsuarioCreateNestedManyWithoutMunicipio_UsuarioInput = {
    create?: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput> | UsuarioCreateWithoutMunicipio_UsuarioInput[] | UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput | UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput[]
    createMany?: UsuarioCreateManyMunicipio_UsuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EmpresaCreateNestedManyWithoutMuncipio_EmpresaInput = {
    create?: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput> | EmpresaCreateWithoutMuncipio_EmpresaInput[] | EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput | EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput[]
    createMany?: EmpresaCreateManyMuncipio_EmpresaInputEnvelope
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
  }

  export type DepartamentoCreateNestedOneWithoutMunicipioInput = {
    create?: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    connectOrCreate?: DepartamentoCreateOrConnectWithoutMunicipioInput
    connect?: DepartamentoWhereUniqueInput
  }

  export type UsuarioUncheckedCreateNestedManyWithoutMunicipio_UsuarioInput = {
    create?: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput> | UsuarioCreateWithoutMunicipio_UsuarioInput[] | UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput | UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput[]
    createMany?: UsuarioCreateManyMunicipio_UsuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EmpresaUncheckedCreateNestedManyWithoutMuncipio_EmpresaInput = {
    create?: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput> | EmpresaCreateWithoutMuncipio_EmpresaInput[] | EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput | EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput[]
    createMany?: EmpresaCreateManyMuncipio_EmpresaInputEnvelope
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
  }

  export type UsuarioUpdateManyWithoutMunicipio_UsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput> | UsuarioCreateWithoutMunicipio_UsuarioInput[] | UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput | UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput | UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput[]
    createMany?: UsuarioCreateManyMunicipio_UsuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput | UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput | UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EmpresaUpdateManyWithoutMuncipio_EmpresaNestedInput = {
    create?: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput> | EmpresaCreateWithoutMuncipio_EmpresaInput[] | EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput | EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput[]
    upsert?: EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput | EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput[]
    createMany?: EmpresaCreateManyMuncipio_EmpresaInputEnvelope
    set?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    disconnect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    delete?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    update?: EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput | EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput[]
    updateMany?: EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput | EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput[]
    deleteMany?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
  }

  export type DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput = {
    create?: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    connectOrCreate?: DepartamentoCreateOrConnectWithoutMunicipioInput
    upsert?: DepartamentoUpsertWithoutMunicipioInput
    connect?: DepartamentoWhereUniqueInput
    update?: XOR<XOR<DepartamentoUpdateToOneWithWhereWithoutMunicipioInput, DepartamentoUpdateWithoutMunicipioInput>, DepartamentoUncheckedUpdateWithoutMunicipioInput>
  }

  export type UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput> | UsuarioCreateWithoutMunicipio_UsuarioInput[] | UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput | UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput | UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput[]
    createMany?: UsuarioCreateManyMunicipio_UsuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput | UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput | UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaNestedInput = {
    create?: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput> | EmpresaCreateWithoutMuncipio_EmpresaInput[] | EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput | EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput[]
    upsert?: EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput | EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput[]
    createMany?: EmpresaCreateManyMuncipio_EmpresaInputEnvelope
    set?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    disconnect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    delete?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    update?: EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput | EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput[]
    updateMany?: EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput | EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput[]
    deleteMany?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
  }

  export type ServicioCreateNestedManyWithoutServicio_Tipo_ServicioInput = {
    create?: XOR<ServicioCreateWithoutServicio_Tipo_ServicioInput, ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput> | ServicioCreateWithoutServicio_Tipo_ServicioInput[] | ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput | ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput[]
    createMany?: ServicioCreateManyServicio_Tipo_ServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ServicioUncheckedCreateNestedManyWithoutServicio_Tipo_ServicioInput = {
    create?: XOR<ServicioCreateWithoutServicio_Tipo_ServicioInput, ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput> | ServicioCreateWithoutServicio_Tipo_ServicioInput[] | ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput | ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput[]
    createMany?: ServicioCreateManyServicio_Tipo_ServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ServicioUpdateManyWithoutServicio_Tipo_ServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutServicio_Tipo_ServicioInput, ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput> | ServicioCreateWithoutServicio_Tipo_ServicioInput[] | ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput | ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutServicio_Tipo_ServicioInput | ServicioUpsertWithWhereUniqueWithoutServicio_Tipo_ServicioInput[]
    createMany?: ServicioCreateManyServicio_Tipo_ServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutServicio_Tipo_ServicioInput | ServicioUpdateWithWhereUniqueWithoutServicio_Tipo_ServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutServicio_Tipo_ServicioInput | ServicioUpdateManyWithWhereWithoutServicio_Tipo_ServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type ServicioUncheckedUpdateManyWithoutServicio_Tipo_ServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutServicio_Tipo_ServicioInput, ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput> | ServicioCreateWithoutServicio_Tipo_ServicioInput[] | ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput | ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutServicio_Tipo_ServicioInput | ServicioUpsertWithWhereUniqueWithoutServicio_Tipo_ServicioInput[]
    createMany?: ServicioCreateManyServicio_Tipo_ServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutServicio_Tipo_ServicioInput | ServicioUpdateWithWhereUniqueWithoutServicio_Tipo_ServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutServicio_Tipo_ServicioInput | ServicioUpdateManyWithWhereWithoutServicio_Tipo_ServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type TarifaCreateNestedManyWithoutTarifa_ServicioInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ServicioInput, TarifaUncheckedCreateWithoutTarifa_ServicioInput> | TarifaCreateWithoutTarifa_ServicioInput[] | TarifaUncheckedCreateWithoutTarifa_ServicioInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ServicioInput | TarifaCreateOrConnectWithoutTarifa_ServicioInput[]
    createMany?: TarifaCreateManyTarifa_ServicioInputEnvelope
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
  }

  export type Tipo_ServicioCreateNestedOneWithoutServicioInput = {
    create?: XOR<Tipo_ServicioCreateWithoutServicioInput, Tipo_ServicioUncheckedCreateWithoutServicioInput>
    connectOrCreate?: Tipo_ServicioCreateOrConnectWithoutServicioInput
    connect?: Tipo_ServicioWhereUniqueInput
  }

  export type PrestadorCreateNestedOneWithoutServicioInput = {
    create?: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutServicioInput
    connect?: PrestadorWhereUniqueInput
  }

  export type TarifaUncheckedCreateNestedManyWithoutTarifa_ServicioInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ServicioInput, TarifaUncheckedCreateWithoutTarifa_ServicioInput> | TarifaCreateWithoutTarifa_ServicioInput[] | TarifaUncheckedCreateWithoutTarifa_ServicioInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ServicioInput | TarifaCreateOrConnectWithoutTarifa_ServicioInput[]
    createMany?: TarifaCreateManyTarifa_ServicioInputEnvelope
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TarifaUpdateManyWithoutTarifa_ServicioNestedInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ServicioInput, TarifaUncheckedCreateWithoutTarifa_ServicioInput> | TarifaCreateWithoutTarifa_ServicioInput[] | TarifaUncheckedCreateWithoutTarifa_ServicioInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ServicioInput | TarifaCreateOrConnectWithoutTarifa_ServicioInput[]
    upsert?: TarifaUpsertWithWhereUniqueWithoutTarifa_ServicioInput | TarifaUpsertWithWhereUniqueWithoutTarifa_ServicioInput[]
    createMany?: TarifaCreateManyTarifa_ServicioInputEnvelope
    set?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    disconnect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    delete?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    update?: TarifaUpdateWithWhereUniqueWithoutTarifa_ServicioInput | TarifaUpdateWithWhereUniqueWithoutTarifa_ServicioInput[]
    updateMany?: TarifaUpdateManyWithWhereWithoutTarifa_ServicioInput | TarifaUpdateManyWithWhereWithoutTarifa_ServicioInput[]
    deleteMany?: TarifaScalarWhereInput | TarifaScalarWhereInput[]
  }

  export type Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput = {
    create?: XOR<Tipo_ServicioCreateWithoutServicioInput, Tipo_ServicioUncheckedCreateWithoutServicioInput>
    connectOrCreate?: Tipo_ServicioCreateOrConnectWithoutServicioInput
    upsert?: Tipo_ServicioUpsertWithoutServicioInput
    connect?: Tipo_ServicioWhereUniqueInput
    update?: XOR<XOR<Tipo_ServicioUpdateToOneWithWhereWithoutServicioInput, Tipo_ServicioUpdateWithoutServicioInput>, Tipo_ServicioUncheckedUpdateWithoutServicioInput>
  }

  export type PrestadorUpdateOneRequiredWithoutServicioNestedInput = {
    create?: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutServicioInput
    upsert?: PrestadorUpsertWithoutServicioInput
    connect?: PrestadorWhereUniqueInput
    update?: XOR<XOR<PrestadorUpdateToOneWithWhereWithoutServicioInput, PrestadorUpdateWithoutServicioInput>, PrestadorUncheckedUpdateWithoutServicioInput>
  }

  export type TarifaUncheckedUpdateManyWithoutTarifa_ServicioNestedInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ServicioInput, TarifaUncheckedCreateWithoutTarifa_ServicioInput> | TarifaCreateWithoutTarifa_ServicioInput[] | TarifaUncheckedCreateWithoutTarifa_ServicioInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ServicioInput | TarifaCreateOrConnectWithoutTarifa_ServicioInput[]
    upsert?: TarifaUpsertWithWhereUniqueWithoutTarifa_ServicioInput | TarifaUpsertWithWhereUniqueWithoutTarifa_ServicioInput[]
    createMany?: TarifaCreateManyTarifa_ServicioInputEnvelope
    set?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    disconnect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    delete?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    update?: TarifaUpdateWithWhereUniqueWithoutTarifa_ServicioInput | TarifaUpdateWithWhereUniqueWithoutTarifa_ServicioInput[]
    updateMany?: TarifaUpdateManyWithWhereWithoutTarifa_ServicioInput | TarifaUpdateManyWithWhereWithoutTarifa_ServicioInput[]
    deleteMany?: TarifaScalarWhereInput | TarifaScalarWhereInput[]
  }

  export type Tipo_ResultadoCreateNestedManyWithoutTipo_Resultado_examenInput = {
    create?: XOR<Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput, Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput> | Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput[] | Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput[]
    connectOrCreate?: Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput | Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput[]
    createMany?: Tipo_ResultadoCreateManyTipo_Resultado_examenInputEnvelope
    connect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
  }

  export type TarifaCreateNestedManyWithoutTarifa_ExamenInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ExamenInput, TarifaUncheckedCreateWithoutTarifa_ExamenInput> | TarifaCreateWithoutTarifa_ExamenInput[] | TarifaUncheckedCreateWithoutTarifa_ExamenInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ExamenInput | TarifaCreateOrConnectWithoutTarifa_ExamenInput[]
    createMany?: TarifaCreateManyTarifa_ExamenInputEnvelope
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
  }

  export type Tipo_ExamenCreateNestedOneWithoutExamenInput = {
    create?: XOR<Tipo_ExamenCreateWithoutExamenInput, Tipo_ExamenUncheckedCreateWithoutExamenInput>
    connectOrCreate?: Tipo_ExamenCreateOrConnectWithoutExamenInput
    connect?: Tipo_ExamenWhereUniqueInput
  }

  export type Tipo_ResultadoUncheckedCreateNestedManyWithoutTipo_Resultado_examenInput = {
    create?: XOR<Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput, Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput> | Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput[] | Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput[]
    connectOrCreate?: Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput | Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput[]
    createMany?: Tipo_ResultadoCreateManyTipo_Resultado_examenInputEnvelope
    connect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
  }

  export type TarifaUncheckedCreateNestedManyWithoutTarifa_ExamenInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ExamenInput, TarifaUncheckedCreateWithoutTarifa_ExamenInput> | TarifaCreateWithoutTarifa_ExamenInput[] | TarifaUncheckedCreateWithoutTarifa_ExamenInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ExamenInput | TarifaCreateOrConnectWithoutTarifa_ExamenInput[]
    createMany?: TarifaCreateManyTarifa_ExamenInputEnvelope
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
  }

  export type Tipo_ResultadoUpdateManyWithoutTipo_Resultado_examenNestedInput = {
    create?: XOR<Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput, Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput> | Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput[] | Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput[]
    connectOrCreate?: Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput | Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput[]
    upsert?: Tipo_ResultadoUpsertWithWhereUniqueWithoutTipo_Resultado_examenInput | Tipo_ResultadoUpsertWithWhereUniqueWithoutTipo_Resultado_examenInput[]
    createMany?: Tipo_ResultadoCreateManyTipo_Resultado_examenInputEnvelope
    set?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    disconnect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    delete?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    connect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    update?: Tipo_ResultadoUpdateWithWhereUniqueWithoutTipo_Resultado_examenInput | Tipo_ResultadoUpdateWithWhereUniqueWithoutTipo_Resultado_examenInput[]
    updateMany?: Tipo_ResultadoUpdateManyWithWhereWithoutTipo_Resultado_examenInput | Tipo_ResultadoUpdateManyWithWhereWithoutTipo_Resultado_examenInput[]
    deleteMany?: Tipo_ResultadoScalarWhereInput | Tipo_ResultadoScalarWhereInput[]
  }

  export type TarifaUpdateManyWithoutTarifa_ExamenNestedInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ExamenInput, TarifaUncheckedCreateWithoutTarifa_ExamenInput> | TarifaCreateWithoutTarifa_ExamenInput[] | TarifaUncheckedCreateWithoutTarifa_ExamenInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ExamenInput | TarifaCreateOrConnectWithoutTarifa_ExamenInput[]
    upsert?: TarifaUpsertWithWhereUniqueWithoutTarifa_ExamenInput | TarifaUpsertWithWhereUniqueWithoutTarifa_ExamenInput[]
    createMany?: TarifaCreateManyTarifa_ExamenInputEnvelope
    set?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    disconnect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    delete?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    update?: TarifaUpdateWithWhereUniqueWithoutTarifa_ExamenInput | TarifaUpdateWithWhereUniqueWithoutTarifa_ExamenInput[]
    updateMany?: TarifaUpdateManyWithWhereWithoutTarifa_ExamenInput | TarifaUpdateManyWithWhereWithoutTarifa_ExamenInput[]
    deleteMany?: TarifaScalarWhereInput | TarifaScalarWhereInput[]
  }

  export type Tipo_ExamenUpdateOneRequiredWithoutExamenNestedInput = {
    create?: XOR<Tipo_ExamenCreateWithoutExamenInput, Tipo_ExamenUncheckedCreateWithoutExamenInput>
    connectOrCreate?: Tipo_ExamenCreateOrConnectWithoutExamenInput
    upsert?: Tipo_ExamenUpsertWithoutExamenInput
    connect?: Tipo_ExamenWhereUniqueInput
    update?: XOR<XOR<Tipo_ExamenUpdateToOneWithWhereWithoutExamenInput, Tipo_ExamenUpdateWithoutExamenInput>, Tipo_ExamenUncheckedUpdateWithoutExamenInput>
  }

  export type Tipo_ResultadoUncheckedUpdateManyWithoutTipo_Resultado_examenNestedInput = {
    create?: XOR<Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput, Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput> | Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput[] | Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput[]
    connectOrCreate?: Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput | Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput[]
    upsert?: Tipo_ResultadoUpsertWithWhereUniqueWithoutTipo_Resultado_examenInput | Tipo_ResultadoUpsertWithWhereUniqueWithoutTipo_Resultado_examenInput[]
    createMany?: Tipo_ResultadoCreateManyTipo_Resultado_examenInputEnvelope
    set?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    disconnect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    delete?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    connect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    update?: Tipo_ResultadoUpdateWithWhereUniqueWithoutTipo_Resultado_examenInput | Tipo_ResultadoUpdateWithWhereUniqueWithoutTipo_Resultado_examenInput[]
    updateMany?: Tipo_ResultadoUpdateManyWithWhereWithoutTipo_Resultado_examenInput | Tipo_ResultadoUpdateManyWithWhereWithoutTipo_Resultado_examenInput[]
    deleteMany?: Tipo_ResultadoScalarWhereInput | Tipo_ResultadoScalarWhereInput[]
  }

  export type TarifaUncheckedUpdateManyWithoutTarifa_ExamenNestedInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ExamenInput, TarifaUncheckedCreateWithoutTarifa_ExamenInput> | TarifaCreateWithoutTarifa_ExamenInput[] | TarifaUncheckedCreateWithoutTarifa_ExamenInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ExamenInput | TarifaCreateOrConnectWithoutTarifa_ExamenInput[]
    upsert?: TarifaUpsertWithWhereUniqueWithoutTarifa_ExamenInput | TarifaUpsertWithWhereUniqueWithoutTarifa_ExamenInput[]
    createMany?: TarifaCreateManyTarifa_ExamenInputEnvelope
    set?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    disconnect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    delete?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    update?: TarifaUpdateWithWhereUniqueWithoutTarifa_ExamenInput | TarifaUpdateWithWhereUniqueWithoutTarifa_ExamenInput[]
    updateMany?: TarifaUpdateManyWithWhereWithoutTarifa_ExamenInput | TarifaUpdateManyWithWhereWithoutTarifa_ExamenInput[]
    deleteMany?: TarifaScalarWhereInput | TarifaScalarWhereInput[]
  }

  export type ExamenCreateNestedOneWithoutTipo_resultadoInput = {
    create?: XOR<ExamenCreateWithoutTipo_resultadoInput, ExamenUncheckedCreateWithoutTipo_resultadoInput>
    connectOrCreate?: ExamenCreateOrConnectWithoutTipo_resultadoInput
    connect?: ExamenWhereUniqueInput
  }

  export type ExamenUpdateOneRequiredWithoutTipo_resultadoNestedInput = {
    create?: XOR<ExamenCreateWithoutTipo_resultadoInput, ExamenUncheckedCreateWithoutTipo_resultadoInput>
    connectOrCreate?: ExamenCreateOrConnectWithoutTipo_resultadoInput
    upsert?: ExamenUpsertWithoutTipo_resultadoInput
    connect?: ExamenWhereUniqueInput
    update?: XOR<XOR<ExamenUpdateToOneWithWhereWithoutTipo_resultadoInput, ExamenUpdateWithoutTipo_resultadoInput>, ExamenUncheckedUpdateWithoutTipo_resultadoInput>
  }

  export type ExamenCreateNestedManyWithoutExamen_tipo_examenInput = {
    create?: XOR<ExamenCreateWithoutExamen_tipo_examenInput, ExamenUncheckedCreateWithoutExamen_tipo_examenInput> | ExamenCreateWithoutExamen_tipo_examenInput[] | ExamenUncheckedCreateWithoutExamen_tipo_examenInput[]
    connectOrCreate?: ExamenCreateOrConnectWithoutExamen_tipo_examenInput | ExamenCreateOrConnectWithoutExamen_tipo_examenInput[]
    createMany?: ExamenCreateManyExamen_tipo_examenInputEnvelope
    connect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
  }

  export type ExamenUncheckedCreateNestedManyWithoutExamen_tipo_examenInput = {
    create?: XOR<ExamenCreateWithoutExamen_tipo_examenInput, ExamenUncheckedCreateWithoutExamen_tipo_examenInput> | ExamenCreateWithoutExamen_tipo_examenInput[] | ExamenUncheckedCreateWithoutExamen_tipo_examenInput[]
    connectOrCreate?: ExamenCreateOrConnectWithoutExamen_tipo_examenInput | ExamenCreateOrConnectWithoutExamen_tipo_examenInput[]
    createMany?: ExamenCreateManyExamen_tipo_examenInputEnvelope
    connect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
  }

  export type ExamenUpdateManyWithoutExamen_tipo_examenNestedInput = {
    create?: XOR<ExamenCreateWithoutExamen_tipo_examenInput, ExamenUncheckedCreateWithoutExamen_tipo_examenInput> | ExamenCreateWithoutExamen_tipo_examenInput[] | ExamenUncheckedCreateWithoutExamen_tipo_examenInput[]
    connectOrCreate?: ExamenCreateOrConnectWithoutExamen_tipo_examenInput | ExamenCreateOrConnectWithoutExamen_tipo_examenInput[]
    upsert?: ExamenUpsertWithWhereUniqueWithoutExamen_tipo_examenInput | ExamenUpsertWithWhereUniqueWithoutExamen_tipo_examenInput[]
    createMany?: ExamenCreateManyExamen_tipo_examenInputEnvelope
    set?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    disconnect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    delete?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    connect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    update?: ExamenUpdateWithWhereUniqueWithoutExamen_tipo_examenInput | ExamenUpdateWithWhereUniqueWithoutExamen_tipo_examenInput[]
    updateMany?: ExamenUpdateManyWithWhereWithoutExamen_tipo_examenInput | ExamenUpdateManyWithWhereWithoutExamen_tipo_examenInput[]
    deleteMany?: ExamenScalarWhereInput | ExamenScalarWhereInput[]
  }

  export type ExamenUncheckedUpdateManyWithoutExamen_tipo_examenNestedInput = {
    create?: XOR<ExamenCreateWithoutExamen_tipo_examenInput, ExamenUncheckedCreateWithoutExamen_tipo_examenInput> | ExamenCreateWithoutExamen_tipo_examenInput[] | ExamenUncheckedCreateWithoutExamen_tipo_examenInput[]
    connectOrCreate?: ExamenCreateOrConnectWithoutExamen_tipo_examenInput | ExamenCreateOrConnectWithoutExamen_tipo_examenInput[]
    upsert?: ExamenUpsertWithWhereUniqueWithoutExamen_tipo_examenInput | ExamenUpsertWithWhereUniqueWithoutExamen_tipo_examenInput[]
    createMany?: ExamenCreateManyExamen_tipo_examenInputEnvelope
    set?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    disconnect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    delete?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    connect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    update?: ExamenUpdateWithWhereUniqueWithoutExamen_tipo_examenInput | ExamenUpdateWithWhereUniqueWithoutExamen_tipo_examenInput[]
    updateMany?: ExamenUpdateManyWithWhereWithoutExamen_tipo_examenInput | ExamenUpdateManyWithWhereWithoutExamen_tipo_examenInput[]
    deleteMany?: ExamenScalarWhereInput | ExamenScalarWhereInput[]
  }

  export type ServicioCreateNestedManyWithoutPrestador_ServicioInput = {
    create?: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput> | ServicioCreateWithoutPrestador_ServicioInput[] | ServicioUncheckedCreateWithoutPrestador_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestador_ServicioInput | ServicioCreateOrConnectWithoutPrestador_ServicioInput[]
    createMany?: ServicioCreateManyPrestador_ServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ProfesionalCreateNestedManyWithoutPropefisonal_PresatadorInput = {
    create?: XOR<ProfesionalCreateWithoutPropefisonal_PresatadorInput, ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput> | ProfesionalCreateWithoutPropefisonal_PresatadorInput[] | ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput[]
    connectOrCreate?: ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput | ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput[]
    createMany?: ProfesionalCreateManyPropefisonal_PresatadorInputEnvelope
    connect?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
  }

  export type ServicioUncheckedCreateNestedManyWithoutPrestador_ServicioInput = {
    create?: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput> | ServicioCreateWithoutPrestador_ServicioInput[] | ServicioUncheckedCreateWithoutPrestador_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestador_ServicioInput | ServicioCreateOrConnectWithoutPrestador_ServicioInput[]
    createMany?: ServicioCreateManyPrestador_ServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ProfesionalUncheckedCreateNestedManyWithoutPropefisonal_PresatadorInput = {
    create?: XOR<ProfesionalCreateWithoutPropefisonal_PresatadorInput, ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput> | ProfesionalCreateWithoutPropefisonal_PresatadorInput[] | ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput[]
    connectOrCreate?: ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput | ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput[]
    createMany?: ProfesionalCreateManyPropefisonal_PresatadorInputEnvelope
    connect?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ServicioUpdateManyWithoutPrestador_ServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput> | ServicioCreateWithoutPrestador_ServicioInput[] | ServicioUncheckedCreateWithoutPrestador_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestador_ServicioInput | ServicioCreateOrConnectWithoutPrestador_ServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput | ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput[]
    createMany?: ServicioCreateManyPrestador_ServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput | ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput | ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type ProfesionalUpdateManyWithoutPropefisonal_PresatadorNestedInput = {
    create?: XOR<ProfesionalCreateWithoutPropefisonal_PresatadorInput, ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput> | ProfesionalCreateWithoutPropefisonal_PresatadorInput[] | ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput[]
    connectOrCreate?: ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput | ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput[]
    upsert?: ProfesionalUpsertWithWhereUniqueWithoutPropefisonal_PresatadorInput | ProfesionalUpsertWithWhereUniqueWithoutPropefisonal_PresatadorInput[]
    createMany?: ProfesionalCreateManyPropefisonal_PresatadorInputEnvelope
    set?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
    disconnect?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
    delete?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
    connect?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
    update?: ProfesionalUpdateWithWhereUniqueWithoutPropefisonal_PresatadorInput | ProfesionalUpdateWithWhereUniqueWithoutPropefisonal_PresatadorInput[]
    updateMany?: ProfesionalUpdateManyWithWhereWithoutPropefisonal_PresatadorInput | ProfesionalUpdateManyWithWhereWithoutPropefisonal_PresatadorInput[]
    deleteMany?: ProfesionalScalarWhereInput | ProfesionalScalarWhereInput[]
  }

  export type ServicioUncheckedUpdateManyWithoutPrestador_ServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput> | ServicioCreateWithoutPrestador_ServicioInput[] | ServicioUncheckedCreateWithoutPrestador_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestador_ServicioInput | ServicioCreateOrConnectWithoutPrestador_ServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput | ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput[]
    createMany?: ServicioCreateManyPrestador_ServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput | ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput | ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type ProfesionalUncheckedUpdateManyWithoutPropefisonal_PresatadorNestedInput = {
    create?: XOR<ProfesionalCreateWithoutPropefisonal_PresatadorInput, ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput> | ProfesionalCreateWithoutPropefisonal_PresatadorInput[] | ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput[]
    connectOrCreate?: ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput | ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput[]
    upsert?: ProfesionalUpsertWithWhereUniqueWithoutPropefisonal_PresatadorInput | ProfesionalUpsertWithWhereUniqueWithoutPropefisonal_PresatadorInput[]
    createMany?: ProfesionalCreateManyPropefisonal_PresatadorInputEnvelope
    set?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
    disconnect?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
    delete?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
    connect?: ProfesionalWhereUniqueInput | ProfesionalWhereUniqueInput[]
    update?: ProfesionalUpdateWithWhereUniqueWithoutPropefisonal_PresatadorInput | ProfesionalUpdateWithWhereUniqueWithoutPropefisonal_PresatadorInput[]
    updateMany?: ProfesionalUpdateManyWithWhereWithoutPropefisonal_PresatadorInput | ProfesionalUpdateManyWithWhereWithoutPropefisonal_PresatadorInput[]
    deleteMany?: ProfesionalScalarWhereInput | ProfesionalScalarWhereInput[]
  }

  export type PrestadorCreateNestedOneWithoutProfesionalInput = {
    create?: XOR<PrestadorCreateWithoutProfesionalInput, PrestadorUncheckedCreateWithoutProfesionalInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutProfesionalInput
    connect?: PrestadorWhereUniqueInput
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type PrestadorUpdateOneRequiredWithoutProfesionalNestedInput = {
    create?: XOR<PrestadorCreateWithoutProfesionalInput, PrestadorUncheckedCreateWithoutProfesionalInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutProfesionalInput
    upsert?: PrestadorUpsertWithoutProfesionalInput
    connect?: PrestadorWhereUniqueInput
    update?: XOR<XOR<PrestadorUpdateToOneWithWhereWithoutProfesionalInput, PrestadorUpdateWithoutProfesionalInput>, PrestadorUncheckedUpdateWithoutProfesionalInput>
  }

  export type ContratoCreateNestedManyWithoutContrato_EmpresaInput = {
    create?: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput> | ContratoCreateWithoutContrato_EmpresaInput[] | ContratoUncheckedCreateWithoutContrato_EmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutContrato_EmpresaInput | ContratoCreateOrConnectWithoutContrato_EmpresaInput[]
    createMany?: ContratoCreateManyContrato_EmpresaInputEnvelope
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
  }

  export type MunicipioCreateNestedOneWithoutEmpresaInput = {
    create?: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutEmpresaInput
    connect?: MunicipioWhereUniqueInput
  }

  export type ContratoUncheckedCreateNestedManyWithoutContrato_EmpresaInput = {
    create?: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput> | ContratoCreateWithoutContrato_EmpresaInput[] | ContratoUncheckedCreateWithoutContrato_EmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutContrato_EmpresaInput | ContratoCreateOrConnectWithoutContrato_EmpresaInput[]
    createMany?: ContratoCreateManyContrato_EmpresaInputEnvelope
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
  }

  export type EnumTipo_EmpresaFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Empresa
  }

  export type ContratoUpdateManyWithoutContrato_EmpresaNestedInput = {
    create?: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput> | ContratoCreateWithoutContrato_EmpresaInput[] | ContratoUncheckedCreateWithoutContrato_EmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutContrato_EmpresaInput | ContratoCreateOrConnectWithoutContrato_EmpresaInput[]
    upsert?: ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput | ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput[]
    createMany?: ContratoCreateManyContrato_EmpresaInputEnvelope
    set?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    disconnect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    delete?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    update?: ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput | ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput[]
    updateMany?: ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput | ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput[]
    deleteMany?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
  }

  export type MunicipioUpdateOneRequiredWithoutEmpresaNestedInput = {
    create?: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutEmpresaInput
    upsert?: MunicipioUpsertWithoutEmpresaInput
    connect?: MunicipioWhereUniqueInput
    update?: XOR<XOR<MunicipioUpdateToOneWithWhereWithoutEmpresaInput, MunicipioUpdateWithoutEmpresaInput>, MunicipioUncheckedUpdateWithoutEmpresaInput>
  }

  export type ContratoUncheckedUpdateManyWithoutContrato_EmpresaNestedInput = {
    create?: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput> | ContratoCreateWithoutContrato_EmpresaInput[] | ContratoUncheckedCreateWithoutContrato_EmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutContrato_EmpresaInput | ContratoCreateOrConnectWithoutContrato_EmpresaInput[]
    upsert?: ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput | ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput[]
    createMany?: ContratoCreateManyContrato_EmpresaInputEnvelope
    set?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    disconnect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    delete?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    update?: ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput | ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput[]
    updateMany?: ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput | ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput[]
    deleteMany?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
  }

  export type TarifaCreateNestedManyWithoutTarifa_ContratoInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ContratoInput, TarifaUncheckedCreateWithoutTarifa_ContratoInput> | TarifaCreateWithoutTarifa_ContratoInput[] | TarifaUncheckedCreateWithoutTarifa_ContratoInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ContratoInput | TarifaCreateOrConnectWithoutTarifa_ContratoInput[]
    createMany?: TarifaCreateManyTarifa_ContratoInputEnvelope
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
  }

  export type ProcedimientoCreateNestedManyWithoutProcedimeinto_ContratoInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimeinto_ContratoInput, ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput> | ProcedimientoCreateWithoutProcedimeinto_ContratoInput[] | ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput | ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput[]
    createMany?: ProcedimientoCreateManyProcedimeinto_ContratoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type EmpresaCreateNestedOneWithoutContratoInput = {
    create?: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutContratoInput
    connect?: EmpresaWhereUniqueInput
  }

  export type TarifaUncheckedCreateNestedManyWithoutTarifa_ContratoInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ContratoInput, TarifaUncheckedCreateWithoutTarifa_ContratoInput> | TarifaCreateWithoutTarifa_ContratoInput[] | TarifaUncheckedCreateWithoutTarifa_ContratoInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ContratoInput | TarifaCreateOrConnectWithoutTarifa_ContratoInput[]
    createMany?: TarifaCreateManyTarifa_ContratoInputEnvelope
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
  }

  export type ProcedimientoUncheckedCreateNestedManyWithoutProcedimeinto_ContratoInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimeinto_ContratoInput, ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput> | ProcedimientoCreateWithoutProcedimeinto_ContratoInput[] | ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput | ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput[]
    createMany?: ProcedimientoCreateManyProcedimeinto_ContratoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type TarifaUpdateManyWithoutTarifa_ContratoNestedInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ContratoInput, TarifaUncheckedCreateWithoutTarifa_ContratoInput> | TarifaCreateWithoutTarifa_ContratoInput[] | TarifaUncheckedCreateWithoutTarifa_ContratoInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ContratoInput | TarifaCreateOrConnectWithoutTarifa_ContratoInput[]
    upsert?: TarifaUpsertWithWhereUniqueWithoutTarifa_ContratoInput | TarifaUpsertWithWhereUniqueWithoutTarifa_ContratoInput[]
    createMany?: TarifaCreateManyTarifa_ContratoInputEnvelope
    set?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    disconnect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    delete?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    update?: TarifaUpdateWithWhereUniqueWithoutTarifa_ContratoInput | TarifaUpdateWithWhereUniqueWithoutTarifa_ContratoInput[]
    updateMany?: TarifaUpdateManyWithWhereWithoutTarifa_ContratoInput | TarifaUpdateManyWithWhereWithoutTarifa_ContratoInput[]
    deleteMany?: TarifaScalarWhereInput | TarifaScalarWhereInput[]
  }

  export type ProcedimientoUpdateManyWithoutProcedimeinto_ContratoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimeinto_ContratoInput, ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput> | ProcedimientoCreateWithoutProcedimeinto_ContratoInput[] | ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput | ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutProcedimeinto_ContratoInput | ProcedimientoUpsertWithWhereUniqueWithoutProcedimeinto_ContratoInput[]
    createMany?: ProcedimientoCreateManyProcedimeinto_ContratoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutProcedimeinto_ContratoInput | ProcedimientoUpdateWithWhereUniqueWithoutProcedimeinto_ContratoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutProcedimeinto_ContratoInput | ProcedimientoUpdateManyWithWhereWithoutProcedimeinto_ContratoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type EmpresaUpdateOneRequiredWithoutContratoNestedInput = {
    create?: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutContratoInput
    upsert?: EmpresaUpsertWithoutContratoInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutContratoInput, EmpresaUpdateWithoutContratoInput>, EmpresaUncheckedUpdateWithoutContratoInput>
  }

  export type TarifaUncheckedUpdateManyWithoutTarifa_ContratoNestedInput = {
    create?: XOR<TarifaCreateWithoutTarifa_ContratoInput, TarifaUncheckedCreateWithoutTarifa_ContratoInput> | TarifaCreateWithoutTarifa_ContratoInput[] | TarifaUncheckedCreateWithoutTarifa_ContratoInput[]
    connectOrCreate?: TarifaCreateOrConnectWithoutTarifa_ContratoInput | TarifaCreateOrConnectWithoutTarifa_ContratoInput[]
    upsert?: TarifaUpsertWithWhereUniqueWithoutTarifa_ContratoInput | TarifaUpsertWithWhereUniqueWithoutTarifa_ContratoInput[]
    createMany?: TarifaCreateManyTarifa_ContratoInputEnvelope
    set?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    disconnect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    delete?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    connect?: TarifaWhereUniqueInput | TarifaWhereUniqueInput[]
    update?: TarifaUpdateWithWhereUniqueWithoutTarifa_ContratoInput | TarifaUpdateWithWhereUniqueWithoutTarifa_ContratoInput[]
    updateMany?: TarifaUpdateManyWithWhereWithoutTarifa_ContratoInput | TarifaUpdateManyWithWhereWithoutTarifa_ContratoInput[]
    deleteMany?: TarifaScalarWhereInput | TarifaScalarWhereInput[]
  }

  export type ProcedimientoUncheckedUpdateManyWithoutProcedimeinto_ContratoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimeinto_ContratoInput, ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput> | ProcedimientoCreateWithoutProcedimeinto_ContratoInput[] | ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput | ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutProcedimeinto_ContratoInput | ProcedimientoUpsertWithWhereUniqueWithoutProcedimeinto_ContratoInput[]
    createMany?: ProcedimientoCreateManyProcedimeinto_ContratoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutProcedimeinto_ContratoInput | ProcedimientoUpdateWithWhereUniqueWithoutProcedimeinto_ContratoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutProcedimeinto_ContratoInput | ProcedimientoUpdateManyWithWhereWithoutProcedimeinto_ContratoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type EstudioCreateNestedManyWithoutTarifa_EstudioInput = {
    create?: XOR<EstudioCreateWithoutTarifa_EstudioInput, EstudioUncheckedCreateWithoutTarifa_EstudioInput> | EstudioCreateWithoutTarifa_EstudioInput[] | EstudioUncheckedCreateWithoutTarifa_EstudioInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutTarifa_EstudioInput | EstudioCreateOrConnectWithoutTarifa_EstudioInput[]
    createMany?: EstudioCreateManyTarifa_EstudioInputEnvelope
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
  }

  export type ExamenCreateNestedOneWithoutTarifaInput = {
    create?: XOR<ExamenCreateWithoutTarifaInput, ExamenUncheckedCreateWithoutTarifaInput>
    connectOrCreate?: ExamenCreateOrConnectWithoutTarifaInput
    connect?: ExamenWhereUniqueInput
  }

  export type ContratoCreateNestedOneWithoutTarifaInput = {
    create?: XOR<ContratoCreateWithoutTarifaInput, ContratoUncheckedCreateWithoutTarifaInput>
    connectOrCreate?: ContratoCreateOrConnectWithoutTarifaInput
    connect?: ContratoWhereUniqueInput
  }

  export type ServicioCreateNestedOneWithoutTarifaInput = {
    create?: XOR<ServicioCreateWithoutTarifaInput, ServicioUncheckedCreateWithoutTarifaInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifaInput
    connect?: ServicioWhereUniqueInput
  }

  export type EstudioUncheckedCreateNestedManyWithoutTarifa_EstudioInput = {
    create?: XOR<EstudioCreateWithoutTarifa_EstudioInput, EstudioUncheckedCreateWithoutTarifa_EstudioInput> | EstudioCreateWithoutTarifa_EstudioInput[] | EstudioUncheckedCreateWithoutTarifa_EstudioInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutTarifa_EstudioInput | EstudioCreateOrConnectWithoutTarifa_EstudioInput[]
    createMany?: EstudioCreateManyTarifa_EstudioInputEnvelope
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
  }

  export type EstudioUpdateManyWithoutTarifa_EstudioNestedInput = {
    create?: XOR<EstudioCreateWithoutTarifa_EstudioInput, EstudioUncheckedCreateWithoutTarifa_EstudioInput> | EstudioCreateWithoutTarifa_EstudioInput[] | EstudioUncheckedCreateWithoutTarifa_EstudioInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutTarifa_EstudioInput | EstudioCreateOrConnectWithoutTarifa_EstudioInput[]
    upsert?: EstudioUpsertWithWhereUniqueWithoutTarifa_EstudioInput | EstudioUpsertWithWhereUniqueWithoutTarifa_EstudioInput[]
    createMany?: EstudioCreateManyTarifa_EstudioInputEnvelope
    set?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    disconnect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    delete?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    update?: EstudioUpdateWithWhereUniqueWithoutTarifa_EstudioInput | EstudioUpdateWithWhereUniqueWithoutTarifa_EstudioInput[]
    updateMany?: EstudioUpdateManyWithWhereWithoutTarifa_EstudioInput | EstudioUpdateManyWithWhereWithoutTarifa_EstudioInput[]
    deleteMany?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
  }

  export type ExamenUpdateOneRequiredWithoutTarifaNestedInput = {
    create?: XOR<ExamenCreateWithoutTarifaInput, ExamenUncheckedCreateWithoutTarifaInput>
    connectOrCreate?: ExamenCreateOrConnectWithoutTarifaInput
    upsert?: ExamenUpsertWithoutTarifaInput
    connect?: ExamenWhereUniqueInput
    update?: XOR<XOR<ExamenUpdateToOneWithWhereWithoutTarifaInput, ExamenUpdateWithoutTarifaInput>, ExamenUncheckedUpdateWithoutTarifaInput>
  }

  export type ContratoUpdateOneRequiredWithoutTarifaNestedInput = {
    create?: XOR<ContratoCreateWithoutTarifaInput, ContratoUncheckedCreateWithoutTarifaInput>
    connectOrCreate?: ContratoCreateOrConnectWithoutTarifaInput
    upsert?: ContratoUpsertWithoutTarifaInput
    connect?: ContratoWhereUniqueInput
    update?: XOR<XOR<ContratoUpdateToOneWithWhereWithoutTarifaInput, ContratoUpdateWithoutTarifaInput>, ContratoUncheckedUpdateWithoutTarifaInput>
  }

  export type ServicioUpdateOneRequiredWithoutTarifaNestedInput = {
    create?: XOR<ServicioCreateWithoutTarifaInput, ServicioUncheckedCreateWithoutTarifaInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifaInput
    upsert?: ServicioUpsertWithoutTarifaInput
    connect?: ServicioWhereUniqueInput
    update?: XOR<XOR<ServicioUpdateToOneWithWhereWithoutTarifaInput, ServicioUpdateWithoutTarifaInput>, ServicioUncheckedUpdateWithoutTarifaInput>
  }

  export type EstudioUncheckedUpdateManyWithoutTarifa_EstudioNestedInput = {
    create?: XOR<EstudioCreateWithoutTarifa_EstudioInput, EstudioUncheckedCreateWithoutTarifa_EstudioInput> | EstudioCreateWithoutTarifa_EstudioInput[] | EstudioUncheckedCreateWithoutTarifa_EstudioInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutTarifa_EstudioInput | EstudioCreateOrConnectWithoutTarifa_EstudioInput[]
    upsert?: EstudioUpsertWithWhereUniqueWithoutTarifa_EstudioInput | EstudioUpsertWithWhereUniqueWithoutTarifa_EstudioInput[]
    createMany?: EstudioCreateManyTarifa_EstudioInputEnvelope
    set?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    disconnect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    delete?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    update?: EstudioUpdateWithWhereUniqueWithoutTarifa_EstudioInput | EstudioUpdateWithWhereUniqueWithoutTarifa_EstudioInput[]
    updateMany?: EstudioUpdateManyWithWhereWithoutTarifa_EstudioInput | EstudioUpdateManyWithWhereWithoutTarifa_EstudioInput[]
    deleteMany?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumTipo_IdentFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentFilter<$PrismaModel> | $Enums.Tipo_Ident
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSexFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexFilter<$PrismaModel> | $Enums.Sex
  }

  export type NestedEnumTipo_UsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Usuario | EnumTipo_UsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Usuario[]
    notIn?: $Enums.Tipo_Usuario[]
    not?: NestedEnumTipo_UsuarioFilter<$PrismaModel> | $Enums.Tipo_Usuario
  }

  export type NestedEnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Ident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_IdentFilter<$PrismaModel>
    _max?: NestedEnumTipo_IdentFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexWithAggregatesFilter<$PrismaModel> | $Enums.Sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexFilter<$PrismaModel>
    _max?: NestedEnumSexFilter<$PrismaModel>
  }

  export type NestedEnumTipo_UsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Usuario | EnumTipo_UsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Usuario[]
    notIn?: $Enums.Tipo_Usuario[]
    not?: NestedEnumTipo_UsuarioWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Usuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_UsuarioFilter<$PrismaModel>
    _max?: NestedEnumTipo_UsuarioFilter<$PrismaModel>
  }

  export type NestedEnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedEnumTipo_EmpresaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaFilter<$PrismaModel> | $Enums.Tipo_Empresa
  }

  export type NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Empresa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
    _max?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
  }

  export type ProcedimientoCreateWithoutProcedimiento_UsuarioInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutEstudio_ProcedimientoInput
    Procedimeinto_Contrato: ContratoCreateNestedOneWithoutProcedimientoInput
    Tipo_Procedimiento_Procedimiento: Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    tipo_procedimiento: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutEstudio_ProcedimientoInput
  }

  export type ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput>
  }

  export type ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope = {
    data: ProcedimientoCreateManyProcedimiento_UsuarioInput | ProcedimientoCreateManyProcedimiento_UsuarioInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioCreateWithoutSuarioInput = {
    nombre: string
    empresa?: EmpresaCreateNestedManyWithoutMuncipio_EmpresaInput
    Departamentos_Municipio: DepartamentoCreateNestedOneWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateWithoutSuarioInput = {
    id_municipio?: number
    nombre: string
    departamento: number
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMuncipio_EmpresaInput
  }

  export type MunicipioCreateOrConnectWithoutSuarioInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutSuarioInput, MunicipioUncheckedCreateWithoutSuarioInput>
  }

  export type EpsCreateWithoutUsuarioInput = {
    codigo: string
    nombre: string
    estado: $Enums.Estado
  }

  export type EpsUncheckedCreateWithoutUsuarioInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
  }

  export type EpsCreateOrConnectWithoutUsuarioInput = {
    where: EpsWhereUniqueInput
    create: XOR<EpsCreateWithoutUsuarioInput, EpsUncheckedCreateWithoutUsuarioInput>
  }

  export type ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput = {
    where: ProcedimientoWhereUniqueInput
    update: XOR<ProcedimientoUpdateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedUpdateWithoutProcedimiento_UsuarioInput>
    create: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput>
  }

  export type ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput = {
    where: ProcedimientoWhereUniqueInput
    data: XOR<ProcedimientoUpdateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedUpdateWithoutProcedimiento_UsuarioInput>
  }

  export type ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput = {
    where: ProcedimientoScalarWhereInput
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioInput>
  }

  export type ProcedimientoScalarWhereInput = {
    AND?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
    OR?: ProcedimientoScalarWhereInput[]
    NOT?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
    id_procedimiento?: IntFilter<"Procedimiento"> | number
    factura?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    edad_persona?: StringFilter<"Procedimiento"> | string
    createAt?: DateTimeFilter<"Procedimiento"> | Date | string
    updateAt?: DateTimeFilter<"Procedimiento"> | Date | string
    contrato?: IntFilter<"Procedimiento"> | number
    tipo_procedimiento?: IntFilter<"Procedimiento"> | number
    usuario?: IntFilter<"Procedimiento"> | number
  }

  export type MunicipioUpsertWithoutSuarioInput = {
    update: XOR<MunicipioUpdateWithoutSuarioInput, MunicipioUncheckedUpdateWithoutSuarioInput>
    create: XOR<MunicipioCreateWithoutSuarioInput, MunicipioUncheckedCreateWithoutSuarioInput>
    where?: MunicipioWhereInput
  }

  export type MunicipioUpdateToOneWithWhereWithoutSuarioInput = {
    where?: MunicipioWhereInput
    data: XOR<MunicipioUpdateWithoutSuarioInput, MunicipioUncheckedUpdateWithoutSuarioInput>
  }

  export type MunicipioUpdateWithoutSuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    empresa?: EmpresaUpdateManyWithoutMuncipio_EmpresaNestedInput
    Departamentos_Municipio?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutSuarioInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: IntFieldUpdateOperationsInput | number
    empresa?: EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaNestedInput
  }

  export type EpsUpsertWithoutUsuarioInput = {
    update: XOR<EpsUpdateWithoutUsuarioInput, EpsUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EpsCreateWithoutUsuarioInput, EpsUncheckedCreateWithoutUsuarioInput>
    where?: EpsWhereInput
  }

  export type EpsUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: EpsWhereInput
    data: XOR<EpsUpdateWithoutUsuarioInput, EpsUncheckedUpdateWithoutUsuarioInput>
  }

  export type EpsUpdateWithoutUsuarioInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EpsUncheckedUpdateWithoutUsuarioInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type UsuarioCreateWithoutEps_usuarioInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_UsuarioInput
    Municipio_Usuario: MunicipioCreateNestedOneWithoutSuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEps_usuarioInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_UsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEps_usuarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput>
  }

  export type UsuarioCreateManyEps_usuarioInputEnvelope = {
    data: UsuarioCreateManyEps_usuarioInput | UsuarioCreateManyEps_usuarioInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutEps_usuarioInput, UsuarioUncheckedUpdateWithoutEps_usuarioInput>
    create: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutEps_usuarioInput, UsuarioUncheckedUpdateWithoutEps_usuarioInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutEps_usuarioInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutEps_usuarioInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id_usuario?: IntFilter<"Usuario"> | number
    tipo_identificacion?: EnumTipo_IdentFilter<"Usuario"> | $Enums.Tipo_Ident
    identificacion?: StringFilter<"Usuario"> | string
    primer_nombre?: StringFilter<"Usuario"> | string
    segundo_nombre?: StringNullableFilter<"Usuario"> | string | null
    primer_apellido?: StringFilter<"Usuario"> | string
    segundo_apellido?: StringNullableFilter<"Usuario"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Usuario"> | Date | string
    sexo?: EnumSexFilter<"Usuario"> | $Enums.Sex
    email?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    direccion?: StringNullableFilter<"Usuario"> | string | null
    tipo_usuario?: EnumTipo_UsuarioFilter<"Usuario"> | $Enums.Tipo_Usuario
    municipio?: IntFilter<"Usuario"> | number
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    createAt?: DateTimeFilter<"Usuario"> | Date | string
    updateAt?: DateTimeFilter<"Usuario"> | Date | string
    eps?: IntFilter<"Usuario"> | number
  }

  export type ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutEstudio_ProcedimientoInput
    Procedimeinto_Contrato: ContratoCreateNestedOneWithoutProcedimientoInput
    Procedimiento_Usuario: UsuarioCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    usuario: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutEstudio_ProcedimientoInput
  }

  export type ProcedimientoCreateOrConnectWithoutTipo_Procedimiento_ProcedimientoInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput>
  }

  export type ProcedimientoCreateManyTipo_Procedimiento_ProcedimientoInputEnvelope = {
    data: ProcedimientoCreateManyTipo_Procedimiento_ProcedimientoInput | ProcedimientoCreateManyTipo_Procedimiento_ProcedimientoInput[]
    skipDuplicates?: boolean
  }

  export type ProcedimientoUpsertWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput = {
    where: ProcedimientoWhereUniqueInput
    update: XOR<ProcedimientoUpdateWithoutTipo_Procedimiento_ProcedimientoInput, ProcedimientoUncheckedUpdateWithoutTipo_Procedimiento_ProcedimientoInput>
    create: XOR<ProcedimientoCreateWithoutTipo_Procedimiento_ProcedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_Procedimiento_ProcedimientoInput>
  }

  export type ProcedimientoUpdateWithWhereUniqueWithoutTipo_Procedimiento_ProcedimientoInput = {
    where: ProcedimientoWhereUniqueInput
    data: XOR<ProcedimientoUpdateWithoutTipo_Procedimiento_ProcedimientoInput, ProcedimientoUncheckedUpdateWithoutTipo_Procedimiento_ProcedimientoInput>
  }

  export type ProcedimientoUpdateManyWithWhereWithoutTipo_Procedimiento_ProcedimientoInput = {
    where: ProcedimientoScalarWhereInput
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyWithoutTipo_Procedimiento_ProcedimientoInput>
  }

  export type EstudioCreateWithoutEstudio_ProcedimientoInput = {
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    Tarifa_Estudio: TarifaCreateNestedOneWithoutEstudioInput
  }

  export type EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    tarifa: number
  }

  export type EstudioCreateOrConnectWithoutEstudio_ProcedimientoInput = {
    where: EstudioWhereUniqueInput
    create: XOR<EstudioCreateWithoutEstudio_ProcedimientoInput, EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput>
  }

  export type EstudioCreateManyEstudio_ProcedimientoInputEnvelope = {
    data: EstudioCreateManyEstudio_ProcedimientoInput | EstudioCreateManyEstudio_ProcedimientoInput[]
    skipDuplicates?: boolean
  }

  export type ContratoCreateWithoutProcedimientoInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ContratoInput
    Contrato_Empresa: EmpresaCreateNestedOneWithoutContratoInput
  }

  export type ContratoUncheckedCreateWithoutProcedimientoInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    empresa: number
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ContratoInput
  }

  export type ContratoCreateOrConnectWithoutProcedimientoInput = {
    where: ContratoWhereUniqueInput
    create: XOR<ContratoCreateWithoutProcedimientoInput, ContratoUncheckedCreateWithoutProcedimientoInput>
  }

  export type Tipo_ProcedimientoCreateWithoutProcedimientoInput = {
    nombre: string
  }

  export type Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput = {
    id_tipo_procedimiento?: number
    nombre: string
  }

  export type Tipo_ProcedimientoCreateOrConnectWithoutProcedimientoInput = {
    where: Tipo_ProcedimientoWhereUniqueInput
    create: XOR<Tipo_ProcedimientoCreateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput>
  }

  export type UsuarioCreateWithoutProcedimientoInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    Municipio_Usuario: MunicipioCreateNestedOneWithoutSuarioInput
    Eps_usuario: EpsCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutProcedimientoInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
  }

  export type UsuarioCreateOrConnectWithoutProcedimientoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutProcedimientoInput, UsuarioUncheckedCreateWithoutProcedimientoInput>
  }

  export type EstudioUpsertWithWhereUniqueWithoutEstudio_ProcedimientoInput = {
    where: EstudioWhereUniqueInput
    update: XOR<EstudioUpdateWithoutEstudio_ProcedimientoInput, EstudioUncheckedUpdateWithoutEstudio_ProcedimientoInput>
    create: XOR<EstudioCreateWithoutEstudio_ProcedimientoInput, EstudioUncheckedCreateWithoutEstudio_ProcedimientoInput>
  }

  export type EstudioUpdateWithWhereUniqueWithoutEstudio_ProcedimientoInput = {
    where: EstudioWhereUniqueInput
    data: XOR<EstudioUpdateWithoutEstudio_ProcedimientoInput, EstudioUncheckedUpdateWithoutEstudio_ProcedimientoInput>
  }

  export type EstudioUpdateManyWithWhereWithoutEstudio_ProcedimientoInput = {
    where: EstudioScalarWhereInput
    data: XOR<EstudioUpdateManyMutationInput, EstudioUncheckedUpdateManyWithoutEstudio_ProcedimientoInput>
  }

  export type EstudioScalarWhereInput = {
    AND?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
    OR?: EstudioScalarWhereInput[]
    NOT?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
    id_estudio?: IntFilter<"Estudio"> | number
    consecutivo?: IntFilter<"Estudio"> | number
    cantidad?: IntFilter<"Estudio"> | number
    fecha_muestra?: DateTimeFilter<"Estudio"> | Date | string
    fecha_resultado?: DateTimeFilter<"Estudio"> | Date | string
    resultado?: StringFilter<"Estudio"> | string
    observacion?: StringFilter<"Estudio"> | string
    profesional?: IntFilter<"Estudio"> | number
    tarifa?: IntFilter<"Estudio"> | number
    procedimiento?: IntFilter<"Estudio"> | number
  }

  export type ContratoUpsertWithoutProcedimientoInput = {
    update: XOR<ContratoUpdateWithoutProcedimientoInput, ContratoUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<ContratoCreateWithoutProcedimientoInput, ContratoUncheckedCreateWithoutProcedimientoInput>
    where?: ContratoWhereInput
  }

  export type ContratoUpdateToOneWithWhereWithoutProcedimientoInput = {
    where?: ContratoWhereInput
    data: XOR<ContratoUpdateWithoutProcedimientoInput, ContratoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type ContratoUpdateWithoutProcedimientoInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tarifa?: TarifaUpdateManyWithoutTarifa_ContratoNestedInput
    Contrato_Empresa?: EmpresaUpdateOneRequiredWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateWithoutProcedimientoInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ContratoNestedInput
  }

  export type Tipo_ProcedimientoUpsertWithoutProcedimientoInput = {
    update: XOR<Tipo_ProcedimientoUpdateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<Tipo_ProcedimientoCreateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput>
    where?: Tipo_ProcedimientoWhereInput
  }

  export type Tipo_ProcedimientoUpdateToOneWithWhereWithoutProcedimientoInput = {
    where?: Tipo_ProcedimientoWhereInput
    data: XOR<Tipo_ProcedimientoUpdateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type Tipo_ProcedimientoUpdateWithoutProcedimientoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type Tipo_ProcedimientoUncheckedUpdateWithoutProcedimientoInput = {
    id_tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUpsertWithoutProcedimientoInput = {
    update: XOR<UsuarioUpdateWithoutProcedimientoInput, UsuarioUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<UsuarioCreateWithoutProcedimientoInput, UsuarioUncheckedCreateWithoutProcedimientoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutProcedimientoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutProcedimientoInput, UsuarioUncheckedUpdateWithoutProcedimientoInput>
  }

  export type UsuarioUpdateWithoutProcedimientoInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Municipio_Usuario?: MunicipioUpdateOneRequiredWithoutSuarioNestedInput
    Eps_usuario?: EpsUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutProcedimientoInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
  }

  export type TarifaCreateWithoutEstudioInput = {
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    Tarifa_Examen: ExamenCreateNestedOneWithoutTarifaInput
    Tarifa_Contrato: ContratoCreateNestedOneWithoutTarifaInput
    Tarifa_Servicio: ServicioCreateNestedOneWithoutTarifaInput
  }

  export type TarifaUncheckedCreateWithoutEstudioInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    examen: number
    contrato: number
    servicio: number
  }

  export type TarifaCreateOrConnectWithoutEstudioInput = {
    where: TarifaWhereUniqueInput
    create: XOR<TarifaCreateWithoutEstudioInput, TarifaUncheckedCreateWithoutEstudioInput>
  }

  export type ProcedimientoCreateWithoutEstudioInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    Procedimeinto_Contrato: ContratoCreateNestedOneWithoutProcedimientoInput
    Tipo_Procedimiento_Procedimiento: Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput
    Procedimiento_Usuario: UsuarioCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutEstudioInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    tipo_procedimiento: number
    usuario: number
  }

  export type ProcedimientoCreateOrConnectWithoutEstudioInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutEstudioInput, ProcedimientoUncheckedCreateWithoutEstudioInput>
  }

  export type TarifaUpsertWithoutEstudioInput = {
    update: XOR<TarifaUpdateWithoutEstudioInput, TarifaUncheckedUpdateWithoutEstudioInput>
    create: XOR<TarifaCreateWithoutEstudioInput, TarifaUncheckedCreateWithoutEstudioInput>
    where?: TarifaWhereInput
  }

  export type TarifaUpdateToOneWithWhereWithoutEstudioInput = {
    where?: TarifaWhereInput
    data: XOR<TarifaUpdateWithoutEstudioInput, TarifaUncheckedUpdateWithoutEstudioInput>
  }

  export type TarifaUpdateWithoutEstudioInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tarifa_Examen?: ExamenUpdateOneRequiredWithoutTarifaNestedInput
    Tarifa_Contrato?: ContratoUpdateOneRequiredWithoutTarifaNestedInput
    Tarifa_Servicio?: ServicioUpdateOneRequiredWithoutTarifaNestedInput
  }

  export type TarifaUncheckedUpdateWithoutEstudioInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examen?: IntFieldUpdateOperationsInput | number
    contrato?: IntFieldUpdateOperationsInput | number
    servicio?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoUpsertWithoutEstudioInput = {
    update: XOR<ProcedimientoUpdateWithoutEstudioInput, ProcedimientoUncheckedUpdateWithoutEstudioInput>
    create: XOR<ProcedimientoCreateWithoutEstudioInput, ProcedimientoUncheckedCreateWithoutEstudioInput>
    where?: ProcedimientoWhereInput
  }

  export type ProcedimientoUpdateToOneWithWhereWithoutEstudioInput = {
    where?: ProcedimientoWhereInput
    data: XOR<ProcedimientoUpdateWithoutEstudioInput, ProcedimientoUncheckedUpdateWithoutEstudioInput>
  }

  export type ProcedimientoUpdateWithoutEstudioInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Procedimeinto_Contrato?: ContratoUpdateOneRequiredWithoutProcedimientoNestedInput
    Tipo_Procedimiento_Procedimiento?: Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput
    Procedimiento_Usuario?: UsuarioUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutEstudioInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
  }

  export type MunicipioCreateWithoutDepartamentos_MunicipioInput = {
    nombre: string
    suario?: UsuarioCreateNestedManyWithoutMunicipio_UsuarioInput
    empresa?: EmpresaCreateNestedManyWithoutMuncipio_EmpresaInput
  }

  export type MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput = {
    id_municipio?: number
    nombre: string
    suario?: UsuarioUncheckedCreateNestedManyWithoutMunicipio_UsuarioInput
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMuncipio_EmpresaInput
  }

  export type MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput>
  }

  export type MunicipioCreateManyDepartamentos_MunicipioInputEnvelope = {
    data: MunicipioCreateManyDepartamentos_MunicipioInput | MunicipioCreateManyDepartamentos_MunicipioInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput = {
    where: MunicipioWhereUniqueInput
    update: XOR<MunicipioUpdateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedUpdateWithoutDepartamentos_MunicipioInput>
    create: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput>
  }

  export type MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput = {
    where: MunicipioWhereUniqueInput
    data: XOR<MunicipioUpdateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedUpdateWithoutDepartamentos_MunicipioInput>
  }

  export type MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput = {
    where: MunicipioScalarWhereInput
    data: XOR<MunicipioUpdateManyMutationInput, MunicipioUncheckedUpdateManyWithoutDepartamentos_MunicipioInput>
  }

  export type MunicipioScalarWhereInput = {
    AND?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
    OR?: MunicipioScalarWhereInput[]
    NOT?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
    id_municipio?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
    departamento?: IntFilter<"Municipio"> | number
  }

  export type UsuarioCreateWithoutMunicipio_UsuarioInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_UsuarioInput
    Eps_usuario: EpsCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_UsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput>
  }

  export type UsuarioCreateManyMunicipio_UsuarioInputEnvelope = {
    data: UsuarioCreateManyMunicipio_UsuarioInput | UsuarioCreateManyMunicipio_UsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaCreateWithoutMuncipio_EmpresaInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    contrato?: ContratoCreateNestedManyWithoutContrato_EmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    contrato?: ContratoUncheckedCreateNestedManyWithoutContrato_EmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput>
  }

  export type EmpresaCreateManyMuncipio_EmpresaInputEnvelope = {
    data: EmpresaCreateManyMuncipio_EmpresaInput | EmpresaCreateManyMuncipio_EmpresaInput[]
    skipDuplicates?: boolean
  }

  export type DepartamentoCreateWithoutMunicipioInput = {
    nombre: string
  }

  export type DepartamentoUncheckedCreateWithoutMunicipioInput = {
    id_departamento?: number
    nombre: string
  }

  export type DepartamentoCreateOrConnectWithoutMunicipioInput = {
    where: DepartamentoWhereUniqueInput
    create: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
  }

  export type UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutMunicipio_UsuarioInput, UsuarioUncheckedUpdateWithoutMunicipio_UsuarioInput>
    create: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutMunicipio_UsuarioInput, UsuarioUncheckedUpdateWithoutMunicipio_UsuarioInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioInput>
  }

  export type EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput = {
    where: EmpresaWhereUniqueInput
    update: XOR<EmpresaUpdateWithoutMuncipio_EmpresaInput, EmpresaUncheckedUpdateWithoutMuncipio_EmpresaInput>
    create: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput>
  }

  export type EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput = {
    where: EmpresaWhereUniqueInput
    data: XOR<EmpresaUpdateWithoutMuncipio_EmpresaInput, EmpresaUncheckedUpdateWithoutMuncipio_EmpresaInput>
  }

  export type EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput = {
    where: EmpresaScalarWhereInput
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaInput>
  }

  export type EmpresaScalarWhereInput = {
    AND?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
    OR?: EmpresaScalarWhereInput[]
    NOT?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
    id_empresa?: IntFilter<"Empresa"> | number
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipio?: IntFilter<"Empresa"> | number
  }

  export type DepartamentoUpsertWithoutMunicipioInput = {
    update: XOR<DepartamentoUpdateWithoutMunicipioInput, DepartamentoUncheckedUpdateWithoutMunicipioInput>
    create: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    where?: DepartamentoWhereInput
  }

  export type DepartamentoUpdateToOneWithWhereWithoutMunicipioInput = {
    where?: DepartamentoWhereInput
    data: XOR<DepartamentoUpdateWithoutMunicipioInput, DepartamentoUncheckedUpdateWithoutMunicipioInput>
  }

  export type DepartamentoUpdateWithoutMunicipioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentoUncheckedUpdateWithoutMunicipioInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ServicioCreateWithoutServicio_Tipo_ServicioInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ServicioInput
    Prestador_Servicio: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    prestador: number
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ServicioInput
  }

  export type ServicioCreateOrConnectWithoutServicio_Tipo_ServicioInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutServicio_Tipo_ServicioInput, ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput>
  }

  export type ServicioCreateManyServicio_Tipo_ServicioInputEnvelope = {
    data: ServicioCreateManyServicio_Tipo_ServicioInput | ServicioCreateManyServicio_Tipo_ServicioInput[]
    skipDuplicates?: boolean
  }

  export type ServicioUpsertWithWhereUniqueWithoutServicio_Tipo_ServicioInput = {
    where: ServicioWhereUniqueInput
    update: XOR<ServicioUpdateWithoutServicio_Tipo_ServicioInput, ServicioUncheckedUpdateWithoutServicio_Tipo_ServicioInput>
    create: XOR<ServicioCreateWithoutServicio_Tipo_ServicioInput, ServicioUncheckedCreateWithoutServicio_Tipo_ServicioInput>
  }

  export type ServicioUpdateWithWhereUniqueWithoutServicio_Tipo_ServicioInput = {
    where: ServicioWhereUniqueInput
    data: XOR<ServicioUpdateWithoutServicio_Tipo_ServicioInput, ServicioUncheckedUpdateWithoutServicio_Tipo_ServicioInput>
  }

  export type ServicioUpdateManyWithWhereWithoutServicio_Tipo_ServicioInput = {
    where: ServicioScalarWhereInput
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyWithoutServicio_Tipo_ServicioInput>
  }

  export type ServicioScalarWhereInput = {
    AND?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
    OR?: ServicioScalarWhereInput[]
    NOT?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
    id_servicio?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    nivel?: IntFilter<"Servicio"> | number
    tipo_servicio?: IntFilter<"Servicio"> | number
    prestador?: IntFilter<"Servicio"> | number
  }

  export type TarifaCreateWithoutTarifa_ServicioInput = {
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutTarifa_EstudioInput
    Tarifa_Examen: ExamenCreateNestedOneWithoutTarifaInput
    Tarifa_Contrato: ContratoCreateNestedOneWithoutTarifaInput
  }

  export type TarifaUncheckedCreateWithoutTarifa_ServicioInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    examen: number
    contrato: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutTarifa_EstudioInput
  }

  export type TarifaCreateOrConnectWithoutTarifa_ServicioInput = {
    where: TarifaWhereUniqueInput
    create: XOR<TarifaCreateWithoutTarifa_ServicioInput, TarifaUncheckedCreateWithoutTarifa_ServicioInput>
  }

  export type TarifaCreateManyTarifa_ServicioInputEnvelope = {
    data: TarifaCreateManyTarifa_ServicioInput | TarifaCreateManyTarifa_ServicioInput[]
    skipDuplicates?: boolean
  }

  export type Tipo_ServicioCreateWithoutServicioInput = {
    nombre: string
    estado: $Enums.Estado
  }

  export type Tipo_ServicioUncheckedCreateWithoutServicioInput = {
    id_tipo_servicio?: number
    nombre: string
    estado: $Enums.Estado
  }

  export type Tipo_ServicioCreateOrConnectWithoutServicioInput = {
    where: Tipo_ServicioWhereUniqueInput
    create: XOR<Tipo_ServicioCreateWithoutServicioInput, Tipo_ServicioUncheckedCreateWithoutServicioInput>
  }

  export type PrestadorCreateWithoutServicioInput = {
    codigo: bigint | number
    nit: string
    razon_social: string
    profesional?: ProfesionalCreateNestedManyWithoutPropefisonal_PresatadorInput
  }

  export type PrestadorUncheckedCreateWithoutServicioInput = {
    id_prestador?: number
    codigo: bigint | number
    nit: string
    razon_social: string
    profesional?: ProfesionalUncheckedCreateNestedManyWithoutPropefisonal_PresatadorInput
  }

  export type PrestadorCreateOrConnectWithoutServicioInput = {
    where: PrestadorWhereUniqueInput
    create: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
  }

  export type TarifaUpsertWithWhereUniqueWithoutTarifa_ServicioInput = {
    where: TarifaWhereUniqueInput
    update: XOR<TarifaUpdateWithoutTarifa_ServicioInput, TarifaUncheckedUpdateWithoutTarifa_ServicioInput>
    create: XOR<TarifaCreateWithoutTarifa_ServicioInput, TarifaUncheckedCreateWithoutTarifa_ServicioInput>
  }

  export type TarifaUpdateWithWhereUniqueWithoutTarifa_ServicioInput = {
    where: TarifaWhereUniqueInput
    data: XOR<TarifaUpdateWithoutTarifa_ServicioInput, TarifaUncheckedUpdateWithoutTarifa_ServicioInput>
  }

  export type TarifaUpdateManyWithWhereWithoutTarifa_ServicioInput = {
    where: TarifaScalarWhereInput
    data: XOR<TarifaUpdateManyMutationInput, TarifaUncheckedUpdateManyWithoutTarifa_ServicioInput>
  }

  export type TarifaScalarWhereInput = {
    AND?: TarifaScalarWhereInput | TarifaScalarWhereInput[]
    OR?: TarifaScalarWhereInput[]
    NOT?: TarifaScalarWhereInput | TarifaScalarWhereInput[]
    id_tarifa?: IntFilter<"Tarifa"> | number
    estado?: EnumEstadoFilter<"Tarifa"> | $Enums.Estado
    precio?: DecimalFilter<"Tarifa"> | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFilter<"Tarifa"> | Date | string
    updateAt?: DateTimeFilter<"Tarifa"> | Date | string
    examen?: IntFilter<"Tarifa"> | number
    contrato?: IntFilter<"Tarifa"> | number
    servicio?: IntFilter<"Tarifa"> | number
  }

  export type Tipo_ServicioUpsertWithoutServicioInput = {
    update: XOR<Tipo_ServicioUpdateWithoutServicioInput, Tipo_ServicioUncheckedUpdateWithoutServicioInput>
    create: XOR<Tipo_ServicioCreateWithoutServicioInput, Tipo_ServicioUncheckedCreateWithoutServicioInput>
    where?: Tipo_ServicioWhereInput
  }

  export type Tipo_ServicioUpdateToOneWithWhereWithoutServicioInput = {
    where?: Tipo_ServicioWhereInput
    data: XOR<Tipo_ServicioUpdateWithoutServicioInput, Tipo_ServicioUncheckedUpdateWithoutServicioInput>
  }

  export type Tipo_ServicioUpdateWithoutServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ServicioUncheckedUpdateWithoutServicioInput = {
    id_tipo_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PrestadorUpsertWithoutServicioInput = {
    update: XOR<PrestadorUpdateWithoutServicioInput, PrestadorUncheckedUpdateWithoutServicioInput>
    create: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    where?: PrestadorWhereInput
  }

  export type PrestadorUpdateToOneWithWhereWithoutServicioInput = {
    where?: PrestadorWhereInput
    data: XOR<PrestadorUpdateWithoutServicioInput, PrestadorUncheckedUpdateWithoutServicioInput>
  }

  export type PrestadorUpdateWithoutServicioInput = {
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    profesional?: ProfesionalUpdateManyWithoutPropefisonal_PresatadorNestedInput
  }

  export type PrestadorUncheckedUpdateWithoutServicioInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    profesional?: ProfesionalUncheckedUpdateManyWithoutPropefisonal_PresatadorNestedInput
  }

  export type Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput = {
    nombre: string
    estado: $Enums.Estado
  }

  export type Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput = {
    id_tipo_resultado?: number
    nombre: string
    estado: $Enums.Estado
  }

  export type Tipo_ResultadoCreateOrConnectWithoutTipo_Resultado_examenInput = {
    where: Tipo_ResultadoWhereUniqueInput
    create: XOR<Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput, Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput>
  }

  export type Tipo_ResultadoCreateManyTipo_Resultado_examenInputEnvelope = {
    data: Tipo_ResultadoCreateManyTipo_Resultado_examenInput | Tipo_ResultadoCreateManyTipo_Resultado_examenInput[]
    skipDuplicates?: boolean
  }

  export type TarifaCreateWithoutTarifa_ExamenInput = {
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutTarifa_EstudioInput
    Tarifa_Contrato: ContratoCreateNestedOneWithoutTarifaInput
    Tarifa_Servicio: ServicioCreateNestedOneWithoutTarifaInput
  }

  export type TarifaUncheckedCreateWithoutTarifa_ExamenInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    servicio: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutTarifa_EstudioInput
  }

  export type TarifaCreateOrConnectWithoutTarifa_ExamenInput = {
    where: TarifaWhereUniqueInput
    create: XOR<TarifaCreateWithoutTarifa_ExamenInput, TarifaUncheckedCreateWithoutTarifa_ExamenInput>
  }

  export type TarifaCreateManyTarifa_ExamenInputEnvelope = {
    data: TarifaCreateManyTarifa_ExamenInput | TarifaCreateManyTarifa_ExamenInput[]
    skipDuplicates?: boolean
  }

  export type Tipo_ExamenCreateWithoutExamenInput = {
    nombre: string
    estado: $Enums.Estado
  }

  export type Tipo_ExamenUncheckedCreateWithoutExamenInput = {
    id_tipo_examen?: number
    nombre: string
    estado: $Enums.Estado
  }

  export type Tipo_ExamenCreateOrConnectWithoutExamenInput = {
    where: Tipo_ExamenWhereUniqueInput
    create: XOR<Tipo_ExamenCreateWithoutExamenInput, Tipo_ExamenUncheckedCreateWithoutExamenInput>
  }

  export type Tipo_ResultadoUpsertWithWhereUniqueWithoutTipo_Resultado_examenInput = {
    where: Tipo_ResultadoWhereUniqueInput
    update: XOR<Tipo_ResultadoUpdateWithoutTipo_Resultado_examenInput, Tipo_ResultadoUncheckedUpdateWithoutTipo_Resultado_examenInput>
    create: XOR<Tipo_ResultadoCreateWithoutTipo_Resultado_examenInput, Tipo_ResultadoUncheckedCreateWithoutTipo_Resultado_examenInput>
  }

  export type Tipo_ResultadoUpdateWithWhereUniqueWithoutTipo_Resultado_examenInput = {
    where: Tipo_ResultadoWhereUniqueInput
    data: XOR<Tipo_ResultadoUpdateWithoutTipo_Resultado_examenInput, Tipo_ResultadoUncheckedUpdateWithoutTipo_Resultado_examenInput>
  }

  export type Tipo_ResultadoUpdateManyWithWhereWithoutTipo_Resultado_examenInput = {
    where: Tipo_ResultadoScalarWhereInput
    data: XOR<Tipo_ResultadoUpdateManyMutationInput, Tipo_ResultadoUncheckedUpdateManyWithoutTipo_Resultado_examenInput>
  }

  export type Tipo_ResultadoScalarWhereInput = {
    AND?: Tipo_ResultadoScalarWhereInput | Tipo_ResultadoScalarWhereInput[]
    OR?: Tipo_ResultadoScalarWhereInput[]
    NOT?: Tipo_ResultadoScalarWhereInput | Tipo_ResultadoScalarWhereInput[]
    id_tipo_resultado?: IntFilter<"Tipo_Resultado"> | number
    nombre?: StringFilter<"Tipo_Resultado"> | string
    estado?: EnumEstadoFilter<"Tipo_Resultado"> | $Enums.Estado
    examen?: IntFilter<"Tipo_Resultado"> | number
  }

  export type TarifaUpsertWithWhereUniqueWithoutTarifa_ExamenInput = {
    where: TarifaWhereUniqueInput
    update: XOR<TarifaUpdateWithoutTarifa_ExamenInput, TarifaUncheckedUpdateWithoutTarifa_ExamenInput>
    create: XOR<TarifaCreateWithoutTarifa_ExamenInput, TarifaUncheckedCreateWithoutTarifa_ExamenInput>
  }

  export type TarifaUpdateWithWhereUniqueWithoutTarifa_ExamenInput = {
    where: TarifaWhereUniqueInput
    data: XOR<TarifaUpdateWithoutTarifa_ExamenInput, TarifaUncheckedUpdateWithoutTarifa_ExamenInput>
  }

  export type TarifaUpdateManyWithWhereWithoutTarifa_ExamenInput = {
    where: TarifaScalarWhereInput
    data: XOR<TarifaUpdateManyMutationInput, TarifaUncheckedUpdateManyWithoutTarifa_ExamenInput>
  }

  export type Tipo_ExamenUpsertWithoutExamenInput = {
    update: XOR<Tipo_ExamenUpdateWithoutExamenInput, Tipo_ExamenUncheckedUpdateWithoutExamenInput>
    create: XOR<Tipo_ExamenCreateWithoutExamenInput, Tipo_ExamenUncheckedCreateWithoutExamenInput>
    where?: Tipo_ExamenWhereInput
  }

  export type Tipo_ExamenUpdateToOneWithWhereWithoutExamenInput = {
    where?: Tipo_ExamenWhereInput
    data: XOR<Tipo_ExamenUpdateWithoutExamenInput, Tipo_ExamenUncheckedUpdateWithoutExamenInput>
  }

  export type Tipo_ExamenUpdateWithoutExamenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ExamenUncheckedUpdateWithoutExamenInput = {
    id_tipo_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ExamenCreateWithoutTipo_resultadoInput = {
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ExamenInput
    examen_tipo_examen: Tipo_ExamenCreateNestedOneWithoutExamenInput
  }

  export type ExamenUncheckedCreateWithoutTipo_resultadoInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tipo_examen: number
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ExamenInput
  }

  export type ExamenCreateOrConnectWithoutTipo_resultadoInput = {
    where: ExamenWhereUniqueInput
    create: XOR<ExamenCreateWithoutTipo_resultadoInput, ExamenUncheckedCreateWithoutTipo_resultadoInput>
  }

  export type ExamenUpsertWithoutTipo_resultadoInput = {
    update: XOR<ExamenUpdateWithoutTipo_resultadoInput, ExamenUncheckedUpdateWithoutTipo_resultadoInput>
    create: XOR<ExamenCreateWithoutTipo_resultadoInput, ExamenUncheckedCreateWithoutTipo_resultadoInput>
    where?: ExamenWhereInput
  }

  export type ExamenUpdateToOneWithWhereWithoutTipo_resultadoInput = {
    where?: ExamenWhereInput
    data: XOR<ExamenUpdateWithoutTipo_resultadoInput, ExamenUncheckedUpdateWithoutTipo_resultadoInput>
  }

  export type ExamenUpdateWithoutTipo_resultadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tarifa?: TarifaUpdateManyWithoutTarifa_ExamenNestedInput
    examen_tipo_examen?: Tipo_ExamenUpdateOneRequiredWithoutExamenNestedInput
  }

  export type ExamenUncheckedUpdateWithoutTipo_resultadoInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examen?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ExamenNestedInput
  }

  export type ExamenCreateWithoutExamen_tipo_examenInput = {
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tipo_resultado?: Tipo_ResultadoCreateNestedManyWithoutTipo_Resultado_examenInput
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ExamenInput
  }

  export type ExamenUncheckedCreateWithoutExamen_tipo_examenInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tipo_resultado?: Tipo_ResultadoUncheckedCreateNestedManyWithoutTipo_Resultado_examenInput
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ExamenInput
  }

  export type ExamenCreateOrConnectWithoutExamen_tipo_examenInput = {
    where: ExamenWhereUniqueInput
    create: XOR<ExamenCreateWithoutExamen_tipo_examenInput, ExamenUncheckedCreateWithoutExamen_tipo_examenInput>
  }

  export type ExamenCreateManyExamen_tipo_examenInputEnvelope = {
    data: ExamenCreateManyExamen_tipo_examenInput | ExamenCreateManyExamen_tipo_examenInput[]
    skipDuplicates?: boolean
  }

  export type ExamenUpsertWithWhereUniqueWithoutExamen_tipo_examenInput = {
    where: ExamenWhereUniqueInput
    update: XOR<ExamenUpdateWithoutExamen_tipo_examenInput, ExamenUncheckedUpdateWithoutExamen_tipo_examenInput>
    create: XOR<ExamenCreateWithoutExamen_tipo_examenInput, ExamenUncheckedCreateWithoutExamen_tipo_examenInput>
  }

  export type ExamenUpdateWithWhereUniqueWithoutExamen_tipo_examenInput = {
    where: ExamenWhereUniqueInput
    data: XOR<ExamenUpdateWithoutExamen_tipo_examenInput, ExamenUncheckedUpdateWithoutExamen_tipo_examenInput>
  }

  export type ExamenUpdateManyWithWhereWithoutExamen_tipo_examenInput = {
    where: ExamenScalarWhereInput
    data: XOR<ExamenUpdateManyMutationInput, ExamenUncheckedUpdateManyWithoutExamen_tipo_examenInput>
  }

  export type ExamenScalarWhereInput = {
    AND?: ExamenScalarWhereInput | ExamenScalarWhereInput[]
    OR?: ExamenScalarWhereInput[]
    NOT?: ExamenScalarWhereInput | ExamenScalarWhereInput[]
    id_examen?: IntFilter<"Examen"> | number
    nombre?: StringFilter<"Examen"> | string
    unidades?: StringFilter<"Examen"> | string
    rango_biologico?: StringFilter<"Examen"> | string
    metodo?: StringFilter<"Examen"> | string
    precio?: DecimalFilter<"Examen"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Examen"> | $Enums.Estado
    tipo_examen?: IntFilter<"Examen"> | number
  }

  export type ServicioCreateWithoutPrestador_ServicioInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ServicioInput
    Servicio_Tipo_Servicio: Tipo_ServicioCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutPrestador_ServicioInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tipo_servicio: number
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ServicioInput
  }

  export type ServicioCreateOrConnectWithoutPrestador_ServicioInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput>
  }

  export type ServicioCreateManyPrestador_ServicioInputEnvelope = {
    data: ServicioCreateManyPrestador_ServicioInput | ServicioCreateManyPrestador_ServicioInput[]
    skipDuplicates?: boolean
  }

  export type ProfesionalCreateWithoutPropefisonal_PresatadorInput = {
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado: $Enums.Estado
  }

  export type ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput = {
    id_profesional?: number
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado: $Enums.Estado
  }

  export type ProfesionalCreateOrConnectWithoutPropefisonal_PresatadorInput = {
    where: ProfesionalWhereUniqueInput
    create: XOR<ProfesionalCreateWithoutPropefisonal_PresatadorInput, ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput>
  }

  export type ProfesionalCreateManyPropefisonal_PresatadorInputEnvelope = {
    data: ProfesionalCreateManyPropefisonal_PresatadorInput | ProfesionalCreateManyPropefisonal_PresatadorInput[]
    skipDuplicates?: boolean
  }

  export type ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput = {
    where: ServicioWhereUniqueInput
    update: XOR<ServicioUpdateWithoutPrestador_ServicioInput, ServicioUncheckedUpdateWithoutPrestador_ServicioInput>
    create: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput>
  }

  export type ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput = {
    where: ServicioWhereUniqueInput
    data: XOR<ServicioUpdateWithoutPrestador_ServicioInput, ServicioUncheckedUpdateWithoutPrestador_ServicioInput>
  }

  export type ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput = {
    where: ServicioScalarWhereInput
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyWithoutPrestador_ServicioInput>
  }

  export type ProfesionalUpsertWithWhereUniqueWithoutPropefisonal_PresatadorInput = {
    where: ProfesionalWhereUniqueInput
    update: XOR<ProfesionalUpdateWithoutPropefisonal_PresatadorInput, ProfesionalUncheckedUpdateWithoutPropefisonal_PresatadorInput>
    create: XOR<ProfesionalCreateWithoutPropefisonal_PresatadorInput, ProfesionalUncheckedCreateWithoutPropefisonal_PresatadorInput>
  }

  export type ProfesionalUpdateWithWhereUniqueWithoutPropefisonal_PresatadorInput = {
    where: ProfesionalWhereUniqueInput
    data: XOR<ProfesionalUpdateWithoutPropefisonal_PresatadorInput, ProfesionalUncheckedUpdateWithoutPropefisonal_PresatadorInput>
  }

  export type ProfesionalUpdateManyWithWhereWithoutPropefisonal_PresatadorInput = {
    where: ProfesionalScalarWhereInput
    data: XOR<ProfesionalUpdateManyMutationInput, ProfesionalUncheckedUpdateManyWithoutPropefisonal_PresatadorInput>
  }

  export type ProfesionalScalarWhereInput = {
    AND?: ProfesionalScalarWhereInput | ProfesionalScalarWhereInput[]
    OR?: ProfesionalScalarWhereInput[]
    NOT?: ProfesionalScalarWhereInput | ProfesionalScalarWhereInput[]
    id_profesional?: IntFilter<"Profesional"> | number
    identificacion?: BigIntFilter<"Profesional"> | bigint | number
    nombre?: StringFilter<"Profesional"> | string
    cargo?: StringFilter<"Profesional"> | string
    rol?: EnumRolFilter<"Profesional"> | $Enums.Rol
    email?: StringFilter<"Profesional"> | string
    password?: StringFilter<"Profesional"> | string
    estado?: EnumEstadoFilter<"Profesional"> | $Enums.Estado
    prestador?: IntFilter<"Profesional"> | number
  }

  export type PrestadorCreateWithoutProfesionalInput = {
    codigo: bigint | number
    nit: string
    razon_social: string
    servicio?: ServicioCreateNestedManyWithoutPrestador_ServicioInput
  }

  export type PrestadorUncheckedCreateWithoutProfesionalInput = {
    id_prestador?: number
    codigo: bigint | number
    nit: string
    razon_social: string
    servicio?: ServicioUncheckedCreateNestedManyWithoutPrestador_ServicioInput
  }

  export type PrestadorCreateOrConnectWithoutProfesionalInput = {
    where: PrestadorWhereUniqueInput
    create: XOR<PrestadorCreateWithoutProfesionalInput, PrestadorUncheckedCreateWithoutProfesionalInput>
  }

  export type PrestadorUpsertWithoutProfesionalInput = {
    update: XOR<PrestadorUpdateWithoutProfesionalInput, PrestadorUncheckedUpdateWithoutProfesionalInput>
    create: XOR<PrestadorCreateWithoutProfesionalInput, PrestadorUncheckedCreateWithoutProfesionalInput>
    where?: PrestadorWhereInput
  }

  export type PrestadorUpdateToOneWithWhereWithoutProfesionalInput = {
    where?: PrestadorWhereInput
    data: XOR<PrestadorUpdateWithoutProfesionalInput, PrestadorUncheckedUpdateWithoutProfesionalInput>
  }

  export type PrestadorUpdateWithoutProfesionalInput = {
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    servicio?: ServicioUpdateManyWithoutPrestador_ServicioNestedInput
  }

  export type PrestadorUncheckedUpdateWithoutProfesionalInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    servicio?: ServicioUncheckedUpdateManyWithoutPrestador_ServicioNestedInput
  }

  export type ContratoCreateWithoutContrato_EmpresaInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    tarifa?: TarifaCreateNestedManyWithoutTarifa_ContratoInput
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimeinto_ContratoInput
  }

  export type ContratoUncheckedCreateWithoutContrato_EmpresaInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    tarifa?: TarifaUncheckedCreateNestedManyWithoutTarifa_ContratoInput
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimeinto_ContratoInput
  }

  export type ContratoCreateOrConnectWithoutContrato_EmpresaInput = {
    where: ContratoWhereUniqueInput
    create: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput>
  }

  export type ContratoCreateManyContrato_EmpresaInputEnvelope = {
    data: ContratoCreateManyContrato_EmpresaInput | ContratoCreateManyContrato_EmpresaInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioCreateWithoutEmpresaInput = {
    nombre: string
    suario?: UsuarioCreateNestedManyWithoutMunicipio_UsuarioInput
    Departamentos_Municipio: DepartamentoCreateNestedOneWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateWithoutEmpresaInput = {
    id_municipio?: number
    nombre: string
    departamento: number
    suario?: UsuarioUncheckedCreateNestedManyWithoutMunicipio_UsuarioInput
  }

  export type MunicipioCreateOrConnectWithoutEmpresaInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
  }

  export type ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput = {
    where: ContratoWhereUniqueInput
    update: XOR<ContratoUpdateWithoutContrato_EmpresaInput, ContratoUncheckedUpdateWithoutContrato_EmpresaInput>
    create: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput>
  }

  export type ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput = {
    where: ContratoWhereUniqueInput
    data: XOR<ContratoUpdateWithoutContrato_EmpresaInput, ContratoUncheckedUpdateWithoutContrato_EmpresaInput>
  }

  export type ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput = {
    where: ContratoScalarWhereInput
    data: XOR<ContratoUpdateManyMutationInput, ContratoUncheckedUpdateManyWithoutContrato_EmpresaInput>
  }

  export type ContratoScalarWhereInput = {
    AND?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
    OR?: ContratoScalarWhereInput[]
    NOT?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
    id_contrato?: IntFilter<"Contrato"> | number
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresa?: IntFilter<"Contrato"> | number
  }

  export type MunicipioUpsertWithoutEmpresaInput = {
    update: XOR<MunicipioUpdateWithoutEmpresaInput, MunicipioUncheckedUpdateWithoutEmpresaInput>
    create: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    where?: MunicipioWhereInput
  }

  export type MunicipioUpdateToOneWithWhereWithoutEmpresaInput = {
    where?: MunicipioWhereInput
    data: XOR<MunicipioUpdateWithoutEmpresaInput, MunicipioUncheckedUpdateWithoutEmpresaInput>
  }

  export type MunicipioUpdateWithoutEmpresaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    suario?: UsuarioUpdateManyWithoutMunicipio_UsuarioNestedInput
    Departamentos_Municipio?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutEmpresaInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: IntFieldUpdateOperationsInput | number
    suario?: UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioNestedInput
  }

  export type TarifaCreateWithoutTarifa_ContratoInput = {
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutTarifa_EstudioInput
    Tarifa_Examen: ExamenCreateNestedOneWithoutTarifaInput
    Tarifa_Servicio: ServicioCreateNestedOneWithoutTarifaInput
  }

  export type TarifaUncheckedCreateWithoutTarifa_ContratoInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    examen: number
    servicio: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutTarifa_EstudioInput
  }

  export type TarifaCreateOrConnectWithoutTarifa_ContratoInput = {
    where: TarifaWhereUniqueInput
    create: XOR<TarifaCreateWithoutTarifa_ContratoInput, TarifaUncheckedCreateWithoutTarifa_ContratoInput>
  }

  export type TarifaCreateManyTarifa_ContratoInputEnvelope = {
    data: TarifaCreateManyTarifa_ContratoInput | TarifaCreateManyTarifa_ContratoInput[]
    skipDuplicates?: boolean
  }

  export type ProcedimientoCreateWithoutProcedimeinto_ContratoInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutEstudio_ProcedimientoInput
    Tipo_Procedimiento_Procedimiento: Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput
    Procedimiento_Usuario: UsuarioCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    tipo_procedimiento: number
    usuario: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutEstudio_ProcedimientoInput
  }

  export type ProcedimientoCreateOrConnectWithoutProcedimeinto_ContratoInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutProcedimeinto_ContratoInput, ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput>
  }

  export type ProcedimientoCreateManyProcedimeinto_ContratoInputEnvelope = {
    data: ProcedimientoCreateManyProcedimeinto_ContratoInput | ProcedimientoCreateManyProcedimeinto_ContratoInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaCreateWithoutContratoInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    Muncipio_Empresa: MunicipioCreateNestedOneWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutContratoInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipio: number
  }

  export type EmpresaCreateOrConnectWithoutContratoInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
  }

  export type TarifaUpsertWithWhereUniqueWithoutTarifa_ContratoInput = {
    where: TarifaWhereUniqueInput
    update: XOR<TarifaUpdateWithoutTarifa_ContratoInput, TarifaUncheckedUpdateWithoutTarifa_ContratoInput>
    create: XOR<TarifaCreateWithoutTarifa_ContratoInput, TarifaUncheckedCreateWithoutTarifa_ContratoInput>
  }

  export type TarifaUpdateWithWhereUniqueWithoutTarifa_ContratoInput = {
    where: TarifaWhereUniqueInput
    data: XOR<TarifaUpdateWithoutTarifa_ContratoInput, TarifaUncheckedUpdateWithoutTarifa_ContratoInput>
  }

  export type TarifaUpdateManyWithWhereWithoutTarifa_ContratoInput = {
    where: TarifaScalarWhereInput
    data: XOR<TarifaUpdateManyMutationInput, TarifaUncheckedUpdateManyWithoutTarifa_ContratoInput>
  }

  export type ProcedimientoUpsertWithWhereUniqueWithoutProcedimeinto_ContratoInput = {
    where: ProcedimientoWhereUniqueInput
    update: XOR<ProcedimientoUpdateWithoutProcedimeinto_ContratoInput, ProcedimientoUncheckedUpdateWithoutProcedimeinto_ContratoInput>
    create: XOR<ProcedimientoCreateWithoutProcedimeinto_ContratoInput, ProcedimientoUncheckedCreateWithoutProcedimeinto_ContratoInput>
  }

  export type ProcedimientoUpdateWithWhereUniqueWithoutProcedimeinto_ContratoInput = {
    where: ProcedimientoWhereUniqueInput
    data: XOR<ProcedimientoUpdateWithoutProcedimeinto_ContratoInput, ProcedimientoUncheckedUpdateWithoutProcedimeinto_ContratoInput>
  }

  export type ProcedimientoUpdateManyWithWhereWithoutProcedimeinto_ContratoInput = {
    where: ProcedimientoScalarWhereInput
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyWithoutProcedimeinto_ContratoInput>
  }

  export type EmpresaUpsertWithoutContratoInput = {
    update: XOR<EmpresaUpdateWithoutContratoInput, EmpresaUncheckedUpdateWithoutContratoInput>
    create: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutContratoInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutContratoInput, EmpresaUncheckedUpdateWithoutContratoInput>
  }

  export type EmpresaUpdateWithoutContratoInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    Muncipio_Empresa?: MunicipioUpdateOneRequiredWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutContratoInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateWithoutTarifa_EstudioInput = {
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    Estudio_Procedimiento: ProcedimientoCreateNestedOneWithoutEstudioInput
  }

  export type EstudioUncheckedCreateWithoutTarifa_EstudioInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    procedimiento: number
  }

  export type EstudioCreateOrConnectWithoutTarifa_EstudioInput = {
    where: EstudioWhereUniqueInput
    create: XOR<EstudioCreateWithoutTarifa_EstudioInput, EstudioUncheckedCreateWithoutTarifa_EstudioInput>
  }

  export type EstudioCreateManyTarifa_EstudioInputEnvelope = {
    data: EstudioCreateManyTarifa_EstudioInput | EstudioCreateManyTarifa_EstudioInput[]
    skipDuplicates?: boolean
  }

  export type ExamenCreateWithoutTarifaInput = {
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tipo_resultado?: Tipo_ResultadoCreateNestedManyWithoutTipo_Resultado_examenInput
    examen_tipo_examen: Tipo_ExamenCreateNestedOneWithoutExamenInput
  }

  export type ExamenUncheckedCreateWithoutTarifaInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    tipo_examen: number
    tipo_resultado?: Tipo_ResultadoUncheckedCreateNestedManyWithoutTipo_Resultado_examenInput
  }

  export type ExamenCreateOrConnectWithoutTarifaInput = {
    where: ExamenWhereUniqueInput
    create: XOR<ExamenCreateWithoutTarifaInput, ExamenUncheckedCreateWithoutTarifaInput>
  }

  export type ContratoCreateWithoutTarifaInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimeinto_ContratoInput
    Contrato_Empresa: EmpresaCreateNestedOneWithoutContratoInput
  }

  export type ContratoUncheckedCreateWithoutTarifaInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    empresa: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimeinto_ContratoInput
  }

  export type ContratoCreateOrConnectWithoutTarifaInput = {
    where: ContratoWhereUniqueInput
    create: XOR<ContratoCreateWithoutTarifaInput, ContratoUncheckedCreateWithoutTarifaInput>
  }

  export type ServicioCreateWithoutTarifaInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    Servicio_Tipo_Servicio: Tipo_ServicioCreateNestedOneWithoutServicioInput
    Prestador_Servicio: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutTarifaInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tipo_servicio: number
    prestador: number
  }

  export type ServicioCreateOrConnectWithoutTarifaInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutTarifaInput, ServicioUncheckedCreateWithoutTarifaInput>
  }

  export type EstudioUpsertWithWhereUniqueWithoutTarifa_EstudioInput = {
    where: EstudioWhereUniqueInput
    update: XOR<EstudioUpdateWithoutTarifa_EstudioInput, EstudioUncheckedUpdateWithoutTarifa_EstudioInput>
    create: XOR<EstudioCreateWithoutTarifa_EstudioInput, EstudioUncheckedCreateWithoutTarifa_EstudioInput>
  }

  export type EstudioUpdateWithWhereUniqueWithoutTarifa_EstudioInput = {
    where: EstudioWhereUniqueInput
    data: XOR<EstudioUpdateWithoutTarifa_EstudioInput, EstudioUncheckedUpdateWithoutTarifa_EstudioInput>
  }

  export type EstudioUpdateManyWithWhereWithoutTarifa_EstudioInput = {
    where: EstudioScalarWhereInput
    data: XOR<EstudioUpdateManyMutationInput, EstudioUncheckedUpdateManyWithoutTarifa_EstudioInput>
  }

  export type ExamenUpsertWithoutTarifaInput = {
    update: XOR<ExamenUpdateWithoutTarifaInput, ExamenUncheckedUpdateWithoutTarifaInput>
    create: XOR<ExamenCreateWithoutTarifaInput, ExamenUncheckedCreateWithoutTarifaInput>
    where?: ExamenWhereInput
  }

  export type ExamenUpdateToOneWithWhereWithoutTarifaInput = {
    where?: ExamenWhereInput
    data: XOR<ExamenUpdateWithoutTarifaInput, ExamenUncheckedUpdateWithoutTarifaInput>
  }

  export type ExamenUpdateWithoutTarifaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_resultado?: Tipo_ResultadoUpdateManyWithoutTipo_Resultado_examenNestedInput
    examen_tipo_examen?: Tipo_ExamenUpdateOneRequiredWithoutExamenNestedInput
  }

  export type ExamenUncheckedUpdateWithoutTarifaInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examen?: IntFieldUpdateOperationsInput | number
    tipo_resultado?: Tipo_ResultadoUncheckedUpdateManyWithoutTipo_Resultado_examenNestedInput
  }

  export type ContratoUpsertWithoutTarifaInput = {
    update: XOR<ContratoUpdateWithoutTarifaInput, ContratoUncheckedUpdateWithoutTarifaInput>
    create: XOR<ContratoCreateWithoutTarifaInput, ContratoUncheckedCreateWithoutTarifaInput>
    where?: ContratoWhereInput
  }

  export type ContratoUpdateToOneWithWhereWithoutTarifaInput = {
    where?: ContratoWhereInput
    data: XOR<ContratoUpdateWithoutTarifaInput, ContratoUncheckedUpdateWithoutTarifaInput>
  }

  export type ContratoUpdateWithoutTarifaInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimeinto_ContratoNestedInput
    Contrato_Empresa?: EmpresaUpdateOneRequiredWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateWithoutTarifaInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimeinto_ContratoNestedInput
  }

  export type ServicioUpsertWithoutTarifaInput = {
    update: XOR<ServicioUpdateWithoutTarifaInput, ServicioUncheckedUpdateWithoutTarifaInput>
    create: XOR<ServicioCreateWithoutTarifaInput, ServicioUncheckedCreateWithoutTarifaInput>
    where?: ServicioWhereInput
  }

  export type ServicioUpdateToOneWithWhereWithoutTarifaInput = {
    where?: ServicioWhereInput
    data: XOR<ServicioUpdateWithoutTarifaInput, ServicioUncheckedUpdateWithoutTarifaInput>
  }

  export type ServicioUpdateWithoutTarifaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    Servicio_Tipo_Servicio?: Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput
    Prestador_Servicio?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutTarifaInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tipo_servicio?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoCreateManyProcedimiento_UsuarioInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    tipo_procedimiento: number
  }

  export type ProcedimientoUpdateWithoutProcedimiento_UsuarioInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutEstudio_ProcedimientoNestedInput
    Procedimeinto_Contrato?: ContratoUpdateOneRequiredWithoutProcedimientoNestedInput
    Tipo_Procedimiento_Procedimiento?: Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutProcedimiento_UsuarioInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutEstudio_ProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    tipo_procedimiento?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateManyEps_usuarioInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UsuarioUpdateWithoutEps_usuarioInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_UsuarioNestedInput
    Municipio_Usuario?: MunicipioUpdateOneRequiredWithoutSuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEps_usuarioInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutEps_usuarioInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedimientoCreateManyTipo_Procedimiento_ProcedimientoInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    usuario: number
  }

  export type ProcedimientoUpdateWithoutTipo_Procedimiento_ProcedimientoInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutEstudio_ProcedimientoNestedInput
    Procedimeinto_Contrato?: ContratoUpdateOneRequiredWithoutProcedimientoNestedInput
    Procedimiento_Usuario?: UsuarioUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutTipo_Procedimiento_ProcedimientoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutEstudio_ProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateManyWithoutTipo_Procedimiento_ProcedimientoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateManyEstudio_ProcedimientoInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    tarifa: number
  }

  export type EstudioUpdateWithoutEstudio_ProcedimientoInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    Tarifa_Estudio?: TarifaUpdateOneRequiredWithoutEstudioNestedInput
  }

  export type EstudioUncheckedUpdateWithoutEstudio_ProcedimientoInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioUncheckedUpdateManyWithoutEstudio_ProcedimientoInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
  }

  export type MunicipioCreateManyDepartamentos_MunicipioInput = {
    id_municipio?: number
    nombre: string
  }

  export type MunicipioUpdateWithoutDepartamentos_MunicipioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    suario?: UsuarioUpdateManyWithoutMunicipio_UsuarioNestedInput
    empresa?: EmpresaUpdateManyWithoutMuncipio_EmpresaNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutDepartamentos_MunicipioInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    suario?: UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioNestedInput
    empresa?: EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaNestedInput
  }

  export type MunicipioUncheckedUpdateManyWithoutDepartamentos_MunicipioInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateManyMunicipio_UsuarioInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
  }

  export type EmpresaCreateManyMuncipio_EmpresaInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
  }

  export type UsuarioUpdateWithoutMunicipio_UsuarioInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_UsuarioNestedInput
    Eps_usuario?: EpsUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMunicipio_UsuarioInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
  }

  export type EmpresaUpdateWithoutMuncipio_EmpresaInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: ContratoUpdateManyWithoutContrato_EmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutMuncipio_EmpresaInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: ContratoUncheckedUpdateManyWithoutContrato_EmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ServicioCreateManyServicio_Tipo_ServicioInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    prestador: number
  }

  export type ServicioUpdateWithoutServicio_Tipo_ServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUpdateManyWithoutTarifa_ServicioNestedInput
    Prestador_Servicio?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutServicio_Tipo_ServicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ServicioNestedInput
  }

  export type ServicioUncheckedUpdateManyWithoutServicio_Tipo_ServicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type TarifaCreateManyTarifa_ServicioInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    examen: number
    contrato: number
  }

  export type TarifaUpdateWithoutTarifa_ServicioInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutTarifa_EstudioNestedInput
    Tarifa_Examen?: ExamenUpdateOneRequiredWithoutTarifaNestedInput
    Tarifa_Contrato?: ContratoUpdateOneRequiredWithoutTarifaNestedInput
  }

  export type TarifaUncheckedUpdateWithoutTarifa_ServicioInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examen?: IntFieldUpdateOperationsInput | number
    contrato?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutTarifa_EstudioNestedInput
  }

  export type TarifaUncheckedUpdateManyWithoutTarifa_ServicioInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examen?: IntFieldUpdateOperationsInput | number
    contrato?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ResultadoCreateManyTipo_Resultado_examenInput = {
    id_tipo_resultado?: number
    nombre: string
    estado: $Enums.Estado
  }

  export type TarifaCreateManyTarifa_ExamenInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: number
    servicio: number
  }

  export type Tipo_ResultadoUpdateWithoutTipo_Resultado_examenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ResultadoUncheckedUpdateWithoutTipo_Resultado_examenInput = {
    id_tipo_resultado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ResultadoUncheckedUpdateManyWithoutTipo_Resultado_examenInput = {
    id_tipo_resultado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type TarifaUpdateWithoutTarifa_ExamenInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutTarifa_EstudioNestedInput
    Tarifa_Contrato?: ContratoUpdateOneRequiredWithoutTarifaNestedInput
    Tarifa_Servicio?: ServicioUpdateOneRequiredWithoutTarifaNestedInput
  }

  export type TarifaUncheckedUpdateWithoutTarifa_ExamenInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    servicio?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutTarifa_EstudioNestedInput
  }

  export type TarifaUncheckedUpdateManyWithoutTarifa_ExamenInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: IntFieldUpdateOperationsInput | number
    servicio?: IntFieldUpdateOperationsInput | number
  }

  export type ExamenCreateManyExamen_tipo_examenInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
  }

  export type ExamenUpdateWithoutExamen_tipo_examenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_resultado?: Tipo_ResultadoUpdateManyWithoutTipo_Resultado_examenNestedInput
    tarifa?: TarifaUpdateManyWithoutTarifa_ExamenNestedInput
  }

  export type ExamenUncheckedUpdateWithoutExamen_tipo_examenInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_resultado?: Tipo_ResultadoUncheckedUpdateManyWithoutTipo_Resultado_examenNestedInput
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ExamenNestedInput
  }

  export type ExamenUncheckedUpdateManyWithoutExamen_tipo_examenInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ServicioCreateManyPrestador_ServicioInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tipo_servicio: number
  }

  export type ProfesionalCreateManyPropefisonal_PresatadorInput = {
    id_profesional?: number
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado: $Enums.Estado
  }

  export type ServicioUpdateWithoutPrestador_ServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUpdateManyWithoutTarifa_ServicioNestedInput
    Servicio_Tipo_Servicio?: Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutPrestador_ServicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tipo_servicio?: IntFieldUpdateOperationsInput | number
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ServicioNestedInput
  }

  export type ServicioUncheckedUpdateManyWithoutPrestador_ServicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tipo_servicio?: IntFieldUpdateOperationsInput | number
  }

  export type ProfesionalUpdateWithoutPropefisonal_PresatadorInput = {
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ProfesionalUncheckedUpdateWithoutPropefisonal_PresatadorInput = {
    id_profesional?: IntFieldUpdateOperationsInput | number
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ProfesionalUncheckedUpdateManyWithoutPropefisonal_PresatadorInput = {
    id_profesional?: IntFieldUpdateOperationsInput | number
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ContratoCreateManyContrato_EmpresaInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
  }

  export type ContratoUpdateWithoutContrato_EmpresaInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tarifa?: TarifaUpdateManyWithoutTarifa_ContratoNestedInput
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimeinto_ContratoNestedInput
  }

  export type ContratoUncheckedUpdateWithoutContrato_EmpresaInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tarifa?: TarifaUncheckedUpdateManyWithoutTarifa_ContratoNestedInput
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimeinto_ContratoNestedInput
  }

  export type ContratoUncheckedUpdateManyWithoutContrato_EmpresaInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type TarifaCreateManyTarifa_ContratoInput = {
    id_tarifa?: number
    estado: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    examen: number
    servicio: number
  }

  export type ProcedimientoCreateManyProcedimeinto_ContratoInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    createAt?: Date | string
    updateAt?: Date | string
    tipo_procedimiento: number
    usuario: number
  }

  export type TarifaUpdateWithoutTarifa_ContratoInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutTarifa_EstudioNestedInput
    Tarifa_Examen?: ExamenUpdateOneRequiredWithoutTarifaNestedInput
    Tarifa_Servicio?: ServicioUpdateOneRequiredWithoutTarifaNestedInput
  }

  export type TarifaUncheckedUpdateWithoutTarifa_ContratoInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examen?: IntFieldUpdateOperationsInput | number
    servicio?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutTarifa_EstudioNestedInput
  }

  export type TarifaUncheckedUpdateManyWithoutTarifa_ContratoInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examen?: IntFieldUpdateOperationsInput | number
    servicio?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoUpdateWithoutProcedimeinto_ContratoInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutEstudio_ProcedimientoNestedInput
    Tipo_Procedimiento_Procedimiento?: Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput
    Procedimiento_Usuario?: UsuarioUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutProcedimeinto_ContratoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutEstudio_ProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateManyWithoutProcedimeinto_ContratoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateManyTarifa_EstudioInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    procedimiento: number
  }

  export type EstudioUpdateWithoutTarifa_EstudioInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    Estudio_Procedimiento?: ProcedimientoUpdateOneRequiredWithoutEstudioNestedInput
  }

  export type EstudioUncheckedUpdateWithoutTarifa_EstudioInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    procedimiento?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioUncheckedUpdateManyWithoutTarifa_EstudioInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    procedimiento?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EpsCountOutputTypeDefaultArgs instead
     */
    export type EpsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EpsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ProcedimientoCountOutputTypeDefaultArgs instead
     */
    export type Tipo_ProcedimientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedimientoCountOutputTypeDefaultArgs instead
     */
    export type ProcedimientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartamentoCountOutputTypeDefaultArgs instead
     */
    export type DepartamentoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioCountOutputTypeDefaultArgs instead
     */
    export type MunicipioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ServicioCountOutputTypeDefaultArgs instead
     */
    export type Tipo_ServicioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ServicioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicioCountOutputTypeDefaultArgs instead
     */
    export type ServicioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamenCountOutputTypeDefaultArgs instead
     */
    export type ExamenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ExamenCountOutputTypeDefaultArgs instead
     */
    export type Tipo_ExamenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ExamenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrestadorCountOutputTypeDefaultArgs instead
     */
    export type PrestadorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrestadorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaCountOutputTypeDefaultArgs instead
     */
    export type EmpresaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContratoCountOutputTypeDefaultArgs instead
     */
    export type ContratoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContratoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TarifaCountOutputTypeDefaultArgs instead
     */
    export type TarifaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TarifaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EpsDefaultArgs instead
     */
    export type EpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EpsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ProcedimientoDefaultArgs instead
     */
    export type Tipo_ProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ProcedimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedimientoDefaultArgs instead
     */
    export type ProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstudioDefaultArgs instead
     */
    export type EstudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstudioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartamentoDefaultArgs instead
     */
    export type DepartamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioDefaultArgs instead
     */
    export type MunicipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ServicioDefaultArgs instead
     */
    export type Tipo_ServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ServicioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicioDefaultArgs instead
     */
    export type ServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamenDefaultArgs instead
     */
    export type ExamenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ResultadoDefaultArgs instead
     */
    export type Tipo_ResultadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ResultadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ExamenDefaultArgs instead
     */
    export type Tipo_ExamenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ExamenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrestadorDefaultArgs instead
     */
    export type PrestadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrestadorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfesionalDefaultArgs instead
     */
    export type ProfesionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfesionalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaDefaultArgs instead
     */
    export type EmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContratoDefaultArgs instead
     */
    export type ContratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContratoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TarifaDefaultArgs instead
     */
    export type TarifaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TarifaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}