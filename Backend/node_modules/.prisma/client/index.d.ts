
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Paciente
 * 
 */
export type Paciente = $Result.DefaultSelection<Prisma.$PacientePayload>
/**
 * Model Eps
 * 
 */
export type Eps = $Result.DefaultSelection<Prisma.$EpsPayload>
/**
 * Model Tipo_Procedimiento
 * 
 */
export type Tipo_Procedimiento = $Result.DefaultSelection<Prisma.$Tipo_ProcedimientoPayload>
/**
 * Model Procedimiento
 * 
 */
export type Procedimiento = $Result.DefaultSelection<Prisma.$ProcedimientoPayload>
/**
 * Model Estudio
 * 
 */
export type Estudio = $Result.DefaultSelection<Prisma.$EstudioPayload>
/**
 * Model Departamento
 * 
 */
export type Departamento = $Result.DefaultSelection<Prisma.$DepartamentoPayload>
/**
 * Model Municipio
 * 
 */
export type Municipio = $Result.DefaultSelection<Prisma.$MunicipioPayload>
/**
 * Model Tipo_Servicio
 * 
 */
export type Tipo_Servicio = $Result.DefaultSelection<Prisma.$Tipo_ServicioPayload>
/**
 * Model Servicio
 * 
 */
export type Servicio = $Result.DefaultSelection<Prisma.$ServicioPayload>
/**
 * Model Examen
 * 
 */
export type Examen = $Result.DefaultSelection<Prisma.$ExamenPayload>
/**
 * Model Tipo_Resultado
 * 
 */
export type Tipo_Resultado = $Result.DefaultSelection<Prisma.$Tipo_ResultadoPayload>
/**
 * Model Tipo_Examen
 * 
 */
export type Tipo_Examen = $Result.DefaultSelection<Prisma.$Tipo_ExamenPayload>
/**
 * Model Prestador
 * 
 */
export type Prestador = $Result.DefaultSelection<Prisma.$PrestadorPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Empresa
 * 
 */
export type Empresa = $Result.DefaultSelection<Prisma.$EmpresaPayload>
/**
 * Model Contrato
 * 
 */
export type Contrato = $Result.DefaultSelection<Prisma.$ContratoPayload>
/**
 * Model Acuerdo
 * 
 */
export type Acuerdo = $Result.DefaultSelection<Prisma.$AcuerdoPayload>
/**
 * Model Paquete
 * 
 */
export type Paquete = $Result.DefaultSelection<Prisma.$PaquetePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Tipo_Ident: {
  CC: 'CC',
  CE: 'CE',
  CD: 'CD',
  PA: 'PA',
  SC: 'SC',
  PE: 'PE',
  RC: 'RC',
  TI: 'TI',
  CN: 'CN',
  AS: 'AS',
  MS: 'MS'
};

export type Tipo_Ident = (typeof Tipo_Ident)[keyof typeof Tipo_Ident]


export const Sex: {
  Femenino: 'Femenino',
  Masculino: 'Masculino',
  Indetermidado: 'Indetermidado'
};

export type Sex = (typeof Sex)[keyof typeof Sex]


export const Tipo_Paciente: {
  Contributivo: 'Contributivo',
  Subsidiado: 'Subsidiado',
  Vinculado: 'Vinculado',
  Particular: 'Particular',
  Otro: 'Otro'
};

export type Tipo_Paciente = (typeof Tipo_Paciente)[keyof typeof Tipo_Paciente]


export const Estado: {
  Activo: 'Activo',
  Inactivo: 'Inactivo'
};

export type Estado = (typeof Estado)[keyof typeof Estado]


export const Rol: {
  Administrador: 'Administrador',
  Facturacion: 'Facturacion',
  Bacteriologo: 'Bacteriologo'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const Tipo_Empresa: {
  Particular: 'Particular',
  Empresa: 'Empresa',
  Eps: 'Eps',
  Esess: 'Esess'
};

export type Tipo_Empresa = (typeof Tipo_Empresa)[keyof typeof Tipo_Empresa]

}

export type Tipo_Ident = $Enums.Tipo_Ident

export const Tipo_Ident: typeof $Enums.Tipo_Ident

export type Sex = $Enums.Sex

export const Sex: typeof $Enums.Sex

export type Tipo_Paciente = $Enums.Tipo_Paciente

export const Tipo_Paciente: typeof $Enums.Tipo_Paciente

export type Estado = $Enums.Estado

export const Estado: typeof $Enums.Estado

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type Tipo_Empresa = $Enums.Tipo_Empresa

export const Tipo_Empresa: typeof $Enums.Tipo_Empresa

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Pacientes
 * const pacientes = await prisma.paciente.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Pacientes
   * const pacientes = await prisma.paciente.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.paciente`: Exposes CRUD operations for the **Paciente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pacientes
    * const pacientes = await prisma.paciente.findMany()
    * ```
    */
  get paciente(): Prisma.PacienteDelegate<ExtArgs>;

  /**
   * `prisma.eps`: Exposes CRUD operations for the **Eps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eps
    * const eps = await prisma.eps.findMany()
    * ```
    */
  get eps(): Prisma.EpsDelegate<ExtArgs>;

  /**
   * `prisma.tipo_Procedimiento`: Exposes CRUD operations for the **Tipo_Procedimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_Procedimientos
    * const tipo_Procedimientos = await prisma.tipo_Procedimiento.findMany()
    * ```
    */
  get tipo_Procedimiento(): Prisma.Tipo_ProcedimientoDelegate<ExtArgs>;

  /**
   * `prisma.procedimiento`: Exposes CRUD operations for the **Procedimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedimientos
    * const procedimientos = await prisma.procedimiento.findMany()
    * ```
    */
  get procedimiento(): Prisma.ProcedimientoDelegate<ExtArgs>;

  /**
   * `prisma.estudio`: Exposes CRUD operations for the **Estudio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudios
    * const estudios = await prisma.estudio.findMany()
    * ```
    */
  get estudio(): Prisma.EstudioDelegate<ExtArgs>;

  /**
   * `prisma.departamento`: Exposes CRUD operations for the **Departamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departamentos
    * const departamentos = await prisma.departamento.findMany()
    * ```
    */
  get departamento(): Prisma.DepartamentoDelegate<ExtArgs>;

  /**
   * `prisma.municipio`: Exposes CRUD operations for the **Municipio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipios
    * const municipios = await prisma.municipio.findMany()
    * ```
    */
  get municipio(): Prisma.MunicipioDelegate<ExtArgs>;

  /**
   * `prisma.tipo_Servicio`: Exposes CRUD operations for the **Tipo_Servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_Servicios
    * const tipo_Servicios = await prisma.tipo_Servicio.findMany()
    * ```
    */
  get tipo_Servicio(): Prisma.Tipo_ServicioDelegate<ExtArgs>;

  /**
   * `prisma.servicio`: Exposes CRUD operations for the **Servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicio.findMany()
    * ```
    */
  get servicio(): Prisma.ServicioDelegate<ExtArgs>;

  /**
   * `prisma.examen`: Exposes CRUD operations for the **Examen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Examen
    * const examen = await prisma.examen.findMany()
    * ```
    */
  get examen(): Prisma.ExamenDelegate<ExtArgs>;

  /**
   * `prisma.tipo_Resultado`: Exposes CRUD operations for the **Tipo_Resultado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_Resultados
    * const tipo_Resultados = await prisma.tipo_Resultado.findMany()
    * ```
    */
  get tipo_Resultado(): Prisma.Tipo_ResultadoDelegate<ExtArgs>;

  /**
   * `prisma.tipo_Examen`: Exposes CRUD operations for the **Tipo_Examen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_Examen
    * const tipo_Examen = await prisma.tipo_Examen.findMany()
    * ```
    */
  get tipo_Examen(): Prisma.Tipo_ExamenDelegate<ExtArgs>;

  /**
   * `prisma.prestador`: Exposes CRUD operations for the **Prestador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prestadors
    * const prestadors = await prisma.prestador.findMany()
    * ```
    */
  get prestador(): Prisma.PrestadorDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **Empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.EmpresaDelegate<ExtArgs>;

  /**
   * `prisma.contrato`: Exposes CRUD operations for the **Contrato** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contratoes
    * const contratoes = await prisma.contrato.findMany()
    * ```
    */
  get contrato(): Prisma.ContratoDelegate<ExtArgs>;

  /**
   * `prisma.acuerdo`: Exposes CRUD operations for the **Acuerdo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Acuerdos
    * const acuerdos = await prisma.acuerdo.findMany()
    * ```
    */
  get acuerdo(): Prisma.AcuerdoDelegate<ExtArgs>;

  /**
   * `prisma.paquete`: Exposes CRUD operations for the **Paquete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paquetes
    * const paquetes = await prisma.paquete.findMany()
    * ```
    */
  get paquete(): Prisma.PaqueteDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Paciente: 'Paciente',
    Eps: 'Eps',
    Tipo_Procedimiento: 'Tipo_Procedimiento',
    Procedimiento: 'Procedimiento',
    Estudio: 'Estudio',
    Departamento: 'Departamento',
    Municipio: 'Municipio',
    Tipo_Servicio: 'Tipo_Servicio',
    Servicio: 'Servicio',
    Examen: 'Examen',
    Tipo_Resultado: 'Tipo_Resultado',
    Tipo_Examen: 'Tipo_Examen',
    Prestador: 'Prestador',
    Usuario: 'Usuario',
    Empresa: 'Empresa',
    Contrato: 'Contrato',
    Acuerdo: 'Acuerdo',
    Paquete: 'Paquete'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "paciente" | "eps" | "tipo_Procedimiento" | "procedimiento" | "estudio" | "departamento" | "municipio" | "tipo_Servicio" | "servicio" | "examen" | "tipo_Resultado" | "tipo_Examen" | "prestador" | "usuario" | "empresa" | "contrato" | "acuerdo" | "paquete"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Paciente: {
        payload: Prisma.$PacientePayload<ExtArgs>
        fields: Prisma.PacienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PacienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PacienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          findFirst: {
            args: Prisma.PacienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PacienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          findMany: {
            args: Prisma.PacienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>[]
          }
          create: {
            args: Prisma.PacienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          createMany: {
            args: Prisma.PacienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PacienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          update: {
            args: Prisma.PacienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          deleteMany: {
            args: Prisma.PacienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PacienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PacienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          aggregate: {
            args: Prisma.PacienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaciente>
          }
          groupBy: {
            args: Prisma.PacienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PacienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PacienteCountArgs<ExtArgs>
            result: $Utils.Optional<PacienteCountAggregateOutputType> | number
          }
        }
      }
      Eps: {
        payload: Prisma.$EpsPayload<ExtArgs>
        fields: Prisma.EpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EpsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EpsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          findFirst: {
            args: Prisma.EpsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EpsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          findMany: {
            args: Prisma.EpsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>[]
          }
          create: {
            args: Prisma.EpsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          createMany: {
            args: Prisma.EpsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EpsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          update: {
            args: Prisma.EpsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          deleteMany: {
            args: Prisma.EpsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EpsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EpsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          aggregate: {
            args: Prisma.EpsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEps>
          }
          groupBy: {
            args: Prisma.EpsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EpsCountArgs<ExtArgs>
            result: $Utils.Optional<EpsCountAggregateOutputType> | number
          }
        }
      }
      Tipo_Procedimiento: {
        payload: Prisma.$Tipo_ProcedimientoPayload<ExtArgs>
        fields: Prisma.Tipo_ProcedimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tipo_ProcedimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tipo_ProcedimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          findFirst: {
            args: Prisma.Tipo_ProcedimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tipo_ProcedimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          findMany: {
            args: Prisma.Tipo_ProcedimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>[]
          }
          create: {
            args: Prisma.Tipo_ProcedimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          createMany: {
            args: Prisma.Tipo_ProcedimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Tipo_ProcedimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          update: {
            args: Prisma.Tipo_ProcedimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          deleteMany: {
            args: Prisma.Tipo_ProcedimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tipo_ProcedimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Tipo_ProcedimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ProcedimientoPayload>
          }
          aggregate: {
            args: Prisma.Tipo_ProcedimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_Procedimiento>
          }
          groupBy: {
            args: Prisma.Tipo_ProcedimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ProcedimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tipo_ProcedimientoCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ProcedimientoCountAggregateOutputType> | number
          }
        }
      }
      Procedimiento: {
        payload: Prisma.$ProcedimientoPayload<ExtArgs>
        fields: Prisma.ProcedimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          findFirst: {
            args: Prisma.ProcedimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          findMany: {
            args: Prisma.ProcedimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>[]
          }
          create: {
            args: Prisma.ProcedimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          createMany: {
            args: Prisma.ProcedimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcedimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          update: {
            args: Prisma.ProcedimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          deleteMany: {
            args: Prisma.ProcedimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcedimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          aggregate: {
            args: Prisma.ProcedimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedimiento>
          }
          groupBy: {
            args: Prisma.ProcedimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedimientoCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedimientoCountAggregateOutputType> | number
          }
        }
      }
      Estudio: {
        payload: Prisma.$EstudioPayload<ExtArgs>
        fields: Prisma.EstudioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          findFirst: {
            args: Prisma.EstudioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          findMany: {
            args: Prisma.EstudioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>[]
          }
          create: {
            args: Prisma.EstudioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          createMany: {
            args: Prisma.EstudioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EstudioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          update: {
            args: Prisma.EstudioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          deleteMany: {
            args: Prisma.EstudioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EstudioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudioPayload>
          }
          aggregate: {
            args: Prisma.EstudioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudio>
          }
          groupBy: {
            args: Prisma.EstudioGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudioGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudioCountArgs<ExtArgs>
            result: $Utils.Optional<EstudioCountAggregateOutputType> | number
          }
        }
      }
      Departamento: {
        payload: Prisma.$DepartamentoPayload<ExtArgs>
        fields: Prisma.DepartamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          findFirst: {
            args: Prisma.DepartamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          findMany: {
            args: Prisma.DepartamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>[]
          }
          create: {
            args: Prisma.DepartamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          createMany: {
            args: Prisma.DepartamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          update: {
            args: Prisma.DepartamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          deleteMany: {
            args: Prisma.DepartamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          aggregate: {
            args: Prisma.DepartamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartamento>
          }
          groupBy: {
            args: Prisma.DepartamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartamentoCountArgs<ExtArgs>
            result: $Utils.Optional<DepartamentoCountAggregateOutputType> | number
          }
        }
      }
      Municipio: {
        payload: Prisma.$MunicipioPayload<ExtArgs>
        fields: Prisma.MunicipioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          findFirst: {
            args: Prisma.MunicipioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          findMany: {
            args: Prisma.MunicipioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>[]
          }
          create: {
            args: Prisma.MunicipioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          createMany: {
            args: Prisma.MunicipioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MunicipioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          update: {
            args: Prisma.MunicipioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          deleteMany: {
            args: Prisma.MunicipioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MunicipioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          aggregate: {
            args: Prisma.MunicipioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipio>
          }
          groupBy: {
            args: Prisma.MunicipioGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipioGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipioCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipioCountAggregateOutputType> | number
          }
        }
      }
      Tipo_Servicio: {
        payload: Prisma.$Tipo_ServicioPayload<ExtArgs>
        fields: Prisma.Tipo_ServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tipo_ServicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tipo_ServicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          findFirst: {
            args: Prisma.Tipo_ServicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tipo_ServicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          findMany: {
            args: Prisma.Tipo_ServicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>[]
          }
          create: {
            args: Prisma.Tipo_ServicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          createMany: {
            args: Prisma.Tipo_ServicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Tipo_ServicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          update: {
            args: Prisma.Tipo_ServicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          deleteMany: {
            args: Prisma.Tipo_ServicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tipo_ServicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Tipo_ServicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ServicioPayload>
          }
          aggregate: {
            args: Prisma.Tipo_ServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_Servicio>
          }
          groupBy: {
            args: Prisma.Tipo_ServicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tipo_ServicioCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ServicioCountAggregateOutputType> | number
          }
        }
      }
      Servicio: {
        payload: Prisma.$ServicioPayload<ExtArgs>
        fields: Prisma.ServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          findFirst: {
            args: Prisma.ServicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          findMany: {
            args: Prisma.ServicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>[]
          }
          create: {
            args: Prisma.ServicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          createMany: {
            args: Prisma.ServicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          update: {
            args: Prisma.ServicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          deleteMany: {
            args: Prisma.ServicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          aggregate: {
            args: Prisma.ServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicio>
          }
          groupBy: {
            args: Prisma.ServicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicioCountArgs<ExtArgs>
            result: $Utils.Optional<ServicioCountAggregateOutputType> | number
          }
        }
      }
      Examen: {
        payload: Prisma.$ExamenPayload<ExtArgs>
        fields: Prisma.ExamenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          findFirst: {
            args: Prisma.ExamenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          findMany: {
            args: Prisma.ExamenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>[]
          }
          create: {
            args: Prisma.ExamenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          createMany: {
            args: Prisma.ExamenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          update: {
            args: Prisma.ExamenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          deleteMany: {
            args: Prisma.ExamenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamenPayload>
          }
          aggregate: {
            args: Prisma.ExamenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamen>
          }
          groupBy: {
            args: Prisma.ExamenGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamenCountArgs<ExtArgs>
            result: $Utils.Optional<ExamenCountAggregateOutputType> | number
          }
        }
      }
      Tipo_Resultado: {
        payload: Prisma.$Tipo_ResultadoPayload<ExtArgs>
        fields: Prisma.Tipo_ResultadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tipo_ResultadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tipo_ResultadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          findFirst: {
            args: Prisma.Tipo_ResultadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tipo_ResultadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          findMany: {
            args: Prisma.Tipo_ResultadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>[]
          }
          create: {
            args: Prisma.Tipo_ResultadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          createMany: {
            args: Prisma.Tipo_ResultadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Tipo_ResultadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          update: {
            args: Prisma.Tipo_ResultadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          deleteMany: {
            args: Prisma.Tipo_ResultadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tipo_ResultadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Tipo_ResultadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ResultadoPayload>
          }
          aggregate: {
            args: Prisma.Tipo_ResultadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_Resultado>
          }
          groupBy: {
            args: Prisma.Tipo_ResultadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ResultadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tipo_ResultadoCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ResultadoCountAggregateOutputType> | number
          }
        }
      }
      Tipo_Examen: {
        payload: Prisma.$Tipo_ExamenPayload<ExtArgs>
        fields: Prisma.Tipo_ExamenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tipo_ExamenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tipo_ExamenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          findFirst: {
            args: Prisma.Tipo_ExamenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tipo_ExamenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          findMany: {
            args: Prisma.Tipo_ExamenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>[]
          }
          create: {
            args: Prisma.Tipo_ExamenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          createMany: {
            args: Prisma.Tipo_ExamenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Tipo_ExamenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          update: {
            args: Prisma.Tipo_ExamenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          deleteMany: {
            args: Prisma.Tipo_ExamenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tipo_ExamenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Tipo_ExamenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tipo_ExamenPayload>
          }
          aggregate: {
            args: Prisma.Tipo_ExamenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipo_Examen>
          }
          groupBy: {
            args: Prisma.Tipo_ExamenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ExamenGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tipo_ExamenCountArgs<ExtArgs>
            result: $Utils.Optional<Tipo_ExamenCountAggregateOutputType> | number
          }
        }
      }
      Prestador: {
        payload: Prisma.$PrestadorPayload<ExtArgs>
        fields: Prisma.PrestadorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrestadorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrestadorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          findFirst: {
            args: Prisma.PrestadorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrestadorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          findMany: {
            args: Prisma.PrestadorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>[]
          }
          create: {
            args: Prisma.PrestadorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          createMany: {
            args: Prisma.PrestadorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrestadorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          update: {
            args: Prisma.PrestadorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          deleteMany: {
            args: Prisma.PrestadorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrestadorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrestadorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          aggregate: {
            args: Prisma.PrestadorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrestador>
          }
          groupBy: {
            args: Prisma.PrestadorGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrestadorGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrestadorCountArgs<ExtArgs>
            result: $Utils.Optional<PrestadorCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Empresa: {
        payload: Prisma.$EmpresaPayload<ExtArgs>
        fields: Prisma.EmpresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findFirst: {
            args: Prisma.EmpresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findMany: {
            args: Prisma.EmpresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          create: {
            args: Prisma.EmpresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          createMany: {
            args: Prisma.EmpresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmpresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          update: {
            args: Prisma.EmpresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.EmpresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      Contrato: {
        payload: Prisma.$ContratoPayload<ExtArgs>
        fields: Prisma.ContratoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContratoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContratoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          findFirst: {
            args: Prisma.ContratoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContratoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          findMany: {
            args: Prisma.ContratoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>[]
          }
          create: {
            args: Prisma.ContratoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          createMany: {
            args: Prisma.ContratoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContratoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          update: {
            args: Prisma.ContratoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          deleteMany: {
            args: Prisma.ContratoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContratoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContratoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          aggregate: {
            args: Prisma.ContratoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContrato>
          }
          groupBy: {
            args: Prisma.ContratoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContratoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContratoCountArgs<ExtArgs>
            result: $Utils.Optional<ContratoCountAggregateOutputType> | number
          }
        }
      }
      Acuerdo: {
        payload: Prisma.$AcuerdoPayload<ExtArgs>
        fields: Prisma.AcuerdoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcuerdoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcuerdoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          findFirst: {
            args: Prisma.AcuerdoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcuerdoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          findMany: {
            args: Prisma.AcuerdoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>[]
          }
          create: {
            args: Prisma.AcuerdoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          createMany: {
            args: Prisma.AcuerdoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcuerdoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          update: {
            args: Prisma.AcuerdoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          deleteMany: {
            args: Prisma.AcuerdoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcuerdoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcuerdoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          aggregate: {
            args: Prisma.AcuerdoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcuerdo>
          }
          groupBy: {
            args: Prisma.AcuerdoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcuerdoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcuerdoCountArgs<ExtArgs>
            result: $Utils.Optional<AcuerdoCountAggregateOutputType> | number
          }
        }
      }
      Paquete: {
        payload: Prisma.$PaquetePayload<ExtArgs>
        fields: Prisma.PaqueteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaqueteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaqueteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload>
          }
          findFirst: {
            args: Prisma.PaqueteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaqueteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload>
          }
          findMany: {
            args: Prisma.PaqueteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload>[]
          }
          create: {
            args: Prisma.PaqueteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload>
          }
          createMany: {
            args: Prisma.PaqueteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaqueteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload>
          }
          update: {
            args: Prisma.PaqueteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload>
          }
          deleteMany: {
            args: Prisma.PaqueteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaqueteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaqueteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaquetePayload>
          }
          aggregate: {
            args: Prisma.PaqueteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaquete>
          }
          groupBy: {
            args: Prisma.PaqueteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaqueteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaqueteCountArgs<ExtArgs>
            result: $Utils.Optional<PaqueteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PacienteCountOutputType
   */

  export type PacienteCountOutputType = {
    procedimiento: number
  }

  export type PacienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | PacienteCountOutputTypeCountProcedimientoArgs
  }

  // Custom InputTypes
  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PacienteCountOutputType
     */
    select?: PacienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
  }


  /**
   * Count Type EpsCountOutputType
   */

  export type EpsCountOutputType = {
    paciente: number
  }

  export type EpsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | EpsCountOutputTypeCountPacienteArgs
  }

  // Custom InputTypes
  /**
   * EpsCountOutputType without action
   */
  export type EpsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EpsCountOutputType
     */
    select?: EpsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EpsCountOutputType without action
   */
  export type EpsCountOutputTypeCountPacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PacienteWhereInput
  }


  /**
   * Count Type Tipo_ProcedimientoCountOutputType
   */

  export type Tipo_ProcedimientoCountOutputType = {
    procedimiento: number
  }

  export type Tipo_ProcedimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Tipo_ProcedimientoCountOutputTypeCountProcedimientoArgs
  }

  // Custom InputTypes
  /**
   * Tipo_ProcedimientoCountOutputType without action
   */
  export type Tipo_ProcedimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_ProcedimientoCountOutputType
     */
    select?: Tipo_ProcedimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipo_ProcedimientoCountOutputType without action
   */
  export type Tipo_ProcedimientoCountOutputTypeCountProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
  }


  /**
   * Count Type ProcedimientoCountOutputType
   */

  export type ProcedimientoCountOutputType = {
    estudio: number
  }

  export type ProcedimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudio?: boolean | ProcedimientoCountOutputTypeCountEstudioArgs
  }

  // Custom InputTypes
  /**
   * ProcedimientoCountOutputType without action
   */
  export type ProcedimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedimientoCountOutputType
     */
    select?: ProcedimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcedimientoCountOutputType without action
   */
  export type ProcedimientoCountOutputTypeCountEstudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudioWhereInput
  }


  /**
   * Count Type DepartamentoCountOutputType
   */

  export type DepartamentoCountOutputType = {
    municipio: number
  }

  export type DepartamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | DepartamentoCountOutputTypeCountMunicipioArgs
  }

  // Custom InputTypes
  /**
   * DepartamentoCountOutputType without action
   */
  export type DepartamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartamentoCountOutputType
     */
    select?: DepartamentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartamentoCountOutputType without action
   */
  export type DepartamentoCountOutputTypeCountMunicipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipioWhereInput
  }


  /**
   * Count Type MunicipioCountOutputType
   */

  export type MunicipioCountOutputType = {
    paciente: number
    empresa: number
  }

  export type MunicipioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | MunicipioCountOutputTypeCountPacienteArgs
    empresa?: boolean | MunicipioCountOutputTypeCountEmpresaArgs
  }

  // Custom InputTypes
  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipioCountOutputType
     */
    select?: MunicipioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeCountPacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PacienteWhereInput
  }

  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeCountEmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
  }


  /**
   * Count Type Tipo_ServicioCountOutputType
   */

  export type Tipo_ServicioCountOutputType = {
    servicio: number
  }

  export type Tipo_ServicioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Tipo_ServicioCountOutputTypeCountServicioArgs
  }

  // Custom InputTypes
  /**
   * Tipo_ServicioCountOutputType without action
   */
  export type Tipo_ServicioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_ServicioCountOutputType
     */
    select?: Tipo_ServicioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipo_ServicioCountOutputType without action
   */
  export type Tipo_ServicioCountOutputTypeCountServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
  }


  /**
   * Count Type ServicioCountOutputType
   */

  export type ServicioCountOutputType = {
    paquete: number
    acuerdo: number
  }

  export type ServicioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | ServicioCountOutputTypeCountPaqueteArgs
    acuerdo?: boolean | ServicioCountOutputTypeCountAcuerdoArgs
  }

  // Custom InputTypes
  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioCountOutputType
     */
    select?: ServicioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountPaqueteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteWhereInput
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountAcuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcuerdoWhereInput
  }


  /**
   * Count Type ExamenCountOutputType
   */

  export type ExamenCountOutputType = {
    tipo_resultado: number
    paquete: number
  }

  export type ExamenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipo_resultado?: boolean | ExamenCountOutputTypeCountTipo_resultadoArgs
    paquete?: boolean | ExamenCountOutputTypeCountPaqueteArgs
  }

  // Custom InputTypes
  /**
   * ExamenCountOutputType without action
   */
  export type ExamenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenCountOutputType
     */
    select?: ExamenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamenCountOutputType without action
   */
  export type ExamenCountOutputTypeCountTipo_resultadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ResultadoWhereInput
  }

  /**
   * ExamenCountOutputType without action
   */
  export type ExamenCountOutputTypeCountPaqueteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteWhereInput
  }


  /**
   * Count Type Tipo_ExamenCountOutputType
   */

  export type Tipo_ExamenCountOutputType = {
    examen: number
  }

  export type Tipo_ExamenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examen?: boolean | Tipo_ExamenCountOutputTypeCountExamenArgs
  }

  // Custom InputTypes
  /**
   * Tipo_ExamenCountOutputType without action
   */
  export type Tipo_ExamenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_ExamenCountOutputType
     */
    select?: Tipo_ExamenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tipo_ExamenCountOutputType without action
   */
  export type Tipo_ExamenCountOutputTypeCountExamenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamenWhereInput
  }


  /**
   * Count Type PrestadorCountOutputType
   */

  export type PrestadorCountOutputType = {
    servicio: number
    usuario: number
  }

  export type PrestadorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | PrestadorCountOutputTypeCountServicioArgs
    usuario?: boolean | PrestadorCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes
  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorCountOutputType
     */
    select?: PrestadorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeCountServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
  }

  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * Count Type EmpresaCountOutputType
   */

  export type EmpresaCountOutputType = {
    contrato: number
  }

  export type EmpresaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contrato?: boolean | EmpresaCountOutputTypeCountContratoArgs
  }

  // Custom InputTypes
  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaCountOutputType
     */
    select?: EmpresaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountContratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratoWhereInput
  }


  /**
   * Count Type ContratoCountOutputType
   */

  export type ContratoCountOutputType = {
    acuerdo: number
  }

  export type ContratoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acuerdo?: boolean | ContratoCountOutputTypeCountAcuerdoArgs
  }

  // Custom InputTypes
  /**
   * ContratoCountOutputType without action
   */
  export type ContratoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratoCountOutputType
     */
    select?: ContratoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContratoCountOutputType without action
   */
  export type ContratoCountOutputTypeCountAcuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcuerdoWhereInput
  }


  /**
   * Count Type AcuerdoCountOutputType
   */

  export type AcuerdoCountOutputType = {
    procedimiento: number
  }

  export type AcuerdoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | AcuerdoCountOutputTypeCountProcedimientoArgs
  }

  // Custom InputTypes
  /**
   * AcuerdoCountOutputType without action
   */
  export type AcuerdoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcuerdoCountOutputType
     */
    select?: AcuerdoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcuerdoCountOutputType without action
   */
  export type AcuerdoCountOutputTypeCountProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
  }


  /**
   * Count Type PaqueteCountOutputType
   */

  export type PaqueteCountOutputType = {
    estudio: number
  }

  export type PaqueteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudio?: boolean | PaqueteCountOutputTypeCountEstudioArgs
  }

  // Custom InputTypes
  /**
   * PaqueteCountOutputType without action
   */
  export type PaqueteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteCountOutputType
     */
    select?: PaqueteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaqueteCountOutputType without action
   */
  export type PaqueteCountOutputTypeCountEstudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudioWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Paciente
   */

  export type AggregatePaciente = {
    _count: PacienteCountAggregateOutputType | null
    _avg: PacienteAvgAggregateOutputType | null
    _sum: PacienteSumAggregateOutputType | null
    _min: PacienteMinAggregateOutputType | null
    _max: PacienteMaxAggregateOutputType | null
  }

  export type PacienteAvgAggregateOutputType = {
    id_paciente: number | null
    municipioId: number | null
    epsId: number | null
  }

  export type PacienteSumAggregateOutputType = {
    id_paciente: number | null
    municipioId: number | null
    epsId: number | null
  }

  export type PacienteMinAggregateOutputType = {
    id_paciente: number | null
    tipo_identificacion: $Enums.Tipo_Ident | null
    identificacion: string | null
    primer_nombre: string | null
    segundo_nombre: string | null
    primer_apellido: string | null
    segundo_apellido: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sex | null
    email: string | null
    telefono: string | null
    direccion: string | null
    tipo_paciente: $Enums.Tipo_Paciente | null
    estado: $Enums.Estado | null
    municipioId: number | null
    epsId: number | null
  }

  export type PacienteMaxAggregateOutputType = {
    id_paciente: number | null
    tipo_identificacion: $Enums.Tipo_Ident | null
    identificacion: string | null
    primer_nombre: string | null
    segundo_nombre: string | null
    primer_apellido: string | null
    segundo_apellido: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sex | null
    email: string | null
    telefono: string | null
    direccion: string | null
    tipo_paciente: $Enums.Tipo_Paciente | null
    estado: $Enums.Estado | null
    municipioId: number | null
    epsId: number | null
  }

  export type PacienteCountAggregateOutputType = {
    id_paciente: number
    tipo_identificacion: number
    identificacion: number
    primer_nombre: number
    segundo_nombre: number
    primer_apellido: number
    segundo_apellido: number
    fecha_nacimiento: number
    sexo: number
    email: number
    telefono: number
    direccion: number
    tipo_paciente: number
    estado: number
    municipioId: number
    epsId: number
    _all: number
  }


  export type PacienteAvgAggregateInputType = {
    id_paciente?: true
    municipioId?: true
    epsId?: true
  }

  export type PacienteSumAggregateInputType = {
    id_paciente?: true
    municipioId?: true
    epsId?: true
  }

  export type PacienteMinAggregateInputType = {
    id_paciente?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    direccion?: true
    tipo_paciente?: true
    estado?: true
    municipioId?: true
    epsId?: true
  }

  export type PacienteMaxAggregateInputType = {
    id_paciente?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    direccion?: true
    tipo_paciente?: true
    estado?: true
    municipioId?: true
    epsId?: true
  }

  export type PacienteCountAggregateInputType = {
    id_paciente?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    direccion?: true
    tipo_paciente?: true
    estado?: true
    municipioId?: true
    epsId?: true
    _all?: true
  }

  export type PacienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paciente to aggregate.
     */
    where?: PacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pacientes to fetch.
     */
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pacientes
    **/
    _count?: true | PacienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PacienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PacienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PacienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PacienteMaxAggregateInputType
  }

  export type GetPacienteAggregateType<T extends PacienteAggregateArgs> = {
        [P in keyof T & keyof AggregatePaciente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaciente[P]>
      : GetScalarType<T[P], AggregatePaciente[P]>
  }




  export type PacienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PacienteWhereInput
    orderBy?: PacienteOrderByWithAggregationInput | PacienteOrderByWithAggregationInput[]
    by: PacienteScalarFieldEnum[] | PacienteScalarFieldEnum
    having?: PacienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PacienteCountAggregateInputType | true
    _avg?: PacienteAvgAggregateInputType
    _sum?: PacienteSumAggregateInputType
    _min?: PacienteMinAggregateInputType
    _max?: PacienteMaxAggregateInputType
  }

  export type PacienteGroupByOutputType = {
    id_paciente: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre: string | null
    primer_apellido: string
    segundo_apellido: string | null
    fecha_nacimiento: Date
    sexo: $Enums.Sex
    email: string
    telefono: string | null
    direccion: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado: $Enums.Estado
    municipioId: number
    epsId: number
    _count: PacienteCountAggregateOutputType | null
    _avg: PacienteAvgAggregateOutputType | null
    _sum: PacienteSumAggregateOutputType | null
    _min: PacienteMinAggregateOutputType | null
    _max: PacienteMaxAggregateOutputType | null
  }

  type GetPacienteGroupByPayload<T extends PacienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PacienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PacienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PacienteGroupByOutputType[P]>
            : GetScalarType<T[P], PacienteGroupByOutputType[P]>
        }
      >
    >


  export type PacienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    tipo_identificacion?: boolean
    identificacion?: boolean
    primer_nombre?: boolean
    segundo_nombre?: boolean
    primer_apellido?: boolean
    segundo_apellido?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    tipo_paciente?: boolean
    estado?: boolean
    municipioId?: boolean
    epsId?: boolean
    procedimiento?: boolean | Paciente$procedimientoArgs<ExtArgs>
    municipio?: boolean | MunicipioDefaultArgs<ExtArgs>
    eps?: boolean | EpsDefaultArgs<ExtArgs>
    _count?: boolean | PacienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paciente"]>


  export type PacienteSelectScalar = {
    id_paciente?: boolean
    tipo_identificacion?: boolean
    identificacion?: boolean
    primer_nombre?: boolean
    segundo_nombre?: boolean
    primer_apellido?: boolean
    segundo_apellido?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    tipo_paciente?: boolean
    estado?: boolean
    municipioId?: boolean
    epsId?: boolean
  }

  export type PacienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Paciente$procedimientoArgs<ExtArgs>
    municipio?: boolean | MunicipioDefaultArgs<ExtArgs>
    eps?: boolean | EpsDefaultArgs<ExtArgs>
    _count?: boolean | PacienteCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PacientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paciente"
    objects: {
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>[]
      municipio: Prisma.$MunicipioPayload<ExtArgs>
      eps: Prisma.$EpsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_paciente: number
      tipo_identificacion: $Enums.Tipo_Ident
      identificacion: string
      primer_nombre: string
      segundo_nombre: string | null
      primer_apellido: string
      segundo_apellido: string | null
      fecha_nacimiento: Date
      sexo: $Enums.Sex
      email: string
      telefono: string | null
      direccion: string | null
      tipo_paciente: $Enums.Tipo_Paciente
      estado: $Enums.Estado
      municipioId: number
      epsId: number
    }, ExtArgs["result"]["paciente"]>
    composites: {}
  }

  type PacienteGetPayload<S extends boolean | null | undefined | PacienteDefaultArgs> = $Result.GetResult<Prisma.$PacientePayload, S>

  type PacienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PacienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PacienteCountAggregateInputType | true
    }

  export interface PacienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paciente'], meta: { name: 'Paciente' } }
    /**
     * Find zero or one Paciente that matches the filter.
     * @param {PacienteFindUniqueArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PacienteFindUniqueArgs>(args: SelectSubset<T, PacienteFindUniqueArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Paciente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PacienteFindUniqueOrThrowArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PacienteFindUniqueOrThrowArgs>(args: SelectSubset<T, PacienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Paciente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteFindFirstArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PacienteFindFirstArgs>(args?: SelectSubset<T, PacienteFindFirstArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Paciente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteFindFirstOrThrowArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PacienteFindFirstOrThrowArgs>(args?: SelectSubset<T, PacienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pacientes
     * const pacientes = await prisma.paciente.findMany()
     * 
     * // Get first 10 Pacientes
     * const pacientes = await prisma.paciente.findMany({ take: 10 })
     * 
     * // Only select the `id_paciente`
     * const pacienteWithId_pacienteOnly = await prisma.paciente.findMany({ select: { id_paciente: true } })
     * 
     */
    findMany<T extends PacienteFindManyArgs>(args?: SelectSubset<T, PacienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Paciente.
     * @param {PacienteCreateArgs} args - Arguments to create a Paciente.
     * @example
     * // Create one Paciente
     * const Paciente = await prisma.paciente.create({
     *   data: {
     *     // ... data to create a Paciente
     *   }
     * })
     * 
     */
    create<T extends PacienteCreateArgs>(args: SelectSubset<T, PacienteCreateArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pacientes.
     * @param {PacienteCreateManyArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const paciente = await prisma.paciente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PacienteCreateManyArgs>(args?: SelectSubset<T, PacienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Paciente.
     * @param {PacienteDeleteArgs} args - Arguments to delete one Paciente.
     * @example
     * // Delete one Paciente
     * const Paciente = await prisma.paciente.delete({
     *   where: {
     *     // ... filter to delete one Paciente
     *   }
     * })
     * 
     */
    delete<T extends PacienteDeleteArgs>(args: SelectSubset<T, PacienteDeleteArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Paciente.
     * @param {PacienteUpdateArgs} args - Arguments to update one Paciente.
     * @example
     * // Update one Paciente
     * const paciente = await prisma.paciente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PacienteUpdateArgs>(args: SelectSubset<T, PacienteUpdateArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pacientes.
     * @param {PacienteDeleteManyArgs} args - Arguments to filter Pacientes to delete.
     * @example
     * // Delete a few Pacientes
     * const { count } = await prisma.paciente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PacienteDeleteManyArgs>(args?: SelectSubset<T, PacienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pacientes
     * const paciente = await prisma.paciente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PacienteUpdateManyArgs>(args: SelectSubset<T, PacienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paciente.
     * @param {PacienteUpsertArgs} args - Arguments to update or create a Paciente.
     * @example
     * // Update or create a Paciente
     * const paciente = await prisma.paciente.upsert({
     *   create: {
     *     // ... data to create a Paciente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paciente we want to update
     *   }
     * })
     */
    upsert<T extends PacienteUpsertArgs>(args: SelectSubset<T, PacienteUpsertArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteCountArgs} args - Arguments to filter Pacientes to count.
     * @example
     * // Count the number of Pacientes
     * const count = await prisma.paciente.count({
     *   where: {
     *     // ... the filter for the Pacientes we want to count
     *   }
     * })
    **/
    count<T extends PacienteCountArgs>(
      args?: Subset<T, PacienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PacienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PacienteAggregateArgs>(args: Subset<T, PacienteAggregateArgs>): Prisma.PrismaPromise<GetPacienteAggregateType<T>>

    /**
     * Group by Paciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PacienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PacienteGroupByArgs['orderBy'] }
        : { orderBy?: PacienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PacienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPacienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paciente model
   */
  readonly fields: PacienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paciente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PacienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedimiento<T extends Paciente$procedimientoArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$procedimientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany"> | Null>
    municipio<T extends MunicipioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipioDefaultArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    eps<T extends EpsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EpsDefaultArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paciente model
   */ 
  interface PacienteFieldRefs {
    readonly id_paciente: FieldRef<"Paciente", 'Int'>
    readonly tipo_identificacion: FieldRef<"Paciente", 'Tipo_Ident'>
    readonly identificacion: FieldRef<"Paciente", 'String'>
    readonly primer_nombre: FieldRef<"Paciente", 'String'>
    readonly segundo_nombre: FieldRef<"Paciente", 'String'>
    readonly primer_apellido: FieldRef<"Paciente", 'String'>
    readonly segundo_apellido: FieldRef<"Paciente", 'String'>
    readonly fecha_nacimiento: FieldRef<"Paciente", 'DateTime'>
    readonly sexo: FieldRef<"Paciente", 'Sex'>
    readonly email: FieldRef<"Paciente", 'String'>
    readonly telefono: FieldRef<"Paciente", 'String'>
    readonly direccion: FieldRef<"Paciente", 'String'>
    readonly tipo_paciente: FieldRef<"Paciente", 'Tipo_Paciente'>
    readonly estado: FieldRef<"Paciente", 'Estado'>
    readonly municipioId: FieldRef<"Paciente", 'Int'>
    readonly epsId: FieldRef<"Paciente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Paciente findUnique
   */
  export type PacienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Paciente to fetch.
     */
    where: PacienteWhereUniqueInput
  }

  /**
   * Paciente findUniqueOrThrow
   */
  export type PacienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Paciente to fetch.
     */
    where: PacienteWhereUniqueInput
  }

  /**
   * Paciente findFirst
   */
  export type PacienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Paciente to fetch.
     */
    where?: PacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pacientes to fetch.
     */
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pacientes.
     */
    cursor?: PacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pacientes.
     */
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Paciente findFirstOrThrow
   */
  export type PacienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Paciente to fetch.
     */
    where?: PacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pacientes to fetch.
     */
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pacientes.
     */
    cursor?: PacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pacientes.
     */
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Paciente findMany
   */
  export type PacienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Pacientes to fetch.
     */
    where?: PacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pacientes to fetch.
     */
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pacientes.
     */
    cursor?: PacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pacientes.
     */
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Paciente create
   */
  export type PacienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Paciente.
     */
    data: XOR<PacienteCreateInput, PacienteUncheckedCreateInput>
  }

  /**
   * Paciente createMany
   */
  export type PacienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pacientes.
     */
    data: PacienteCreateManyInput | PacienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paciente update
   */
  export type PacienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Paciente.
     */
    data: XOR<PacienteUpdateInput, PacienteUncheckedUpdateInput>
    /**
     * Choose, which Paciente to update.
     */
    where: PacienteWhereUniqueInput
  }

  /**
   * Paciente updateMany
   */
  export type PacienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pacientes.
     */
    data: XOR<PacienteUpdateManyMutationInput, PacienteUncheckedUpdateManyInput>
    /**
     * Filter which Pacientes to update
     */
    where?: PacienteWhereInput
  }

  /**
   * Paciente upsert
   */
  export type PacienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Paciente to update in case it exists.
     */
    where: PacienteWhereUniqueInput
    /**
     * In case the Paciente found by the `where` argument doesn't exist, create a new Paciente with this data.
     */
    create: XOR<PacienteCreateInput, PacienteUncheckedCreateInput>
    /**
     * In case the Paciente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PacienteUpdateInput, PacienteUncheckedUpdateInput>
  }

  /**
   * Paciente delete
   */
  export type PacienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter which Paciente to delete.
     */
    where: PacienteWhereUniqueInput
  }

  /**
   * Paciente deleteMany
   */
  export type PacienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pacientes to delete
     */
    where?: PacienteWhereInput
  }

  /**
   * Paciente.procedimiento
   */
  export type Paciente$procedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    cursor?: ProcedimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Paciente without action
   */
  export type PacienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
  }


  /**
   * Model Eps
   */

  export type AggregateEps = {
    _count: EpsCountAggregateOutputType | null
    _avg: EpsAvgAggregateOutputType | null
    _sum: EpsSumAggregateOutputType | null
    _min: EpsMinAggregateOutputType | null
    _max: EpsMaxAggregateOutputType | null
  }

  export type EpsAvgAggregateOutputType = {
    id_eps: number | null
  }

  export type EpsSumAggregateOutputType = {
    id_eps: number | null
  }

  export type EpsMinAggregateOutputType = {
    id_eps: number | null
    codigo: string | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type EpsMaxAggregateOutputType = {
    id_eps: number | null
    codigo: string | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type EpsCountAggregateOutputType = {
    id_eps: number
    codigo: number
    nombre: number
    estado: number
    _all: number
  }


  export type EpsAvgAggregateInputType = {
    id_eps?: true
  }

  export type EpsSumAggregateInputType = {
    id_eps?: true
  }

  export type EpsMinAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
  }

  export type EpsMaxAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
  }

  export type EpsCountAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type EpsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eps to aggregate.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eps
    **/
    _count?: true | EpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpsMaxAggregateInputType
  }

  export type GetEpsAggregateType<T extends EpsAggregateArgs> = {
        [P in keyof T & keyof AggregateEps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEps[P]>
      : GetScalarType<T[P], AggregateEps[P]>
  }




  export type EpsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpsWhereInput
    orderBy?: EpsOrderByWithAggregationInput | EpsOrderByWithAggregationInput[]
    by: EpsScalarFieldEnum[] | EpsScalarFieldEnum
    having?: EpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpsCountAggregateInputType | true
    _avg?: EpsAvgAggregateInputType
    _sum?: EpsSumAggregateInputType
    _min?: EpsMinAggregateInputType
    _max?: EpsMaxAggregateInputType
  }

  export type EpsGroupByOutputType = {
    id_eps: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
    _count: EpsCountAggregateOutputType | null
    _avg: EpsAvgAggregateOutputType | null
    _sum: EpsSumAggregateOutputType | null
    _min: EpsMinAggregateOutputType | null
    _max: EpsMaxAggregateOutputType | null
  }

  type GetEpsGroupByPayload<T extends EpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpsGroupByOutputType[P]>
            : GetScalarType<T[P], EpsGroupByOutputType[P]>
        }
      >
    >


  export type EpsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_eps?: boolean
    codigo?: boolean
    nombre?: boolean
    estado?: boolean
    paciente?: boolean | Eps$pacienteArgs<ExtArgs>
    _count?: boolean | EpsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eps"]>


  export type EpsSelectScalar = {
    id_eps?: boolean
    codigo?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type EpsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | Eps$pacienteArgs<ExtArgs>
    _count?: boolean | EpsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EpsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Eps"
    objects: {
      paciente: Prisma.$PacientePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_eps: number
      codigo: string
      nombre: string
      estado: $Enums.Estado
    }, ExtArgs["result"]["eps"]>
    composites: {}
  }

  type EpsGetPayload<S extends boolean | null | undefined | EpsDefaultArgs> = $Result.GetResult<Prisma.$EpsPayload, S>

  type EpsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EpsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EpsCountAggregateInputType | true
    }

  export interface EpsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Eps'], meta: { name: 'Eps' } }
    /**
     * Find zero or one Eps that matches the filter.
     * @param {EpsFindUniqueArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EpsFindUniqueArgs>(args: SelectSubset<T, EpsFindUniqueArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Eps that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EpsFindUniqueOrThrowArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EpsFindUniqueOrThrowArgs>(args: SelectSubset<T, EpsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Eps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindFirstArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EpsFindFirstArgs>(args?: SelectSubset<T, EpsFindFirstArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Eps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindFirstOrThrowArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EpsFindFirstOrThrowArgs>(args?: SelectSubset<T, EpsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eps
     * const eps = await prisma.eps.findMany()
     * 
     * // Get first 10 Eps
     * const eps = await prisma.eps.findMany({ take: 10 })
     * 
     * // Only select the `id_eps`
     * const epsWithId_epsOnly = await prisma.eps.findMany({ select: { id_eps: true } })
     * 
     */
    findMany<T extends EpsFindManyArgs>(args?: SelectSubset<T, EpsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Eps.
     * @param {EpsCreateArgs} args - Arguments to create a Eps.
     * @example
     * // Create one Eps
     * const Eps = await prisma.eps.create({
     *   data: {
     *     // ... data to create a Eps
     *   }
     * })
     * 
     */
    create<T extends EpsCreateArgs>(args: SelectSubset<T, EpsCreateArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eps.
     * @param {EpsCreateManyArgs} args - Arguments to create many Eps.
     * @example
     * // Create many Eps
     * const eps = await prisma.eps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EpsCreateManyArgs>(args?: SelectSubset<T, EpsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Eps.
     * @param {EpsDeleteArgs} args - Arguments to delete one Eps.
     * @example
     * // Delete one Eps
     * const Eps = await prisma.eps.delete({
     *   where: {
     *     // ... filter to delete one Eps
     *   }
     * })
     * 
     */
    delete<T extends EpsDeleteArgs>(args: SelectSubset<T, EpsDeleteArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Eps.
     * @param {EpsUpdateArgs} args - Arguments to update one Eps.
     * @example
     * // Update one Eps
     * const eps = await prisma.eps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EpsUpdateArgs>(args: SelectSubset<T, EpsUpdateArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eps.
     * @param {EpsDeleteManyArgs} args - Arguments to filter Eps to delete.
     * @example
     * // Delete a few Eps
     * const { count } = await prisma.eps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EpsDeleteManyArgs>(args?: SelectSubset<T, EpsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eps
     * const eps = await prisma.eps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EpsUpdateManyArgs>(args: SelectSubset<T, EpsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eps.
     * @param {EpsUpsertArgs} args - Arguments to update or create a Eps.
     * @example
     * // Update or create a Eps
     * const eps = await prisma.eps.upsert({
     *   create: {
     *     // ... data to create a Eps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eps we want to update
     *   }
     * })
     */
    upsert<T extends EpsUpsertArgs>(args: SelectSubset<T, EpsUpsertArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsCountArgs} args - Arguments to filter Eps to count.
     * @example
     * // Count the number of Eps
     * const count = await prisma.eps.count({
     *   where: {
     *     // ... the filter for the Eps we want to count
     *   }
     * })
    **/
    count<T extends EpsCountArgs>(
      args?: Subset<T, EpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpsAggregateArgs>(args: Subset<T, EpsAggregateArgs>): Prisma.PrismaPromise<GetEpsAggregateType<T>>

    /**
     * Group by Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EpsGroupByArgs['orderBy'] }
        : { orderBy?: EpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Eps model
   */
  readonly fields: EpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Eps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EpsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paciente<T extends Eps$pacienteArgs<ExtArgs> = {}>(args?: Subset<T, Eps$pacienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Eps model
   */ 
  interface EpsFieldRefs {
    readonly id_eps: FieldRef<"Eps", 'Int'>
    readonly codigo: FieldRef<"Eps", 'String'>
    readonly nombre: FieldRef<"Eps", 'String'>
    readonly estado: FieldRef<"Eps", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Eps findUnique
   */
  export type EpsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps findUniqueOrThrow
   */
  export type EpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps findFirst
   */
  export type EpsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eps.
     */
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps findFirstOrThrow
   */
  export type EpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eps.
     */
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps findMany
   */
  export type EpsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps create
   */
  export type EpsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The data needed to create a Eps.
     */
    data: XOR<EpsCreateInput, EpsUncheckedCreateInput>
  }

  /**
   * Eps createMany
   */
  export type EpsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eps.
     */
    data: EpsCreateManyInput | EpsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Eps update
   */
  export type EpsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The data needed to update a Eps.
     */
    data: XOR<EpsUpdateInput, EpsUncheckedUpdateInput>
    /**
     * Choose, which Eps to update.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps updateMany
   */
  export type EpsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eps.
     */
    data: XOR<EpsUpdateManyMutationInput, EpsUncheckedUpdateManyInput>
    /**
     * Filter which Eps to update
     */
    where?: EpsWhereInput
  }

  /**
   * Eps upsert
   */
  export type EpsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The filter to search for the Eps to update in case it exists.
     */
    where: EpsWhereUniqueInput
    /**
     * In case the Eps found by the `where` argument doesn't exist, create a new Eps with this data.
     */
    create: XOR<EpsCreateInput, EpsUncheckedCreateInput>
    /**
     * In case the Eps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EpsUpdateInput, EpsUncheckedUpdateInput>
  }

  /**
   * Eps delete
   */
  export type EpsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter which Eps to delete.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps deleteMany
   */
  export type EpsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eps to delete
     */
    where?: EpsWhereInput
  }

  /**
   * Eps.paciente
   */
  export type Eps$pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    where?: PacienteWhereInput
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    cursor?: PacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Eps without action
   */
  export type EpsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
  }


  /**
   * Model Tipo_Procedimiento
   */

  export type AggregateTipo_Procedimiento = {
    _count: Tipo_ProcedimientoCountAggregateOutputType | null
    _avg: Tipo_ProcedimientoAvgAggregateOutputType | null
    _sum: Tipo_ProcedimientoSumAggregateOutputType | null
    _min: Tipo_ProcedimientoMinAggregateOutputType | null
    _max: Tipo_ProcedimientoMaxAggregateOutputType | null
  }

  export type Tipo_ProcedimientoAvgAggregateOutputType = {
    id_tipo_procedimiento: number | null
  }

  export type Tipo_ProcedimientoSumAggregateOutputType = {
    id_tipo_procedimiento: number | null
  }

  export type Tipo_ProcedimientoMinAggregateOutputType = {
    id_tipo_procedimiento: number | null
    nombre: string | null
  }

  export type Tipo_ProcedimientoMaxAggregateOutputType = {
    id_tipo_procedimiento: number | null
    nombre: string | null
  }

  export type Tipo_ProcedimientoCountAggregateOutputType = {
    id_tipo_procedimiento: number
    nombre: number
    _all: number
  }


  export type Tipo_ProcedimientoAvgAggregateInputType = {
    id_tipo_procedimiento?: true
  }

  export type Tipo_ProcedimientoSumAggregateInputType = {
    id_tipo_procedimiento?: true
  }

  export type Tipo_ProcedimientoMinAggregateInputType = {
    id_tipo_procedimiento?: true
    nombre?: true
  }

  export type Tipo_ProcedimientoMaxAggregateInputType = {
    id_tipo_procedimiento?: true
    nombre?: true
  }

  export type Tipo_ProcedimientoCountAggregateInputType = {
    id_tipo_procedimiento?: true
    nombre?: true
    _all?: true
  }

  export type Tipo_ProcedimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Procedimiento to aggregate.
     */
    where?: Tipo_ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Procedimientos to fetch.
     */
    orderBy?: Tipo_ProcedimientoOrderByWithRelationInput | Tipo_ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tipo_ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipo_Procedimientos
    **/
    _count?: true | Tipo_ProcedimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_ProcedimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_ProcedimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_ProcedimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_ProcedimientoMaxAggregateInputType
  }

  export type GetTipo_ProcedimientoAggregateType<T extends Tipo_ProcedimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_Procedimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_Procedimiento[P]>
      : GetScalarType<T[P], AggregateTipo_Procedimiento[P]>
  }




  export type Tipo_ProcedimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ProcedimientoWhereInput
    orderBy?: Tipo_ProcedimientoOrderByWithAggregationInput | Tipo_ProcedimientoOrderByWithAggregationInput[]
    by: Tipo_ProcedimientoScalarFieldEnum[] | Tipo_ProcedimientoScalarFieldEnum
    having?: Tipo_ProcedimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_ProcedimientoCountAggregateInputType | true
    _avg?: Tipo_ProcedimientoAvgAggregateInputType
    _sum?: Tipo_ProcedimientoSumAggregateInputType
    _min?: Tipo_ProcedimientoMinAggregateInputType
    _max?: Tipo_ProcedimientoMaxAggregateInputType
  }

  export type Tipo_ProcedimientoGroupByOutputType = {
    id_tipo_procedimiento: number
    nombre: string
    _count: Tipo_ProcedimientoCountAggregateOutputType | null
    _avg: Tipo_ProcedimientoAvgAggregateOutputType | null
    _sum: Tipo_ProcedimientoSumAggregateOutputType | null
    _min: Tipo_ProcedimientoMinAggregateOutputType | null
    _max: Tipo_ProcedimientoMaxAggregateOutputType | null
  }

  type GetTipo_ProcedimientoGroupByPayload<T extends Tipo_ProcedimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_ProcedimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_ProcedimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_ProcedimientoGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_ProcedimientoGroupByOutputType[P]>
        }
      >
    >


  export type Tipo_ProcedimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_procedimiento?: boolean
    nombre?: boolean
    procedimiento?: boolean | Tipo_Procedimiento$procedimientoArgs<ExtArgs>
    _count?: boolean | Tipo_ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_Procedimiento"]>


  export type Tipo_ProcedimientoSelectScalar = {
    id_tipo_procedimiento?: boolean
    nombre?: boolean
  }

  export type Tipo_ProcedimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Tipo_Procedimiento$procedimientoArgs<ExtArgs>
    _count?: boolean | Tipo_ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Tipo_ProcedimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tipo_Procedimiento"
    objects: {
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_procedimiento: number
      nombre: string
    }, ExtArgs["result"]["tipo_Procedimiento"]>
    composites: {}
  }

  type Tipo_ProcedimientoGetPayload<S extends boolean | null | undefined | Tipo_ProcedimientoDefaultArgs> = $Result.GetResult<Prisma.$Tipo_ProcedimientoPayload, S>

  type Tipo_ProcedimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tipo_ProcedimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_ProcedimientoCountAggregateInputType | true
    }

  export interface Tipo_ProcedimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tipo_Procedimiento'], meta: { name: 'Tipo_Procedimiento' } }
    /**
     * Find zero or one Tipo_Procedimiento that matches the filter.
     * @param {Tipo_ProcedimientoFindUniqueArgs} args - Arguments to find a Tipo_Procedimiento
     * @example
     * // Get one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tipo_ProcedimientoFindUniqueArgs>(args: SelectSubset<T, Tipo_ProcedimientoFindUniqueArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_Procedimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Tipo_ProcedimientoFindUniqueOrThrowArgs} args - Arguments to find a Tipo_Procedimiento
     * @example
     * // Get one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tipo_ProcedimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, Tipo_ProcedimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_Procedimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoFindFirstArgs} args - Arguments to find a Tipo_Procedimiento
     * @example
     * // Get one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tipo_ProcedimientoFindFirstArgs>(args?: SelectSubset<T, Tipo_ProcedimientoFindFirstArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_Procedimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoFindFirstOrThrowArgs} args - Arguments to find a Tipo_Procedimiento
     * @example
     * // Get one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tipo_ProcedimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, Tipo_ProcedimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_Procedimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_Procedimientos
     * const tipo_Procedimientos = await prisma.tipo_Procedimiento.findMany()
     * 
     * // Get first 10 Tipo_Procedimientos
     * const tipo_Procedimientos = await prisma.tipo_Procedimiento.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_procedimiento`
     * const tipo_ProcedimientoWithId_tipo_procedimientoOnly = await prisma.tipo_Procedimiento.findMany({ select: { id_tipo_procedimiento: true } })
     * 
     */
    findMany<T extends Tipo_ProcedimientoFindManyArgs>(args?: SelectSubset<T, Tipo_ProcedimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_Procedimiento.
     * @param {Tipo_ProcedimientoCreateArgs} args - Arguments to create a Tipo_Procedimiento.
     * @example
     * // Create one Tipo_Procedimiento
     * const Tipo_Procedimiento = await prisma.tipo_Procedimiento.create({
     *   data: {
     *     // ... data to create a Tipo_Procedimiento
     *   }
     * })
     * 
     */
    create<T extends Tipo_ProcedimientoCreateArgs>(args: SelectSubset<T, Tipo_ProcedimientoCreateArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_Procedimientos.
     * @param {Tipo_ProcedimientoCreateManyArgs} args - Arguments to create many Tipo_Procedimientos.
     * @example
     * // Create many Tipo_Procedimientos
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tipo_ProcedimientoCreateManyArgs>(args?: SelectSubset<T, Tipo_ProcedimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_Procedimiento.
     * @param {Tipo_ProcedimientoDeleteArgs} args - Arguments to delete one Tipo_Procedimiento.
     * @example
     * // Delete one Tipo_Procedimiento
     * const Tipo_Procedimiento = await prisma.tipo_Procedimiento.delete({
     *   where: {
     *     // ... filter to delete one Tipo_Procedimiento
     *   }
     * })
     * 
     */
    delete<T extends Tipo_ProcedimientoDeleteArgs>(args: SelectSubset<T, Tipo_ProcedimientoDeleteArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_Procedimiento.
     * @param {Tipo_ProcedimientoUpdateArgs} args - Arguments to update one Tipo_Procedimiento.
     * @example
     * // Update one Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tipo_ProcedimientoUpdateArgs>(args: SelectSubset<T, Tipo_ProcedimientoUpdateArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_Procedimientos.
     * @param {Tipo_ProcedimientoDeleteManyArgs} args - Arguments to filter Tipo_Procedimientos to delete.
     * @example
     * // Delete a few Tipo_Procedimientos
     * const { count } = await prisma.tipo_Procedimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tipo_ProcedimientoDeleteManyArgs>(args?: SelectSubset<T, Tipo_ProcedimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_Procedimientos
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tipo_ProcedimientoUpdateManyArgs>(args: SelectSubset<T, Tipo_ProcedimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_Procedimiento.
     * @param {Tipo_ProcedimientoUpsertArgs} args - Arguments to update or create a Tipo_Procedimiento.
     * @example
     * // Update or create a Tipo_Procedimiento
     * const tipo_Procedimiento = await prisma.tipo_Procedimiento.upsert({
     *   create: {
     *     // ... data to create a Tipo_Procedimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_Procedimiento we want to update
     *   }
     * })
     */
    upsert<T extends Tipo_ProcedimientoUpsertArgs>(args: SelectSubset<T, Tipo_ProcedimientoUpsertArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoCountArgs} args - Arguments to filter Tipo_Procedimientos to count.
     * @example
     * // Count the number of Tipo_Procedimientos
     * const count = await prisma.tipo_Procedimiento.count({
     *   where: {
     *     // ... the filter for the Tipo_Procedimientos we want to count
     *   }
     * })
    **/
    count<T extends Tipo_ProcedimientoCountArgs>(
      args?: Subset<T, Tipo_ProcedimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_ProcedimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_ProcedimientoAggregateArgs>(args: Subset<T, Tipo_ProcedimientoAggregateArgs>): Prisma.PrismaPromise<GetTipo_ProcedimientoAggregateType<T>>

    /**
     * Group by Tipo_Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ProcedimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_ProcedimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_ProcedimientoGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_ProcedimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_ProcedimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_ProcedimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tipo_Procedimiento model
   */
  readonly fields: Tipo_ProcedimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo_Procedimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tipo_ProcedimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedimiento<T extends Tipo_Procedimiento$procedimientoArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_Procedimiento$procedimientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tipo_Procedimiento model
   */ 
  interface Tipo_ProcedimientoFieldRefs {
    readonly id_tipo_procedimiento: FieldRef<"Tipo_Procedimiento", 'Int'>
    readonly nombre: FieldRef<"Tipo_Procedimiento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tipo_Procedimiento findUnique
   */
  export type Tipo_ProcedimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimiento to fetch.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
  }

  /**
   * Tipo_Procedimiento findUniqueOrThrow
   */
  export type Tipo_ProcedimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimiento to fetch.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
  }

  /**
   * Tipo_Procedimiento findFirst
   */
  export type Tipo_ProcedimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimiento to fetch.
     */
    where?: Tipo_ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Procedimientos to fetch.
     */
    orderBy?: Tipo_ProcedimientoOrderByWithRelationInput | Tipo_ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Procedimientos.
     */
    cursor?: Tipo_ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Procedimientos.
     */
    distinct?: Tipo_ProcedimientoScalarFieldEnum | Tipo_ProcedimientoScalarFieldEnum[]
  }

  /**
   * Tipo_Procedimiento findFirstOrThrow
   */
  export type Tipo_ProcedimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimiento to fetch.
     */
    where?: Tipo_ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Procedimientos to fetch.
     */
    orderBy?: Tipo_ProcedimientoOrderByWithRelationInput | Tipo_ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Procedimientos.
     */
    cursor?: Tipo_ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Procedimientos.
     */
    distinct?: Tipo_ProcedimientoScalarFieldEnum | Tipo_ProcedimientoScalarFieldEnum[]
  }

  /**
   * Tipo_Procedimiento findMany
   */
  export type Tipo_ProcedimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Procedimientos to fetch.
     */
    where?: Tipo_ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Procedimientos to fetch.
     */
    orderBy?: Tipo_ProcedimientoOrderByWithRelationInput | Tipo_ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipo_Procedimientos.
     */
    cursor?: Tipo_ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Procedimientos.
     */
    skip?: number
    distinct?: Tipo_ProcedimientoScalarFieldEnum | Tipo_ProcedimientoScalarFieldEnum[]
  }

  /**
   * Tipo_Procedimiento create
   */
  export type Tipo_ProcedimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Tipo_Procedimiento.
     */
    data: XOR<Tipo_ProcedimientoCreateInput, Tipo_ProcedimientoUncheckedCreateInput>
  }

  /**
   * Tipo_Procedimiento createMany
   */
  export type Tipo_ProcedimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tipo_Procedimientos.
     */
    data: Tipo_ProcedimientoCreateManyInput | Tipo_ProcedimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tipo_Procedimiento update
   */
  export type Tipo_ProcedimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Tipo_Procedimiento.
     */
    data: XOR<Tipo_ProcedimientoUpdateInput, Tipo_ProcedimientoUncheckedUpdateInput>
    /**
     * Choose, which Tipo_Procedimiento to update.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
  }

  /**
   * Tipo_Procedimiento updateMany
   */
  export type Tipo_ProcedimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tipo_Procedimientos.
     */
    data: XOR<Tipo_ProcedimientoUpdateManyMutationInput, Tipo_ProcedimientoUncheckedUpdateManyInput>
    /**
     * Filter which Tipo_Procedimientos to update
     */
    where?: Tipo_ProcedimientoWhereInput
  }

  /**
   * Tipo_Procedimiento upsert
   */
  export type Tipo_ProcedimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Tipo_Procedimiento to update in case it exists.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
    /**
     * In case the Tipo_Procedimiento found by the `where` argument doesn't exist, create a new Tipo_Procedimiento with this data.
     */
    create: XOR<Tipo_ProcedimientoCreateInput, Tipo_ProcedimientoUncheckedCreateInput>
    /**
     * In case the Tipo_Procedimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tipo_ProcedimientoUpdateInput, Tipo_ProcedimientoUncheckedUpdateInput>
  }

  /**
   * Tipo_Procedimiento delete
   */
  export type Tipo_ProcedimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter which Tipo_Procedimiento to delete.
     */
    where: Tipo_ProcedimientoWhereUniqueInput
  }

  /**
   * Tipo_Procedimiento deleteMany
   */
  export type Tipo_ProcedimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Procedimientos to delete
     */
    where?: Tipo_ProcedimientoWhereInput
  }

  /**
   * Tipo_Procedimiento.procedimiento
   */
  export type Tipo_Procedimiento$procedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    cursor?: ProcedimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Tipo_Procedimiento without action
   */
  export type Tipo_ProcedimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Procedimiento
     */
    select?: Tipo_ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ProcedimientoInclude<ExtArgs> | null
  }


  /**
   * Model Procedimiento
   */

  export type AggregateProcedimiento = {
    _count: ProcedimientoCountAggregateOutputType | null
    _avg: ProcedimientoAvgAggregateOutputType | null
    _sum: ProcedimientoSumAggregateOutputType | null
    _min: ProcedimientoMinAggregateOutputType | null
    _max: ProcedimientoMaxAggregateOutputType | null
  }

  export type ProcedimientoAvgAggregateOutputType = {
    id_procedimiento: number | null
    factura: number | null
    acuerdoId: number | null
    tipo_procedimientoId: number | null
    pacienteId: number | null
  }

  export type ProcedimientoSumAggregateOutputType = {
    id_procedimiento: number | null
    factura: number | null
    acuerdoId: number | null
    tipo_procedimientoId: number | null
    pacienteId: number | null
  }

  export type ProcedimientoMinAggregateOutputType = {
    id_procedimiento: number | null
    factura: number | null
    fecha: Date | null
    edad_persona: string | null
    estado: $Enums.Estado | null
    createAt: Date | null
    updateAt: Date | null
    acuerdoId: number | null
    tipo_procedimientoId: number | null
    pacienteId: number | null
  }

  export type ProcedimientoMaxAggregateOutputType = {
    id_procedimiento: number | null
    factura: number | null
    fecha: Date | null
    edad_persona: string | null
    estado: $Enums.Estado | null
    createAt: Date | null
    updateAt: Date | null
    acuerdoId: number | null
    tipo_procedimientoId: number | null
    pacienteId: number | null
  }

  export type ProcedimientoCountAggregateOutputType = {
    id_procedimiento: number
    factura: number
    fecha: number
    edad_persona: number
    estado: number
    createAt: number
    updateAt: number
    acuerdoId: number
    tipo_procedimientoId: number
    pacienteId: number
    _all: number
  }


  export type ProcedimientoAvgAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    acuerdoId?: true
    tipo_procedimientoId?: true
    pacienteId?: true
  }

  export type ProcedimientoSumAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    acuerdoId?: true
    tipo_procedimientoId?: true
    pacienteId?: true
  }

  export type ProcedimientoMinAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    fecha?: true
    edad_persona?: true
    estado?: true
    createAt?: true
    updateAt?: true
    acuerdoId?: true
    tipo_procedimientoId?: true
    pacienteId?: true
  }

  export type ProcedimientoMaxAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    fecha?: true
    edad_persona?: true
    estado?: true
    createAt?: true
    updateAt?: true
    acuerdoId?: true
    tipo_procedimientoId?: true
    pacienteId?: true
  }

  export type ProcedimientoCountAggregateInputType = {
    id_procedimiento?: true
    factura?: true
    fecha?: true
    edad_persona?: true
    estado?: true
    createAt?: true
    updateAt?: true
    acuerdoId?: true
    tipo_procedimientoId?: true
    pacienteId?: true
    _all?: true
  }

  export type ProcedimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedimiento to aggregate.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procedimientos
    **/
    _count?: true | ProcedimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcedimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcedimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedimientoMaxAggregateInputType
  }

  export type GetProcedimientoAggregateType<T extends ProcedimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedimiento[P]>
      : GetScalarType<T[P], AggregateProcedimiento[P]>
  }




  export type ProcedimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithAggregationInput | ProcedimientoOrderByWithAggregationInput[]
    by: ProcedimientoScalarFieldEnum[] | ProcedimientoScalarFieldEnum
    having?: ProcedimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedimientoCountAggregateInputType | true
    _avg?: ProcedimientoAvgAggregateInputType
    _sum?: ProcedimientoSumAggregateInputType
    _min?: ProcedimientoMinAggregateInputType
    _max?: ProcedimientoMaxAggregateInputType
  }

  export type ProcedimientoGroupByOutputType = {
    id_procedimiento: number
    factura: number
    fecha: Date
    edad_persona: string
    estado: $Enums.Estado
    createAt: Date
    updateAt: Date
    acuerdoId: number
    tipo_procedimientoId: number
    pacienteId: number
    _count: ProcedimientoCountAggregateOutputType | null
    _avg: ProcedimientoAvgAggregateOutputType | null
    _sum: ProcedimientoSumAggregateOutputType | null
    _min: ProcedimientoMinAggregateOutputType | null
    _max: ProcedimientoMaxAggregateOutputType | null
  }

  type GetProcedimientoGroupByPayload<T extends ProcedimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedimientoGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedimientoGroupByOutputType[P]>
        }
      >
    >


  export type ProcedimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_procedimiento?: boolean
    factura?: boolean
    fecha?: boolean
    edad_persona?: boolean
    estado?: boolean
    createAt?: boolean
    updateAt?: boolean
    acuerdoId?: boolean
    tipo_procedimientoId?: boolean
    pacienteId?: boolean
    estudio?: boolean | Procedimiento$estudioArgs<ExtArgs>
    acuerdo?: boolean | AcuerdoDefaultArgs<ExtArgs>
    tipo_procedimiento?: boolean | Tipo_ProcedimientoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    _count?: boolean | ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedimiento"]>


  export type ProcedimientoSelectScalar = {
    id_procedimiento?: boolean
    factura?: boolean
    fecha?: boolean
    edad_persona?: boolean
    estado?: boolean
    createAt?: boolean
    updateAt?: boolean
    acuerdoId?: boolean
    tipo_procedimientoId?: boolean
    pacienteId?: boolean
  }

  export type ProcedimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudio?: boolean | Procedimiento$estudioArgs<ExtArgs>
    acuerdo?: boolean | AcuerdoDefaultArgs<ExtArgs>
    tipo_procedimiento?: boolean | Tipo_ProcedimientoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    _count?: boolean | ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProcedimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Procedimiento"
    objects: {
      estudio: Prisma.$EstudioPayload<ExtArgs>[]
      acuerdo: Prisma.$AcuerdoPayload<ExtArgs>
      tipo_procedimiento: Prisma.$Tipo_ProcedimientoPayload<ExtArgs>
      paciente: Prisma.$PacientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_procedimiento: number
      factura: number
      fecha: Date
      edad_persona: string
      estado: $Enums.Estado
      createAt: Date
      updateAt: Date
      acuerdoId: number
      tipo_procedimientoId: number
      pacienteId: number
    }, ExtArgs["result"]["procedimiento"]>
    composites: {}
  }

  type ProcedimientoGetPayload<S extends boolean | null | undefined | ProcedimientoDefaultArgs> = $Result.GetResult<Prisma.$ProcedimientoPayload, S>

  type ProcedimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcedimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcedimientoCountAggregateInputType | true
    }

  export interface ProcedimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Procedimiento'], meta: { name: 'Procedimiento' } }
    /**
     * Find zero or one Procedimiento that matches the filter.
     * @param {ProcedimientoFindUniqueArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedimientoFindUniqueArgs>(args: SelectSubset<T, ProcedimientoFindUniqueArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Procedimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcedimientoFindUniqueOrThrowArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Procedimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindFirstArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedimientoFindFirstArgs>(args?: SelectSubset<T, ProcedimientoFindFirstArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Procedimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindFirstOrThrowArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procedimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedimientos
     * const procedimientos = await prisma.procedimiento.findMany()
     * 
     * // Get first 10 Procedimientos
     * const procedimientos = await prisma.procedimiento.findMany({ take: 10 })
     * 
     * // Only select the `id_procedimiento`
     * const procedimientoWithId_procedimientoOnly = await prisma.procedimiento.findMany({ select: { id_procedimiento: true } })
     * 
     */
    findMany<T extends ProcedimientoFindManyArgs>(args?: SelectSubset<T, ProcedimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Procedimiento.
     * @param {ProcedimientoCreateArgs} args - Arguments to create a Procedimiento.
     * @example
     * // Create one Procedimiento
     * const Procedimiento = await prisma.procedimiento.create({
     *   data: {
     *     // ... data to create a Procedimiento
     *   }
     * })
     * 
     */
    create<T extends ProcedimientoCreateArgs>(args: SelectSubset<T, ProcedimientoCreateArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procedimientos.
     * @param {ProcedimientoCreateManyArgs} args - Arguments to create many Procedimientos.
     * @example
     * // Create many Procedimientos
     * const procedimiento = await prisma.procedimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedimientoCreateManyArgs>(args?: SelectSubset<T, ProcedimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Procedimiento.
     * @param {ProcedimientoDeleteArgs} args - Arguments to delete one Procedimiento.
     * @example
     * // Delete one Procedimiento
     * const Procedimiento = await prisma.procedimiento.delete({
     *   where: {
     *     // ... filter to delete one Procedimiento
     *   }
     * })
     * 
     */
    delete<T extends ProcedimientoDeleteArgs>(args: SelectSubset<T, ProcedimientoDeleteArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Procedimiento.
     * @param {ProcedimientoUpdateArgs} args - Arguments to update one Procedimiento.
     * @example
     * // Update one Procedimiento
     * const procedimiento = await prisma.procedimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedimientoUpdateArgs>(args: SelectSubset<T, ProcedimientoUpdateArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procedimientos.
     * @param {ProcedimientoDeleteManyArgs} args - Arguments to filter Procedimientos to delete.
     * @example
     * // Delete a few Procedimientos
     * const { count } = await prisma.procedimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedimientoDeleteManyArgs>(args?: SelectSubset<T, ProcedimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedimientos
     * const procedimiento = await prisma.procedimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedimientoUpdateManyArgs>(args: SelectSubset<T, ProcedimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Procedimiento.
     * @param {ProcedimientoUpsertArgs} args - Arguments to update or create a Procedimiento.
     * @example
     * // Update or create a Procedimiento
     * const procedimiento = await prisma.procedimiento.upsert({
     *   create: {
     *     // ... data to create a Procedimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedimiento we want to update
     *   }
     * })
     */
    upsert<T extends ProcedimientoUpsertArgs>(args: SelectSubset<T, ProcedimientoUpsertArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoCountArgs} args - Arguments to filter Procedimientos to count.
     * @example
     * // Count the number of Procedimientos
     * const count = await prisma.procedimiento.count({
     *   where: {
     *     // ... the filter for the Procedimientos we want to count
     *   }
     * })
    **/
    count<T extends ProcedimientoCountArgs>(
      args?: Subset<T, ProcedimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedimientoAggregateArgs>(args: Subset<T, ProcedimientoAggregateArgs>): Prisma.PrismaPromise<GetProcedimientoAggregateType<T>>

    /**
     * Group by Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedimientoGroupByArgs['orderBy'] }
        : { orderBy?: ProcedimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Procedimiento model
   */
  readonly fields: ProcedimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Procedimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudio<T extends Procedimiento$estudioArgs<ExtArgs> = {}>(args?: Subset<T, Procedimiento$estudioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findMany"> | Null>
    acuerdo<T extends AcuerdoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcuerdoDefaultArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tipo_procedimiento<T extends Tipo_ProcedimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_ProcedimientoDefaultArgs<ExtArgs>>): Prisma__Tipo_ProcedimientoClient<$Result.GetResult<Prisma.$Tipo_ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paciente<T extends PacienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PacienteDefaultArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Procedimiento model
   */ 
  interface ProcedimientoFieldRefs {
    readonly id_procedimiento: FieldRef<"Procedimiento", 'Int'>
    readonly factura: FieldRef<"Procedimiento", 'Int'>
    readonly fecha: FieldRef<"Procedimiento", 'DateTime'>
    readonly edad_persona: FieldRef<"Procedimiento", 'String'>
    readonly estado: FieldRef<"Procedimiento", 'Estado'>
    readonly createAt: FieldRef<"Procedimiento", 'DateTime'>
    readonly updateAt: FieldRef<"Procedimiento", 'DateTime'>
    readonly acuerdoId: FieldRef<"Procedimiento", 'Int'>
    readonly tipo_procedimientoId: FieldRef<"Procedimiento", 'Int'>
    readonly pacienteId: FieldRef<"Procedimiento", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Procedimiento findUnique
   */
  export type ProcedimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento findUniqueOrThrow
   */
  export type ProcedimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento findFirst
   */
  export type ProcedimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedimientos.
     */
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento findFirstOrThrow
   */
  export type ProcedimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedimientos.
     */
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento findMany
   */
  export type ProcedimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimientos to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento create
   */
  export type ProcedimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Procedimiento.
     */
    data: XOR<ProcedimientoCreateInput, ProcedimientoUncheckedCreateInput>
  }

  /**
   * Procedimiento createMany
   */
  export type ProcedimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procedimientos.
     */
    data: ProcedimientoCreateManyInput | ProcedimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedimiento update
   */
  export type ProcedimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Procedimiento.
     */
    data: XOR<ProcedimientoUpdateInput, ProcedimientoUncheckedUpdateInput>
    /**
     * Choose, which Procedimiento to update.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento updateMany
   */
  export type ProcedimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procedimientos.
     */
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyInput>
    /**
     * Filter which Procedimientos to update
     */
    where?: ProcedimientoWhereInput
  }

  /**
   * Procedimiento upsert
   */
  export type ProcedimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Procedimiento to update in case it exists.
     */
    where: ProcedimientoWhereUniqueInput
    /**
     * In case the Procedimiento found by the `where` argument doesn't exist, create a new Procedimiento with this data.
     */
    create: XOR<ProcedimientoCreateInput, ProcedimientoUncheckedCreateInput>
    /**
     * In case the Procedimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedimientoUpdateInput, ProcedimientoUncheckedUpdateInput>
  }

  /**
   * Procedimiento delete
   */
  export type ProcedimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter which Procedimiento to delete.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento deleteMany
   */
  export type ProcedimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedimientos to delete
     */
    where?: ProcedimientoWhereInput
  }

  /**
   * Procedimiento.estudio
   */
  export type Procedimiento$estudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    where?: EstudioWhereInput
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    cursor?: EstudioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Procedimiento without action
   */
  export type ProcedimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
  }


  /**
   * Model Estudio
   */

  export type AggregateEstudio = {
    _count: EstudioCountAggregateOutputType | null
    _avg: EstudioAvgAggregateOutputType | null
    _sum: EstudioSumAggregateOutputType | null
    _min: EstudioMinAggregateOutputType | null
    _max: EstudioMaxAggregateOutputType | null
  }

  export type EstudioAvgAggregateOutputType = {
    id_estudio: number | null
    consecutivo: number | null
    cantidad: number | null
    profesional: number | null
    paqueteId: number | null
    procedimientoId: number | null
  }

  export type EstudioSumAggregateOutputType = {
    id_estudio: number | null
    consecutivo: number | null
    cantidad: number | null
    profesional: number | null
    paqueteId: number | null
    procedimientoId: number | null
  }

  export type EstudioMinAggregateOutputType = {
    id_estudio: number | null
    consecutivo: number | null
    cantidad: number | null
    fecha_muestra: Date | null
    fecha_resultado: Date | null
    resultado: string | null
    observacion: string | null
    profesional: number | null
    paqueteId: number | null
    procedimientoId: number | null
  }

  export type EstudioMaxAggregateOutputType = {
    id_estudio: number | null
    consecutivo: number | null
    cantidad: number | null
    fecha_muestra: Date | null
    fecha_resultado: Date | null
    resultado: string | null
    observacion: string | null
    profesional: number | null
    paqueteId: number | null
    procedimientoId: number | null
  }

  export type EstudioCountAggregateOutputType = {
    id_estudio: number
    consecutivo: number
    cantidad: number
    fecha_muestra: number
    fecha_resultado: number
    resultado: number
    observacion: number
    profesional: number
    paqueteId: number
    procedimientoId: number
    _all: number
  }


  export type EstudioAvgAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    profesional?: true
    paqueteId?: true
    procedimientoId?: true
  }

  export type EstudioSumAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    profesional?: true
    paqueteId?: true
    procedimientoId?: true
  }

  export type EstudioMinAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    fecha_muestra?: true
    fecha_resultado?: true
    resultado?: true
    observacion?: true
    profesional?: true
    paqueteId?: true
    procedimientoId?: true
  }

  export type EstudioMaxAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    fecha_muestra?: true
    fecha_resultado?: true
    resultado?: true
    observacion?: true
    profesional?: true
    paqueteId?: true
    procedimientoId?: true
  }

  export type EstudioCountAggregateInputType = {
    id_estudio?: true
    consecutivo?: true
    cantidad?: true
    fecha_muestra?: true
    fecha_resultado?: true
    resultado?: true
    observacion?: true
    profesional?: true
    paqueteId?: true
    procedimientoId?: true
    _all?: true
  }

  export type EstudioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudio to aggregate.
     */
    where?: EstudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudios to fetch.
     */
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estudios
    **/
    _count?: true | EstudioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudioMaxAggregateInputType
  }

  export type GetEstudioAggregateType<T extends EstudioAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudio[P]>
      : GetScalarType<T[P], AggregateEstudio[P]>
  }




  export type EstudioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudioWhereInput
    orderBy?: EstudioOrderByWithAggregationInput | EstudioOrderByWithAggregationInput[]
    by: EstudioScalarFieldEnum[] | EstudioScalarFieldEnum
    having?: EstudioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudioCountAggregateInputType | true
    _avg?: EstudioAvgAggregateInputType
    _sum?: EstudioSumAggregateInputType
    _min?: EstudioMinAggregateInputType
    _max?: EstudioMaxAggregateInputType
  }

  export type EstudioGroupByOutputType = {
    id_estudio: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date
    fecha_resultado: Date
    resultado: string
    observacion: string
    profesional: number
    paqueteId: number
    procedimientoId: number
    _count: EstudioCountAggregateOutputType | null
    _avg: EstudioAvgAggregateOutputType | null
    _sum: EstudioSumAggregateOutputType | null
    _min: EstudioMinAggregateOutputType | null
    _max: EstudioMaxAggregateOutputType | null
  }

  type GetEstudioGroupByPayload<T extends EstudioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudioGroupByOutputType[P]>
            : GetScalarType<T[P], EstudioGroupByOutputType[P]>
        }
      >
    >


  export type EstudioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_estudio?: boolean
    consecutivo?: boolean
    cantidad?: boolean
    fecha_muestra?: boolean
    fecha_resultado?: boolean
    resultado?: boolean
    observacion?: boolean
    profesional?: boolean
    paqueteId?: boolean
    procedimientoId?: boolean
    paquete?: boolean | PaqueteDefaultArgs<ExtArgs>
    procedimiento?: boolean | ProcedimientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudio"]>


  export type EstudioSelectScalar = {
    id_estudio?: boolean
    consecutivo?: boolean
    cantidad?: boolean
    fecha_muestra?: boolean
    fecha_resultado?: boolean
    resultado?: boolean
    observacion?: boolean
    profesional?: boolean
    paqueteId?: boolean
    procedimientoId?: boolean
  }

  export type EstudioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | PaqueteDefaultArgs<ExtArgs>
    procedimiento?: boolean | ProcedimientoDefaultArgs<ExtArgs>
  }

  export type $EstudioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estudio"
    objects: {
      paquete: Prisma.$PaquetePayload<ExtArgs>
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_estudio: number
      consecutivo: number
      cantidad: number
      fecha_muestra: Date
      fecha_resultado: Date
      resultado: string
      observacion: string
      profesional: number
      paqueteId: number
      procedimientoId: number
    }, ExtArgs["result"]["estudio"]>
    composites: {}
  }

  type EstudioGetPayload<S extends boolean | null | undefined | EstudioDefaultArgs> = $Result.GetResult<Prisma.$EstudioPayload, S>

  type EstudioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstudioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstudioCountAggregateInputType | true
    }

  export interface EstudioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estudio'], meta: { name: 'Estudio' } }
    /**
     * Find zero or one Estudio that matches the filter.
     * @param {EstudioFindUniqueArgs} args - Arguments to find a Estudio
     * @example
     * // Get one Estudio
     * const estudio = await prisma.estudio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudioFindUniqueArgs>(args: SelectSubset<T, EstudioFindUniqueArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Estudio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EstudioFindUniqueOrThrowArgs} args - Arguments to find a Estudio
     * @example
     * // Get one Estudio
     * const estudio = await prisma.estudio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudioFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Estudio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioFindFirstArgs} args - Arguments to find a Estudio
     * @example
     * // Get one Estudio
     * const estudio = await prisma.estudio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudioFindFirstArgs>(args?: SelectSubset<T, EstudioFindFirstArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Estudio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioFindFirstOrThrowArgs} args - Arguments to find a Estudio
     * @example
     * // Get one Estudio
     * const estudio = await prisma.estudio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudioFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudioFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Estudios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudios
     * const estudios = await prisma.estudio.findMany()
     * 
     * // Get first 10 Estudios
     * const estudios = await prisma.estudio.findMany({ take: 10 })
     * 
     * // Only select the `id_estudio`
     * const estudioWithId_estudioOnly = await prisma.estudio.findMany({ select: { id_estudio: true } })
     * 
     */
    findMany<T extends EstudioFindManyArgs>(args?: SelectSubset<T, EstudioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Estudio.
     * @param {EstudioCreateArgs} args - Arguments to create a Estudio.
     * @example
     * // Create one Estudio
     * const Estudio = await prisma.estudio.create({
     *   data: {
     *     // ... data to create a Estudio
     *   }
     * })
     * 
     */
    create<T extends EstudioCreateArgs>(args: SelectSubset<T, EstudioCreateArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Estudios.
     * @param {EstudioCreateManyArgs} args - Arguments to create many Estudios.
     * @example
     * // Create many Estudios
     * const estudio = await prisma.estudio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudioCreateManyArgs>(args?: SelectSubset<T, EstudioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estudio.
     * @param {EstudioDeleteArgs} args - Arguments to delete one Estudio.
     * @example
     * // Delete one Estudio
     * const Estudio = await prisma.estudio.delete({
     *   where: {
     *     // ... filter to delete one Estudio
     *   }
     * })
     * 
     */
    delete<T extends EstudioDeleteArgs>(args: SelectSubset<T, EstudioDeleteArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Estudio.
     * @param {EstudioUpdateArgs} args - Arguments to update one Estudio.
     * @example
     * // Update one Estudio
     * const estudio = await prisma.estudio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudioUpdateArgs>(args: SelectSubset<T, EstudioUpdateArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Estudios.
     * @param {EstudioDeleteManyArgs} args - Arguments to filter Estudios to delete.
     * @example
     * // Delete a few Estudios
     * const { count } = await prisma.estudio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudioDeleteManyArgs>(args?: SelectSubset<T, EstudioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudios
     * const estudio = await prisma.estudio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudioUpdateManyArgs>(args: SelectSubset<T, EstudioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estudio.
     * @param {EstudioUpsertArgs} args - Arguments to update or create a Estudio.
     * @example
     * // Update or create a Estudio
     * const estudio = await prisma.estudio.upsert({
     *   create: {
     *     // ... data to create a Estudio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudio we want to update
     *   }
     * })
     */
    upsert<T extends EstudioUpsertArgs>(args: SelectSubset<T, EstudioUpsertArgs<ExtArgs>>): Prisma__EstudioClient<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Estudios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioCountArgs} args - Arguments to filter Estudios to count.
     * @example
     * // Count the number of Estudios
     * const count = await prisma.estudio.count({
     *   where: {
     *     // ... the filter for the Estudios we want to count
     *   }
     * })
    **/
    count<T extends EstudioCountArgs>(
      args?: Subset<T, EstudioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudioAggregateArgs>(args: Subset<T, EstudioAggregateArgs>): Prisma.PrismaPromise<GetEstudioAggregateType<T>>

    /**
     * Group by Estudio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudioGroupByArgs['orderBy'] }
        : { orderBy?: EstudioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estudio model
   */
  readonly fields: EstudioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estudio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paquete<T extends PaqueteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaqueteDefaultArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    procedimiento<T extends ProcedimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcedimientoDefaultArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estudio model
   */ 
  interface EstudioFieldRefs {
    readonly id_estudio: FieldRef<"Estudio", 'Int'>
    readonly consecutivo: FieldRef<"Estudio", 'Int'>
    readonly cantidad: FieldRef<"Estudio", 'Int'>
    readonly fecha_muestra: FieldRef<"Estudio", 'DateTime'>
    readonly fecha_resultado: FieldRef<"Estudio", 'DateTime'>
    readonly resultado: FieldRef<"Estudio", 'String'>
    readonly observacion: FieldRef<"Estudio", 'String'>
    readonly profesional: FieldRef<"Estudio", 'Int'>
    readonly paqueteId: FieldRef<"Estudio", 'Int'>
    readonly procedimientoId: FieldRef<"Estudio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Estudio findUnique
   */
  export type EstudioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudio to fetch.
     */
    where: EstudioWhereUniqueInput
  }

  /**
   * Estudio findUniqueOrThrow
   */
  export type EstudioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudio to fetch.
     */
    where: EstudioWhereUniqueInput
  }

  /**
   * Estudio findFirst
   */
  export type EstudioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudio to fetch.
     */
    where?: EstudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudios to fetch.
     */
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudios.
     */
    cursor?: EstudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudios.
     */
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Estudio findFirstOrThrow
   */
  export type EstudioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudio to fetch.
     */
    where?: EstudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudios to fetch.
     */
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudios.
     */
    cursor?: EstudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudios.
     */
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Estudio findMany
   */
  export type EstudioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter, which Estudios to fetch.
     */
    where?: EstudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudios to fetch.
     */
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estudios.
     */
    cursor?: EstudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudios.
     */
    skip?: number
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Estudio create
   */
  export type EstudioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * The data needed to create a Estudio.
     */
    data: XOR<EstudioCreateInput, EstudioUncheckedCreateInput>
  }

  /**
   * Estudio createMany
   */
  export type EstudioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estudios.
     */
    data: EstudioCreateManyInput | EstudioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estudio update
   */
  export type EstudioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * The data needed to update a Estudio.
     */
    data: XOR<EstudioUpdateInput, EstudioUncheckedUpdateInput>
    /**
     * Choose, which Estudio to update.
     */
    where: EstudioWhereUniqueInput
  }

  /**
   * Estudio updateMany
   */
  export type EstudioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estudios.
     */
    data: XOR<EstudioUpdateManyMutationInput, EstudioUncheckedUpdateManyInput>
    /**
     * Filter which Estudios to update
     */
    where?: EstudioWhereInput
  }

  /**
   * Estudio upsert
   */
  export type EstudioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * The filter to search for the Estudio to update in case it exists.
     */
    where: EstudioWhereUniqueInput
    /**
     * In case the Estudio found by the `where` argument doesn't exist, create a new Estudio with this data.
     */
    create: XOR<EstudioCreateInput, EstudioUncheckedCreateInput>
    /**
     * In case the Estudio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudioUpdateInput, EstudioUncheckedUpdateInput>
  }

  /**
   * Estudio delete
   */
  export type EstudioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    /**
     * Filter which Estudio to delete.
     */
    where: EstudioWhereUniqueInput
  }

  /**
   * Estudio deleteMany
   */
  export type EstudioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudios to delete
     */
    where?: EstudioWhereInput
  }

  /**
   * Estudio without action
   */
  export type EstudioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
  }


  /**
   * Model Departamento
   */

  export type AggregateDepartamento = {
    _count: DepartamentoCountAggregateOutputType | null
    _avg: DepartamentoAvgAggregateOutputType | null
    _sum: DepartamentoSumAggregateOutputType | null
    _min: DepartamentoMinAggregateOutputType | null
    _max: DepartamentoMaxAggregateOutputType | null
  }

  export type DepartamentoAvgAggregateOutputType = {
    id_departamento: number | null
  }

  export type DepartamentoSumAggregateOutputType = {
    id_departamento: number | null
  }

  export type DepartamentoMinAggregateOutputType = {
    id_departamento: number | null
    nombre: string | null
  }

  export type DepartamentoMaxAggregateOutputType = {
    id_departamento: number | null
    nombre: string | null
  }

  export type DepartamentoCountAggregateOutputType = {
    id_departamento: number
    nombre: number
    _all: number
  }


  export type DepartamentoAvgAggregateInputType = {
    id_departamento?: true
  }

  export type DepartamentoSumAggregateInputType = {
    id_departamento?: true
  }

  export type DepartamentoMinAggregateInputType = {
    id_departamento?: true
    nombre?: true
  }

  export type DepartamentoMaxAggregateInputType = {
    id_departamento?: true
    nombre?: true
  }

  export type DepartamentoCountAggregateInputType = {
    id_departamento?: true
    nombre?: true
    _all?: true
  }

  export type DepartamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departamento to aggregate.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departamentos
    **/
    _count?: true | DepartamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartamentoMaxAggregateInputType
  }

  export type GetDepartamentoAggregateType<T extends DepartamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartamento[P]>
      : GetScalarType<T[P], AggregateDepartamento[P]>
  }




  export type DepartamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartamentoWhereInput
    orderBy?: DepartamentoOrderByWithAggregationInput | DepartamentoOrderByWithAggregationInput[]
    by: DepartamentoScalarFieldEnum[] | DepartamentoScalarFieldEnum
    having?: DepartamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartamentoCountAggregateInputType | true
    _avg?: DepartamentoAvgAggregateInputType
    _sum?: DepartamentoSumAggregateInputType
    _min?: DepartamentoMinAggregateInputType
    _max?: DepartamentoMaxAggregateInputType
  }

  export type DepartamentoGroupByOutputType = {
    id_departamento: number
    nombre: string
    _count: DepartamentoCountAggregateOutputType | null
    _avg: DepartamentoAvgAggregateOutputType | null
    _sum: DepartamentoSumAggregateOutputType | null
    _min: DepartamentoMinAggregateOutputType | null
    _max: DepartamentoMaxAggregateOutputType | null
  }

  type GetDepartamentoGroupByPayload<T extends DepartamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartamentoGroupByOutputType[P]>
            : GetScalarType<T[P], DepartamentoGroupByOutputType[P]>
        }
      >
    >


  export type DepartamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_departamento?: boolean
    nombre?: boolean
    municipio?: boolean | Departamento$municipioArgs<ExtArgs>
    _count?: boolean | DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departamento"]>


  export type DepartamentoSelectScalar = {
    id_departamento?: boolean
    nombre?: boolean
  }

  export type DepartamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | Departamento$municipioArgs<ExtArgs>
    _count?: boolean | DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Departamento"
    objects: {
      municipio: Prisma.$MunicipioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_departamento: number
      nombre: string
    }, ExtArgs["result"]["departamento"]>
    composites: {}
  }

  type DepartamentoGetPayload<S extends boolean | null | undefined | DepartamentoDefaultArgs> = $Result.GetResult<Prisma.$DepartamentoPayload, S>

  type DepartamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartamentoCountAggregateInputType | true
    }

  export interface DepartamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Departamento'], meta: { name: 'Departamento' } }
    /**
     * Find zero or one Departamento that matches the filter.
     * @param {DepartamentoFindUniqueArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartamentoFindUniqueArgs>(args: SelectSubset<T, DepartamentoFindUniqueArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Departamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartamentoFindUniqueOrThrowArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Departamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindFirstArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartamentoFindFirstArgs>(args?: SelectSubset<T, DepartamentoFindFirstArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Departamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindFirstOrThrowArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departamentos
     * const departamentos = await prisma.departamento.findMany()
     * 
     * // Get first 10 Departamentos
     * const departamentos = await prisma.departamento.findMany({ take: 10 })
     * 
     * // Only select the `id_departamento`
     * const departamentoWithId_departamentoOnly = await prisma.departamento.findMany({ select: { id_departamento: true } })
     * 
     */
    findMany<T extends DepartamentoFindManyArgs>(args?: SelectSubset<T, DepartamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Departamento.
     * @param {DepartamentoCreateArgs} args - Arguments to create a Departamento.
     * @example
     * // Create one Departamento
     * const Departamento = await prisma.departamento.create({
     *   data: {
     *     // ... data to create a Departamento
     *   }
     * })
     * 
     */
    create<T extends DepartamentoCreateArgs>(args: SelectSubset<T, DepartamentoCreateArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departamentos.
     * @param {DepartamentoCreateManyArgs} args - Arguments to create many Departamentos.
     * @example
     * // Create many Departamentos
     * const departamento = await prisma.departamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartamentoCreateManyArgs>(args?: SelectSubset<T, DepartamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Departamento.
     * @param {DepartamentoDeleteArgs} args - Arguments to delete one Departamento.
     * @example
     * // Delete one Departamento
     * const Departamento = await prisma.departamento.delete({
     *   where: {
     *     // ... filter to delete one Departamento
     *   }
     * })
     * 
     */
    delete<T extends DepartamentoDeleteArgs>(args: SelectSubset<T, DepartamentoDeleteArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Departamento.
     * @param {DepartamentoUpdateArgs} args - Arguments to update one Departamento.
     * @example
     * // Update one Departamento
     * const departamento = await prisma.departamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartamentoUpdateArgs>(args: SelectSubset<T, DepartamentoUpdateArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departamentos.
     * @param {DepartamentoDeleteManyArgs} args - Arguments to filter Departamentos to delete.
     * @example
     * // Delete a few Departamentos
     * const { count } = await prisma.departamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartamentoDeleteManyArgs>(args?: SelectSubset<T, DepartamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departamentos
     * const departamento = await prisma.departamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartamentoUpdateManyArgs>(args: SelectSubset<T, DepartamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Departamento.
     * @param {DepartamentoUpsertArgs} args - Arguments to update or create a Departamento.
     * @example
     * // Update or create a Departamento
     * const departamento = await prisma.departamento.upsert({
     *   create: {
     *     // ... data to create a Departamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departamento we want to update
     *   }
     * })
     */
    upsert<T extends DepartamentoUpsertArgs>(args: SelectSubset<T, DepartamentoUpsertArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoCountArgs} args - Arguments to filter Departamentos to count.
     * @example
     * // Count the number of Departamentos
     * const count = await prisma.departamento.count({
     *   where: {
     *     // ... the filter for the Departamentos we want to count
     *   }
     * })
    **/
    count<T extends DepartamentoCountArgs>(
      args?: Subset<T, DepartamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartamentoAggregateArgs>(args: Subset<T, DepartamentoAggregateArgs>): Prisma.PrismaPromise<GetDepartamentoAggregateType<T>>

    /**
     * Group by Departamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartamentoGroupByArgs['orderBy'] }
        : { orderBy?: DepartamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Departamento model
   */
  readonly fields: DepartamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Departamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipio<T extends Departamento$municipioArgs<ExtArgs> = {}>(args?: Subset<T, Departamento$municipioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Departamento model
   */ 
  interface DepartamentoFieldRefs {
    readonly id_departamento: FieldRef<"Departamento", 'Int'>
    readonly nombre: FieldRef<"Departamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Departamento findUnique
   */
  export type DepartamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento findUniqueOrThrow
   */
  export type DepartamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento findFirst
   */
  export type DepartamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     */
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento findFirstOrThrow
   */
  export type DepartamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     */
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento findMany
   */
  export type DepartamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamentos to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento create
   */
  export type DepartamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Departamento.
     */
    data: XOR<DepartamentoCreateInput, DepartamentoUncheckedCreateInput>
  }

  /**
   * Departamento createMany
   */
  export type DepartamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departamentos.
     */
    data: DepartamentoCreateManyInput | DepartamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Departamento update
   */
  export type DepartamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Departamento.
     */
    data: XOR<DepartamentoUpdateInput, DepartamentoUncheckedUpdateInput>
    /**
     * Choose, which Departamento to update.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento updateMany
   */
  export type DepartamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departamentos.
     */
    data: XOR<DepartamentoUpdateManyMutationInput, DepartamentoUncheckedUpdateManyInput>
    /**
     * Filter which Departamentos to update
     */
    where?: DepartamentoWhereInput
  }

  /**
   * Departamento upsert
   */
  export type DepartamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Departamento to update in case it exists.
     */
    where: DepartamentoWhereUniqueInput
    /**
     * In case the Departamento found by the `where` argument doesn't exist, create a new Departamento with this data.
     */
    create: XOR<DepartamentoCreateInput, DepartamentoUncheckedCreateInput>
    /**
     * In case the Departamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartamentoUpdateInput, DepartamentoUncheckedUpdateInput>
  }

  /**
   * Departamento delete
   */
  export type DepartamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter which Departamento to delete.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento deleteMany
   */
  export type DepartamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departamentos to delete
     */
    where?: DepartamentoWhereInput
  }

  /**
   * Departamento.municipio
   */
  export type Departamento$municipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    where?: MunicipioWhereInput
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    cursor?: MunicipioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Departamento without action
   */
  export type DepartamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
  }


  /**
   * Model Municipio
   */

  export type AggregateMunicipio = {
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  export type MunicipioAvgAggregateOutputType = {
    id_municipio: number | null
    departamentoId: number | null
  }

  export type MunicipioSumAggregateOutputType = {
    id_municipio: number | null
    departamentoId: number | null
  }

  export type MunicipioMinAggregateOutputType = {
    id_municipio: number | null
    nombre: string | null
    departamentoId: number | null
  }

  export type MunicipioMaxAggregateOutputType = {
    id_municipio: number | null
    nombre: string | null
    departamentoId: number | null
  }

  export type MunicipioCountAggregateOutputType = {
    id_municipio: number
    nombre: number
    departamentoId: number
    _all: number
  }


  export type MunicipioAvgAggregateInputType = {
    id_municipio?: true
    departamentoId?: true
  }

  export type MunicipioSumAggregateInputType = {
    id_municipio?: true
    departamentoId?: true
  }

  export type MunicipioMinAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamentoId?: true
  }

  export type MunicipioMaxAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamentoId?: true
  }

  export type MunicipioCountAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamentoId?: true
    _all?: true
  }

  export type MunicipioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipio to aggregate.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipios
    **/
    _count?: true | MunicipioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MunicipioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MunicipioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipioMaxAggregateInputType
  }

  export type GetMunicipioAggregateType<T extends MunicipioAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipio[P]>
      : GetScalarType<T[P], AggregateMunicipio[P]>
  }




  export type MunicipioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipioWhereInput
    orderBy?: MunicipioOrderByWithAggregationInput | MunicipioOrderByWithAggregationInput[]
    by: MunicipioScalarFieldEnum[] | MunicipioScalarFieldEnum
    having?: MunicipioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipioCountAggregateInputType | true
    _avg?: MunicipioAvgAggregateInputType
    _sum?: MunicipioSumAggregateInputType
    _min?: MunicipioMinAggregateInputType
    _max?: MunicipioMaxAggregateInputType
  }

  export type MunicipioGroupByOutputType = {
    id_municipio: number
    nombre: string
    departamentoId: number
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  type GetMunicipioGroupByPayload<T extends MunicipioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
        }
      >
    >


  export type MunicipioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_municipio?: boolean
    nombre?: boolean
    departamentoId?: boolean
    departamento?: boolean | DepartamentoDefaultArgs<ExtArgs>
    paciente?: boolean | Municipio$pacienteArgs<ExtArgs>
    empresa?: boolean | Municipio$empresaArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipio"]>


  export type MunicipioSelectScalar = {
    id_municipio?: boolean
    nombre?: boolean
    departamentoId?: boolean
  }

  export type MunicipioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departamento?: boolean | DepartamentoDefaultArgs<ExtArgs>
    paciente?: boolean | Municipio$pacienteArgs<ExtArgs>
    empresa?: boolean | Municipio$empresaArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MunicipioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipio"
    objects: {
      departamento: Prisma.$DepartamentoPayload<ExtArgs>
      paciente: Prisma.$PacientePayload<ExtArgs>[]
      empresa: Prisma.$EmpresaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_municipio: number
      nombre: string
      departamentoId: number
    }, ExtArgs["result"]["municipio"]>
    composites: {}
  }

  type MunicipioGetPayload<S extends boolean | null | undefined | MunicipioDefaultArgs> = $Result.GetResult<Prisma.$MunicipioPayload, S>

  type MunicipioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MunicipioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MunicipioCountAggregateInputType | true
    }

  export interface MunicipioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipio'], meta: { name: 'Municipio' } }
    /**
     * Find zero or one Municipio that matches the filter.
     * @param {MunicipioFindUniqueArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipioFindUniqueArgs>(args: SelectSubset<T, MunicipioFindUniqueArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Municipio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MunicipioFindUniqueOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipioFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Municipio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindFirstArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipioFindFirstArgs>(args?: SelectSubset<T, MunicipioFindFirstArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Municipio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindFirstOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipioFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipioFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Municipios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipios
     * const municipios = await prisma.municipio.findMany()
     * 
     * // Get first 10 Municipios
     * const municipios = await prisma.municipio.findMany({ take: 10 })
     * 
     * // Only select the `id_municipio`
     * const municipioWithId_municipioOnly = await prisma.municipio.findMany({ select: { id_municipio: true } })
     * 
     */
    findMany<T extends MunicipioFindManyArgs>(args?: SelectSubset<T, MunicipioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Municipio.
     * @param {MunicipioCreateArgs} args - Arguments to create a Municipio.
     * @example
     * // Create one Municipio
     * const Municipio = await prisma.municipio.create({
     *   data: {
     *     // ... data to create a Municipio
     *   }
     * })
     * 
     */
    create<T extends MunicipioCreateArgs>(args: SelectSubset<T, MunicipioCreateArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Municipios.
     * @param {MunicipioCreateManyArgs} args - Arguments to create many Municipios.
     * @example
     * // Create many Municipios
     * const municipio = await prisma.municipio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipioCreateManyArgs>(args?: SelectSubset<T, MunicipioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Municipio.
     * @param {MunicipioDeleteArgs} args - Arguments to delete one Municipio.
     * @example
     * // Delete one Municipio
     * const Municipio = await prisma.municipio.delete({
     *   where: {
     *     // ... filter to delete one Municipio
     *   }
     * })
     * 
     */
    delete<T extends MunicipioDeleteArgs>(args: SelectSubset<T, MunicipioDeleteArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Municipio.
     * @param {MunicipioUpdateArgs} args - Arguments to update one Municipio.
     * @example
     * // Update one Municipio
     * const municipio = await prisma.municipio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipioUpdateArgs>(args: SelectSubset<T, MunicipioUpdateArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Municipios.
     * @param {MunicipioDeleteManyArgs} args - Arguments to filter Municipios to delete.
     * @example
     * // Delete a few Municipios
     * const { count } = await prisma.municipio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipioDeleteManyArgs>(args?: SelectSubset<T, MunicipioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipios
     * const municipio = await prisma.municipio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipioUpdateManyArgs>(args: SelectSubset<T, MunicipioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Municipio.
     * @param {MunicipioUpsertArgs} args - Arguments to update or create a Municipio.
     * @example
     * // Update or create a Municipio
     * const municipio = await prisma.municipio.upsert({
     *   create: {
     *     // ... data to create a Municipio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipio we want to update
     *   }
     * })
     */
    upsert<T extends MunicipioUpsertArgs>(args: SelectSubset<T, MunicipioUpsertArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioCountArgs} args - Arguments to filter Municipios to count.
     * @example
     * // Count the number of Municipios
     * const count = await prisma.municipio.count({
     *   where: {
     *     // ... the filter for the Municipios we want to count
     *   }
     * })
    **/
    count<T extends MunicipioCountArgs>(
      args?: Subset<T, MunicipioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipioAggregateArgs>(args: Subset<T, MunicipioAggregateArgs>): Prisma.PrismaPromise<GetMunicipioAggregateType<T>>

    /**
     * Group by Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipioGroupByArgs['orderBy'] }
        : { orderBy?: MunicipioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipio model
   */
  readonly fields: MunicipioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departamento<T extends DepartamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartamentoDefaultArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paciente<T extends Municipio$pacienteArgs<ExtArgs> = {}>(args?: Subset<T, Municipio$pacienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findMany"> | Null>
    empresa<T extends Municipio$empresaArgs<ExtArgs> = {}>(args?: Subset<T, Municipio$empresaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipio model
   */ 
  interface MunicipioFieldRefs {
    readonly id_municipio: FieldRef<"Municipio", 'Int'>
    readonly nombre: FieldRef<"Municipio", 'String'>
    readonly departamentoId: FieldRef<"Municipio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Municipio findUnique
   */
  export type MunicipioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio findUniqueOrThrow
   */
  export type MunicipioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio findFirst
   */
  export type MunicipioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio findFirstOrThrow
   */
  export type MunicipioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio findMany
   */
  export type MunicipioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipios to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio create
   */
  export type MunicipioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipio.
     */
    data: XOR<MunicipioCreateInput, MunicipioUncheckedCreateInput>
  }

  /**
   * Municipio createMany
   */
  export type MunicipioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipios.
     */
    data: MunicipioCreateManyInput | MunicipioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Municipio update
   */
  export type MunicipioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipio.
     */
    data: XOR<MunicipioUpdateInput, MunicipioUncheckedUpdateInput>
    /**
     * Choose, which Municipio to update.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio updateMany
   */
  export type MunicipioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipios.
     */
    data: XOR<MunicipioUpdateManyMutationInput, MunicipioUncheckedUpdateManyInput>
    /**
     * Filter which Municipios to update
     */
    where?: MunicipioWhereInput
  }

  /**
   * Municipio upsert
   */
  export type MunicipioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipio to update in case it exists.
     */
    where: MunicipioWhereUniqueInput
    /**
     * In case the Municipio found by the `where` argument doesn't exist, create a new Municipio with this data.
     */
    create: XOR<MunicipioCreateInput, MunicipioUncheckedCreateInput>
    /**
     * In case the Municipio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipioUpdateInput, MunicipioUncheckedUpdateInput>
  }

  /**
   * Municipio delete
   */
  export type MunicipioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter which Municipio to delete.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio deleteMany
   */
  export type MunicipioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipios to delete
     */
    where?: MunicipioWhereInput
  }

  /**
   * Municipio.paciente
   */
  export type Municipio$pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    where?: PacienteWhereInput
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    cursor?: PacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Municipio.empresa
   */
  export type Municipio$empresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    cursor?: EmpresaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Municipio without action
   */
  export type MunicipioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
  }


  /**
   * Model Tipo_Servicio
   */

  export type AggregateTipo_Servicio = {
    _count: Tipo_ServicioCountAggregateOutputType | null
    _avg: Tipo_ServicioAvgAggregateOutputType | null
    _sum: Tipo_ServicioSumAggregateOutputType | null
    _min: Tipo_ServicioMinAggregateOutputType | null
    _max: Tipo_ServicioMaxAggregateOutputType | null
  }

  export type Tipo_ServicioAvgAggregateOutputType = {
    id_tipo_servicio: number | null
  }

  export type Tipo_ServicioSumAggregateOutputType = {
    id_tipo_servicio: number | null
  }

  export type Tipo_ServicioMinAggregateOutputType = {
    id_tipo_servicio: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type Tipo_ServicioMaxAggregateOutputType = {
    id_tipo_servicio: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type Tipo_ServicioCountAggregateOutputType = {
    id_tipo_servicio: number
    nombre: number
    estado: number
    _all: number
  }


  export type Tipo_ServicioAvgAggregateInputType = {
    id_tipo_servicio?: true
  }

  export type Tipo_ServicioSumAggregateInputType = {
    id_tipo_servicio?: true
  }

  export type Tipo_ServicioMinAggregateInputType = {
    id_tipo_servicio?: true
    nombre?: true
    estado?: true
  }

  export type Tipo_ServicioMaxAggregateInputType = {
    id_tipo_servicio?: true
    nombre?: true
    estado?: true
  }

  export type Tipo_ServicioCountAggregateInputType = {
    id_tipo_servicio?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type Tipo_ServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Servicio to aggregate.
     */
    where?: Tipo_ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Servicios to fetch.
     */
    orderBy?: Tipo_ServicioOrderByWithRelationInput | Tipo_ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tipo_ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipo_Servicios
    **/
    _count?: true | Tipo_ServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_ServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_ServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_ServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_ServicioMaxAggregateInputType
  }

  export type GetTipo_ServicioAggregateType<T extends Tipo_ServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_Servicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_Servicio[P]>
      : GetScalarType<T[P], AggregateTipo_Servicio[P]>
  }




  export type Tipo_ServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ServicioWhereInput
    orderBy?: Tipo_ServicioOrderByWithAggregationInput | Tipo_ServicioOrderByWithAggregationInput[]
    by: Tipo_ServicioScalarFieldEnum[] | Tipo_ServicioScalarFieldEnum
    having?: Tipo_ServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_ServicioCountAggregateInputType | true
    _avg?: Tipo_ServicioAvgAggregateInputType
    _sum?: Tipo_ServicioSumAggregateInputType
    _min?: Tipo_ServicioMinAggregateInputType
    _max?: Tipo_ServicioMaxAggregateInputType
  }

  export type Tipo_ServicioGroupByOutputType = {
    id_tipo_servicio: number
    nombre: string
    estado: $Enums.Estado
    _count: Tipo_ServicioCountAggregateOutputType | null
    _avg: Tipo_ServicioAvgAggregateOutputType | null
    _sum: Tipo_ServicioSumAggregateOutputType | null
    _min: Tipo_ServicioMinAggregateOutputType | null
    _max: Tipo_ServicioMaxAggregateOutputType | null
  }

  type GetTipo_ServicioGroupByPayload<T extends Tipo_ServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_ServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_ServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_ServicioGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_ServicioGroupByOutputType[P]>
        }
      >
    >


  export type Tipo_ServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_servicio?: boolean
    nombre?: boolean
    estado?: boolean
    servicio?: boolean | Tipo_Servicio$servicioArgs<ExtArgs>
    _count?: boolean | Tipo_ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_Servicio"]>


  export type Tipo_ServicioSelectScalar = {
    id_tipo_servicio?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type Tipo_ServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Tipo_Servicio$servicioArgs<ExtArgs>
    _count?: boolean | Tipo_ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Tipo_ServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tipo_Servicio"
    objects: {
      servicio: Prisma.$ServicioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_servicio: number
      nombre: string
      estado: $Enums.Estado
    }, ExtArgs["result"]["tipo_Servicio"]>
    composites: {}
  }

  type Tipo_ServicioGetPayload<S extends boolean | null | undefined | Tipo_ServicioDefaultArgs> = $Result.GetResult<Prisma.$Tipo_ServicioPayload, S>

  type Tipo_ServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tipo_ServicioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_ServicioCountAggregateInputType | true
    }

  export interface Tipo_ServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tipo_Servicio'], meta: { name: 'Tipo_Servicio' } }
    /**
     * Find zero or one Tipo_Servicio that matches the filter.
     * @param {Tipo_ServicioFindUniqueArgs} args - Arguments to find a Tipo_Servicio
     * @example
     * // Get one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tipo_ServicioFindUniqueArgs>(args: SelectSubset<T, Tipo_ServicioFindUniqueArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_Servicio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Tipo_ServicioFindUniqueOrThrowArgs} args - Arguments to find a Tipo_Servicio
     * @example
     * // Get one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tipo_ServicioFindUniqueOrThrowArgs>(args: SelectSubset<T, Tipo_ServicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_Servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioFindFirstArgs} args - Arguments to find a Tipo_Servicio
     * @example
     * // Get one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tipo_ServicioFindFirstArgs>(args?: SelectSubset<T, Tipo_ServicioFindFirstArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_Servicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioFindFirstOrThrowArgs} args - Arguments to find a Tipo_Servicio
     * @example
     * // Get one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tipo_ServicioFindFirstOrThrowArgs>(args?: SelectSubset<T, Tipo_ServicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_Servicios
     * const tipo_Servicios = await prisma.tipo_Servicio.findMany()
     * 
     * // Get first 10 Tipo_Servicios
     * const tipo_Servicios = await prisma.tipo_Servicio.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_servicio`
     * const tipo_ServicioWithId_tipo_servicioOnly = await prisma.tipo_Servicio.findMany({ select: { id_tipo_servicio: true } })
     * 
     */
    findMany<T extends Tipo_ServicioFindManyArgs>(args?: SelectSubset<T, Tipo_ServicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_Servicio.
     * @param {Tipo_ServicioCreateArgs} args - Arguments to create a Tipo_Servicio.
     * @example
     * // Create one Tipo_Servicio
     * const Tipo_Servicio = await prisma.tipo_Servicio.create({
     *   data: {
     *     // ... data to create a Tipo_Servicio
     *   }
     * })
     * 
     */
    create<T extends Tipo_ServicioCreateArgs>(args: SelectSubset<T, Tipo_ServicioCreateArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_Servicios.
     * @param {Tipo_ServicioCreateManyArgs} args - Arguments to create many Tipo_Servicios.
     * @example
     * // Create many Tipo_Servicios
     * const tipo_Servicio = await prisma.tipo_Servicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tipo_ServicioCreateManyArgs>(args?: SelectSubset<T, Tipo_ServicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_Servicio.
     * @param {Tipo_ServicioDeleteArgs} args - Arguments to delete one Tipo_Servicio.
     * @example
     * // Delete one Tipo_Servicio
     * const Tipo_Servicio = await prisma.tipo_Servicio.delete({
     *   where: {
     *     // ... filter to delete one Tipo_Servicio
     *   }
     * })
     * 
     */
    delete<T extends Tipo_ServicioDeleteArgs>(args: SelectSubset<T, Tipo_ServicioDeleteArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_Servicio.
     * @param {Tipo_ServicioUpdateArgs} args - Arguments to update one Tipo_Servicio.
     * @example
     * // Update one Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tipo_ServicioUpdateArgs>(args: SelectSubset<T, Tipo_ServicioUpdateArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_Servicios.
     * @param {Tipo_ServicioDeleteManyArgs} args - Arguments to filter Tipo_Servicios to delete.
     * @example
     * // Delete a few Tipo_Servicios
     * const { count } = await prisma.tipo_Servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tipo_ServicioDeleteManyArgs>(args?: SelectSubset<T, Tipo_ServicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_Servicios
     * const tipo_Servicio = await prisma.tipo_Servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tipo_ServicioUpdateManyArgs>(args: SelectSubset<T, Tipo_ServicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_Servicio.
     * @param {Tipo_ServicioUpsertArgs} args - Arguments to update or create a Tipo_Servicio.
     * @example
     * // Update or create a Tipo_Servicio
     * const tipo_Servicio = await prisma.tipo_Servicio.upsert({
     *   create: {
     *     // ... data to create a Tipo_Servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_Servicio we want to update
     *   }
     * })
     */
    upsert<T extends Tipo_ServicioUpsertArgs>(args: SelectSubset<T, Tipo_ServicioUpsertArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioCountArgs} args - Arguments to filter Tipo_Servicios to count.
     * @example
     * // Count the number of Tipo_Servicios
     * const count = await prisma.tipo_Servicio.count({
     *   where: {
     *     // ... the filter for the Tipo_Servicios we want to count
     *   }
     * })
    **/
    count<T extends Tipo_ServicioCountArgs>(
      args?: Subset<T, Tipo_ServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_ServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_ServicioAggregateArgs>(args: Subset<T, Tipo_ServicioAggregateArgs>): Prisma.PrismaPromise<GetTipo_ServicioAggregateType<T>>

    /**
     * Group by Tipo_Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_ServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_ServicioGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_ServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_ServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_ServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tipo_Servicio model
   */
  readonly fields: Tipo_ServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo_Servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tipo_ServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends Tipo_Servicio$servicioArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_Servicio$servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tipo_Servicio model
   */ 
  interface Tipo_ServicioFieldRefs {
    readonly id_tipo_servicio: FieldRef<"Tipo_Servicio", 'Int'>
    readonly nombre: FieldRef<"Tipo_Servicio", 'String'>
    readonly estado: FieldRef<"Tipo_Servicio", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Tipo_Servicio findUnique
   */
  export type Tipo_ServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicio to fetch.
     */
    where: Tipo_ServicioWhereUniqueInput
  }

  /**
   * Tipo_Servicio findUniqueOrThrow
   */
  export type Tipo_ServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicio to fetch.
     */
    where: Tipo_ServicioWhereUniqueInput
  }

  /**
   * Tipo_Servicio findFirst
   */
  export type Tipo_ServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicio to fetch.
     */
    where?: Tipo_ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Servicios to fetch.
     */
    orderBy?: Tipo_ServicioOrderByWithRelationInput | Tipo_ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Servicios.
     */
    cursor?: Tipo_ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Servicios.
     */
    distinct?: Tipo_ServicioScalarFieldEnum | Tipo_ServicioScalarFieldEnum[]
  }

  /**
   * Tipo_Servicio findFirstOrThrow
   */
  export type Tipo_ServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicio to fetch.
     */
    where?: Tipo_ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Servicios to fetch.
     */
    orderBy?: Tipo_ServicioOrderByWithRelationInput | Tipo_ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Servicios.
     */
    cursor?: Tipo_ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Servicios.
     */
    distinct?: Tipo_ServicioScalarFieldEnum | Tipo_ServicioScalarFieldEnum[]
  }

  /**
   * Tipo_Servicio findMany
   */
  export type Tipo_ServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Servicios to fetch.
     */
    where?: Tipo_ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Servicios to fetch.
     */
    orderBy?: Tipo_ServicioOrderByWithRelationInput | Tipo_ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipo_Servicios.
     */
    cursor?: Tipo_ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Servicios.
     */
    skip?: number
    distinct?: Tipo_ServicioScalarFieldEnum | Tipo_ServicioScalarFieldEnum[]
  }

  /**
   * Tipo_Servicio create
   */
  export type Tipo_ServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a Tipo_Servicio.
     */
    data: XOR<Tipo_ServicioCreateInput, Tipo_ServicioUncheckedCreateInput>
  }

  /**
   * Tipo_Servicio createMany
   */
  export type Tipo_ServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tipo_Servicios.
     */
    data: Tipo_ServicioCreateManyInput | Tipo_ServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tipo_Servicio update
   */
  export type Tipo_ServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a Tipo_Servicio.
     */
    data: XOR<Tipo_ServicioUpdateInput, Tipo_ServicioUncheckedUpdateInput>
    /**
     * Choose, which Tipo_Servicio to update.
     */
    where: Tipo_ServicioWhereUniqueInput
  }

  /**
   * Tipo_Servicio updateMany
   */
  export type Tipo_ServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tipo_Servicios.
     */
    data: XOR<Tipo_ServicioUpdateManyMutationInput, Tipo_ServicioUncheckedUpdateManyInput>
    /**
     * Filter which Tipo_Servicios to update
     */
    where?: Tipo_ServicioWhereInput
  }

  /**
   * Tipo_Servicio upsert
   */
  export type Tipo_ServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the Tipo_Servicio to update in case it exists.
     */
    where: Tipo_ServicioWhereUniqueInput
    /**
     * In case the Tipo_Servicio found by the `where` argument doesn't exist, create a new Tipo_Servicio with this data.
     */
    create: XOR<Tipo_ServicioCreateInput, Tipo_ServicioUncheckedCreateInput>
    /**
     * In case the Tipo_Servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tipo_ServicioUpdateInput, Tipo_ServicioUncheckedUpdateInput>
  }

  /**
   * Tipo_Servicio delete
   */
  export type Tipo_ServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
    /**
     * Filter which Tipo_Servicio to delete.
     */
    where: Tipo_ServicioWhereUniqueInput
  }

  /**
   * Tipo_Servicio deleteMany
   */
  export type Tipo_ServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Servicios to delete
     */
    where?: Tipo_ServicioWhereInput
  }

  /**
   * Tipo_Servicio.servicio
   */
  export type Tipo_Servicio$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    cursor?: ServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Tipo_Servicio without action
   */
  export type Tipo_ServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Servicio
     */
    select?: Tipo_ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ServicioInclude<ExtArgs> | null
  }


  /**
   * Model Servicio
   */

  export type AggregateServicio = {
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  export type ServicioAvgAggregateOutputType = {
    id_servicio: number | null
    nivel: number | null
    precio: Decimal | null
    tipo_servicioId: number | null
    prestadorId: number | null
  }

  export type ServicioSumAggregateOutputType = {
    id_servicio: number | null
    nivel: number | null
    precio: Decimal | null
    tipo_servicioId: number | null
    prestadorId: number | null
  }

  export type ServicioMinAggregateOutputType = {
    id_servicio: number | null
    nombre: string | null
    nivel: number | null
    precio: Decimal | null
    estado: $Enums.Estado | null
    tipo_servicioId: number | null
    prestadorId: number | null
  }

  export type ServicioMaxAggregateOutputType = {
    id_servicio: number | null
    nombre: string | null
    nivel: number | null
    precio: Decimal | null
    estado: $Enums.Estado | null
    tipo_servicioId: number | null
    prestadorId: number | null
  }

  export type ServicioCountAggregateOutputType = {
    id_servicio: number
    nombre: number
    nivel: number
    precio: number
    estado: number
    tipo_servicioId: number
    prestadorId: number
    _all: number
  }


  export type ServicioAvgAggregateInputType = {
    id_servicio?: true
    nivel?: true
    precio?: true
    tipo_servicioId?: true
    prestadorId?: true
  }

  export type ServicioSumAggregateInputType = {
    id_servicio?: true
    nivel?: true
    precio?: true
    tipo_servicioId?: true
    prestadorId?: true
  }

  export type ServicioMinAggregateInputType = {
    id_servicio?: true
    nombre?: true
    nivel?: true
    precio?: true
    estado?: true
    tipo_servicioId?: true
    prestadorId?: true
  }

  export type ServicioMaxAggregateInputType = {
    id_servicio?: true
    nombre?: true
    nivel?: true
    precio?: true
    estado?: true
    tipo_servicioId?: true
    prestadorId?: true
  }

  export type ServicioCountAggregateInputType = {
    id_servicio?: true
    nombre?: true
    nivel?: true
    precio?: true
    estado?: true
    tipo_servicioId?: true
    prestadorId?: true
    _all?: true
  }

  export type ServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicio to aggregate.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicios
    **/
    _count?: true | ServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioMaxAggregateInputType
  }

  export type GetServicioAggregateType<T extends ServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio[P]>
      : GetScalarType<T[P], AggregateServicio[P]>
  }




  export type ServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithAggregationInput | ServicioOrderByWithAggregationInput[]
    by: ServicioScalarFieldEnum[] | ServicioScalarFieldEnum
    having?: ServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioCountAggregateInputType | true
    _avg?: ServicioAvgAggregateInputType
    _sum?: ServicioSumAggregateInputType
    _min?: ServicioMinAggregateInputType
    _max?: ServicioMaxAggregateInputType
  }

  export type ServicioGroupByOutputType = {
    id_servicio: number
    nombre: string
    nivel: number
    precio: Decimal
    estado: $Enums.Estado
    tipo_servicioId: number
    prestadorId: number
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  type GetServicioGroupByPayload<T extends ServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicioGroupByOutputType[P]>
            : GetScalarType<T[P], ServicioGroupByOutputType[P]>
        }
      >
    >


  export type ServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_servicio?: boolean
    nombre?: boolean
    nivel?: boolean
    precio?: boolean
    estado?: boolean
    tipo_servicioId?: boolean
    prestadorId?: boolean
    paquete?: boolean | Servicio$paqueteArgs<ExtArgs>
    acuerdo?: boolean | Servicio$acuerdoArgs<ExtArgs>
    tipo_servicio?: boolean | Tipo_ServicioDefaultArgs<ExtArgs>
    prestador?: boolean | PrestadorDefaultArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>


  export type ServicioSelectScalar = {
    id_servicio?: boolean
    nombre?: boolean
    nivel?: boolean
    precio?: boolean
    estado?: boolean
    tipo_servicioId?: boolean
    prestadorId?: boolean
  }

  export type ServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | Servicio$paqueteArgs<ExtArgs>
    acuerdo?: boolean | Servicio$acuerdoArgs<ExtArgs>
    tipo_servicio?: boolean | Tipo_ServicioDefaultArgs<ExtArgs>
    prestador?: boolean | PrestadorDefaultArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Servicio"
    objects: {
      paquete: Prisma.$PaquetePayload<ExtArgs>[]
      acuerdo: Prisma.$AcuerdoPayload<ExtArgs>[]
      tipo_servicio: Prisma.$Tipo_ServicioPayload<ExtArgs>
      prestador: Prisma.$PrestadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_servicio: number
      nombre: string
      nivel: number
      precio: Prisma.Decimal
      estado: $Enums.Estado
      tipo_servicioId: number
      prestadorId: number
    }, ExtArgs["result"]["servicio"]>
    composites: {}
  }

  type ServicioGetPayload<S extends boolean | null | undefined | ServicioDefaultArgs> = $Result.GetResult<Prisma.$ServicioPayload, S>

  type ServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServicioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicioCountAggregateInputType | true
    }

  export interface ServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Servicio'], meta: { name: 'Servicio' } }
    /**
     * Find zero or one Servicio that matches the filter.
     * @param {ServicioFindUniqueArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicioFindUniqueArgs>(args: SelectSubset<T, ServicioFindUniqueArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServicioFindUniqueOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicioFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicioFindFirstArgs>(args?: SelectSubset<T, ServicioFindFirstArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicioFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicio.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicio.findMany({ take: 10 })
     * 
     * // Only select the `id_servicio`
     * const servicioWithId_servicioOnly = await prisma.servicio.findMany({ select: { id_servicio: true } })
     * 
     */
    findMany<T extends ServicioFindManyArgs>(args?: SelectSubset<T, ServicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicio.
     * @param {ServicioCreateArgs} args - Arguments to create a Servicio.
     * @example
     * // Create one Servicio
     * const Servicio = await prisma.servicio.create({
     *   data: {
     *     // ... data to create a Servicio
     *   }
     * })
     * 
     */
    create<T extends ServicioCreateArgs>(args: SelectSubset<T, ServicioCreateArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicios.
     * @param {ServicioCreateManyArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicio = await prisma.servicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicioCreateManyArgs>(args?: SelectSubset<T, ServicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio.
     * @param {ServicioDeleteArgs} args - Arguments to delete one Servicio.
     * @example
     * // Delete one Servicio
     * const Servicio = await prisma.servicio.delete({
     *   where: {
     *     // ... filter to delete one Servicio
     *   }
     * })
     * 
     */
    delete<T extends ServicioDeleteArgs>(args: SelectSubset<T, ServicioDeleteArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicio.
     * @param {ServicioUpdateArgs} args - Arguments to update one Servicio.
     * @example
     * // Update one Servicio
     * const servicio = await prisma.servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicioUpdateArgs>(args: SelectSubset<T, ServicioUpdateArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {ServicioDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicioDeleteManyArgs>(args?: SelectSubset<T, ServicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicio = await prisma.servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicioUpdateManyArgs>(args: SelectSubset<T, ServicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio.
     * @param {ServicioUpsertArgs} args - Arguments to update or create a Servicio.
     * @example
     * // Update or create a Servicio
     * const servicio = await prisma.servicio.upsert({
     *   create: {
     *     // ... data to create a Servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio we want to update
     *   }
     * })
     */
    upsert<T extends ServicioUpsertArgs>(args: SelectSubset<T, ServicioUpsertArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicio.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends ServicioCountArgs>(
      args?: Subset<T, ServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioAggregateArgs>(args: Subset<T, ServicioAggregateArgs>): Prisma.PrismaPromise<GetServicioAggregateType<T>>

    /**
     * Group by Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicioGroupByArgs['orderBy'] }
        : { orderBy?: ServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Servicio model
   */
  readonly fields: ServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paquete<T extends Servicio$paqueteArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$paqueteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "findMany"> | Null>
    acuerdo<T extends Servicio$acuerdoArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$acuerdoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findMany"> | Null>
    tipo_servicio<T extends Tipo_ServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_ServicioDefaultArgs<ExtArgs>>): Prisma__Tipo_ServicioClient<$Result.GetResult<Prisma.$Tipo_ServicioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prestador<T extends PrestadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrestadorDefaultArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Servicio model
   */ 
  interface ServicioFieldRefs {
    readonly id_servicio: FieldRef<"Servicio", 'Int'>
    readonly nombre: FieldRef<"Servicio", 'String'>
    readonly nivel: FieldRef<"Servicio", 'Int'>
    readonly precio: FieldRef<"Servicio", 'Decimal'>
    readonly estado: FieldRef<"Servicio", 'Estado'>
    readonly tipo_servicioId: FieldRef<"Servicio", 'Int'>
    readonly prestadorId: FieldRef<"Servicio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Servicio findUnique
   */
  export type ServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findUniqueOrThrow
   */
  export type ServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findFirst
   */
  export type ServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio findFirstOrThrow
   */
  export type ServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio findMany
   */
  export type ServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio create
   */
  export type ServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a Servicio.
     */
    data: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
  }

  /**
   * Servicio createMany
   */
  export type ServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servicios.
     */
    data: ServicioCreateManyInput | ServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Servicio update
   */
  export type ServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a Servicio.
     */
    data: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
    /**
     * Choose, which Servicio to update.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio updateMany
   */
  export type ServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servicios.
     */
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyInput>
    /**
     * Filter which Servicios to update
     */
    where?: ServicioWhereInput
  }

  /**
   * Servicio upsert
   */
  export type ServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the Servicio to update in case it exists.
     */
    where: ServicioWhereUniqueInput
    /**
     * In case the Servicio found by the `where` argument doesn't exist, create a new Servicio with this data.
     */
    create: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
    /**
     * In case the Servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
  }

  /**
   * Servicio delete
   */
  export type ServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter which Servicio to delete.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio deleteMany
   */
  export type ServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to delete
     */
    where?: ServicioWhereInput
  }

  /**
   * Servicio.paquete
   */
  export type Servicio$paqueteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    where?: PaqueteWhereInput
    orderBy?: PaqueteOrderByWithRelationInput | PaqueteOrderByWithRelationInput[]
    cursor?: PaqueteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaqueteScalarFieldEnum | PaqueteScalarFieldEnum[]
  }

  /**
   * Servicio.acuerdo
   */
  export type Servicio$acuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    where?: AcuerdoWhereInput
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    cursor?: AcuerdoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Servicio without action
   */
  export type ServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
  }


  /**
   * Model Examen
   */

  export type AggregateExamen = {
    _count: ExamenCountAggregateOutputType | null
    _avg: ExamenAvgAggregateOutputType | null
    _sum: ExamenSumAggregateOutputType | null
    _min: ExamenMinAggregateOutputType | null
    _max: ExamenMaxAggregateOutputType | null
  }

  export type ExamenAvgAggregateOutputType = {
    id_examen: number | null
    precio: Decimal | null
    tipo_examenId: number | null
  }

  export type ExamenSumAggregateOutputType = {
    id_examen: number | null
    precio: Decimal | null
    tipo_examenId: number | null
  }

  export type ExamenMinAggregateOutputType = {
    id_examen: number | null
    nombre: string | null
    unidades: string | null
    rango_biologico: string | null
    metodo: string | null
    precio: Decimal | null
    estado: $Enums.Estado | null
    tipo_examenId: number | null
  }

  export type ExamenMaxAggregateOutputType = {
    id_examen: number | null
    nombre: string | null
    unidades: string | null
    rango_biologico: string | null
    metodo: string | null
    precio: Decimal | null
    estado: $Enums.Estado | null
    tipo_examenId: number | null
  }

  export type ExamenCountAggregateOutputType = {
    id_examen: number
    nombre: number
    unidades: number
    rango_biologico: number
    metodo: number
    precio: number
    estado: number
    tipo_examenId: number
    _all: number
  }


  export type ExamenAvgAggregateInputType = {
    id_examen?: true
    precio?: true
    tipo_examenId?: true
  }

  export type ExamenSumAggregateInputType = {
    id_examen?: true
    precio?: true
    tipo_examenId?: true
  }

  export type ExamenMinAggregateInputType = {
    id_examen?: true
    nombre?: true
    unidades?: true
    rango_biologico?: true
    metodo?: true
    precio?: true
    estado?: true
    tipo_examenId?: true
  }

  export type ExamenMaxAggregateInputType = {
    id_examen?: true
    nombre?: true
    unidades?: true
    rango_biologico?: true
    metodo?: true
    precio?: true
    estado?: true
    tipo_examenId?: true
  }

  export type ExamenCountAggregateInputType = {
    id_examen?: true
    nombre?: true
    unidades?: true
    rango_biologico?: true
    metodo?: true
    precio?: true
    estado?: true
    tipo_examenId?: true
    _all?: true
  }

  export type ExamenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Examen to aggregate.
     */
    where?: ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examen to fetch.
     */
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Examen
    **/
    _count?: true | ExamenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamenMaxAggregateInputType
  }

  export type GetExamenAggregateType<T extends ExamenAggregateArgs> = {
        [P in keyof T & keyof AggregateExamen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamen[P]>
      : GetScalarType<T[P], AggregateExamen[P]>
  }




  export type ExamenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamenWhereInput
    orderBy?: ExamenOrderByWithAggregationInput | ExamenOrderByWithAggregationInput[]
    by: ExamenScalarFieldEnum[] | ExamenScalarFieldEnum
    having?: ExamenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamenCountAggregateInputType | true
    _avg?: ExamenAvgAggregateInputType
    _sum?: ExamenSumAggregateInputType
    _min?: ExamenMinAggregateInputType
    _max?: ExamenMaxAggregateInputType
  }

  export type ExamenGroupByOutputType = {
    id_examen: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal
    estado: $Enums.Estado
    tipo_examenId: number
    _count: ExamenCountAggregateOutputType | null
    _avg: ExamenAvgAggregateOutputType | null
    _sum: ExamenSumAggregateOutputType | null
    _min: ExamenMinAggregateOutputType | null
    _max: ExamenMaxAggregateOutputType | null
  }

  type GetExamenGroupByPayload<T extends ExamenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamenGroupByOutputType[P]>
            : GetScalarType<T[P], ExamenGroupByOutputType[P]>
        }
      >
    >


  export type ExamenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_examen?: boolean
    nombre?: boolean
    unidades?: boolean
    rango_biologico?: boolean
    metodo?: boolean
    precio?: boolean
    estado?: boolean
    tipo_examenId?: boolean
    tipo_examen?: boolean | Tipo_ExamenDefaultArgs<ExtArgs>
    tipo_resultado?: boolean | Examen$tipo_resultadoArgs<ExtArgs>
    paquete?: boolean | Examen$paqueteArgs<ExtArgs>
    _count?: boolean | ExamenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examen"]>


  export type ExamenSelectScalar = {
    id_examen?: boolean
    nombre?: boolean
    unidades?: boolean
    rango_biologico?: boolean
    metodo?: boolean
    precio?: boolean
    estado?: boolean
    tipo_examenId?: boolean
  }

  export type ExamenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipo_examen?: boolean | Tipo_ExamenDefaultArgs<ExtArgs>
    tipo_resultado?: boolean | Examen$tipo_resultadoArgs<ExtArgs>
    paquete?: boolean | Examen$paqueteArgs<ExtArgs>
    _count?: boolean | ExamenCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Examen"
    objects: {
      tipo_examen: Prisma.$Tipo_ExamenPayload<ExtArgs>
      tipo_resultado: Prisma.$Tipo_ResultadoPayload<ExtArgs>[]
      paquete: Prisma.$PaquetePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_examen: number
      nombre: string
      unidades: string
      rango_biologico: string
      metodo: string
      precio: Prisma.Decimal
      estado: $Enums.Estado
      tipo_examenId: number
    }, ExtArgs["result"]["examen"]>
    composites: {}
  }

  type ExamenGetPayload<S extends boolean | null | undefined | ExamenDefaultArgs> = $Result.GetResult<Prisma.$ExamenPayload, S>

  type ExamenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamenCountAggregateInputType | true
    }

  export interface ExamenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Examen'], meta: { name: 'Examen' } }
    /**
     * Find zero or one Examen that matches the filter.
     * @param {ExamenFindUniqueArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamenFindUniqueArgs>(args: SelectSubset<T, ExamenFindUniqueArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Examen that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamenFindUniqueOrThrowArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamenFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenFindFirstArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamenFindFirstArgs>(args?: SelectSubset<T, ExamenFindFirstArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Examen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenFindFirstOrThrowArgs} args - Arguments to find a Examen
     * @example
     * // Get one Examen
     * const examen = await prisma.examen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamenFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Examen
     * const examen = await prisma.examen.findMany()
     * 
     * // Get first 10 Examen
     * const examen = await prisma.examen.findMany({ take: 10 })
     * 
     * // Only select the `id_examen`
     * const examenWithId_examenOnly = await prisma.examen.findMany({ select: { id_examen: true } })
     * 
     */
    findMany<T extends ExamenFindManyArgs>(args?: SelectSubset<T, ExamenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Examen.
     * @param {ExamenCreateArgs} args - Arguments to create a Examen.
     * @example
     * // Create one Examen
     * const Examen = await prisma.examen.create({
     *   data: {
     *     // ... data to create a Examen
     *   }
     * })
     * 
     */
    create<T extends ExamenCreateArgs>(args: SelectSubset<T, ExamenCreateArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Examen.
     * @param {ExamenCreateManyArgs} args - Arguments to create many Examen.
     * @example
     * // Create many Examen
     * const examen = await prisma.examen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamenCreateManyArgs>(args?: SelectSubset<T, ExamenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Examen.
     * @param {ExamenDeleteArgs} args - Arguments to delete one Examen.
     * @example
     * // Delete one Examen
     * const Examen = await prisma.examen.delete({
     *   where: {
     *     // ... filter to delete one Examen
     *   }
     * })
     * 
     */
    delete<T extends ExamenDeleteArgs>(args: SelectSubset<T, ExamenDeleteArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Examen.
     * @param {ExamenUpdateArgs} args - Arguments to update one Examen.
     * @example
     * // Update one Examen
     * const examen = await prisma.examen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamenUpdateArgs>(args: SelectSubset<T, ExamenUpdateArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Examen.
     * @param {ExamenDeleteManyArgs} args - Arguments to filter Examen to delete.
     * @example
     * // Delete a few Examen
     * const { count } = await prisma.examen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamenDeleteManyArgs>(args?: SelectSubset<T, ExamenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Examen
     * const examen = await prisma.examen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamenUpdateManyArgs>(args: SelectSubset<T, ExamenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Examen.
     * @param {ExamenUpsertArgs} args - Arguments to update or create a Examen.
     * @example
     * // Update or create a Examen
     * const examen = await prisma.examen.upsert({
     *   create: {
     *     // ... data to create a Examen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Examen we want to update
     *   }
     * })
     */
    upsert<T extends ExamenUpsertArgs>(args: SelectSubset<T, ExamenUpsertArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenCountArgs} args - Arguments to filter Examen to count.
     * @example
     * // Count the number of Examen
     * const count = await prisma.examen.count({
     *   where: {
     *     // ... the filter for the Examen we want to count
     *   }
     * })
    **/
    count<T extends ExamenCountArgs>(
      args?: Subset<T, ExamenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamenAggregateArgs>(args: Subset<T, ExamenAggregateArgs>): Prisma.PrismaPromise<GetExamenAggregateType<T>>

    /**
     * Group by Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamenGroupByArgs['orderBy'] }
        : { orderBy?: ExamenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Examen model
   */
  readonly fields: ExamenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Examen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipo_examen<T extends Tipo_ExamenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_ExamenDefaultArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tipo_resultado<T extends Examen$tipo_resultadoArgs<ExtArgs> = {}>(args?: Subset<T, Examen$tipo_resultadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findMany"> | Null>
    paquete<T extends Examen$paqueteArgs<ExtArgs> = {}>(args?: Subset<T, Examen$paqueteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Examen model
   */ 
  interface ExamenFieldRefs {
    readonly id_examen: FieldRef<"Examen", 'Int'>
    readonly nombre: FieldRef<"Examen", 'String'>
    readonly unidades: FieldRef<"Examen", 'String'>
    readonly rango_biologico: FieldRef<"Examen", 'String'>
    readonly metodo: FieldRef<"Examen", 'String'>
    readonly precio: FieldRef<"Examen", 'Decimal'>
    readonly estado: FieldRef<"Examen", 'Estado'>
    readonly tipo_examenId: FieldRef<"Examen", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Examen findUnique
   */
  export type ExamenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where: ExamenWhereUniqueInput
  }

  /**
   * Examen findUniqueOrThrow
   */
  export type ExamenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where: ExamenWhereUniqueInput
  }

  /**
   * Examen findFirst
   */
  export type ExamenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where?: ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examen to fetch.
     */
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examen.
     */
    cursor?: ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examen.
     */
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * Examen findFirstOrThrow
   */
  export type ExamenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where?: ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examen to fetch.
     */
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examen.
     */
    cursor?: ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examen.
     */
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * Examen findMany
   */
  export type ExamenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Examen to fetch.
     */
    where?: ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examen to fetch.
     */
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Examen.
     */
    cursor?: ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examen.
     */
    skip?: number
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * Examen create
   */
  export type ExamenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * The data needed to create a Examen.
     */
    data: XOR<ExamenCreateInput, ExamenUncheckedCreateInput>
  }

  /**
   * Examen createMany
   */
  export type ExamenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Examen.
     */
    data: ExamenCreateManyInput | ExamenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Examen update
   */
  export type ExamenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * The data needed to update a Examen.
     */
    data: XOR<ExamenUpdateInput, ExamenUncheckedUpdateInput>
    /**
     * Choose, which Examen to update.
     */
    where: ExamenWhereUniqueInput
  }

  /**
   * Examen updateMany
   */
  export type ExamenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Examen.
     */
    data: XOR<ExamenUpdateManyMutationInput, ExamenUncheckedUpdateManyInput>
    /**
     * Filter which Examen to update
     */
    where?: ExamenWhereInput
  }

  /**
   * Examen upsert
   */
  export type ExamenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * The filter to search for the Examen to update in case it exists.
     */
    where: ExamenWhereUniqueInput
    /**
     * In case the Examen found by the `where` argument doesn't exist, create a new Examen with this data.
     */
    create: XOR<ExamenCreateInput, ExamenUncheckedCreateInput>
    /**
     * In case the Examen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamenUpdateInput, ExamenUncheckedUpdateInput>
  }

  /**
   * Examen delete
   */
  export type ExamenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    /**
     * Filter which Examen to delete.
     */
    where: ExamenWhereUniqueInput
  }

  /**
   * Examen deleteMany
   */
  export type ExamenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Examen to delete
     */
    where?: ExamenWhereInput
  }

  /**
   * Examen.tipo_resultado
   */
  export type Examen$tipo_resultadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    where?: Tipo_ResultadoWhereInput
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    cursor?: Tipo_ResultadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tipo_ResultadoScalarFieldEnum | Tipo_ResultadoScalarFieldEnum[]
  }

  /**
   * Examen.paquete
   */
  export type Examen$paqueteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    where?: PaqueteWhereInput
    orderBy?: PaqueteOrderByWithRelationInput | PaqueteOrderByWithRelationInput[]
    cursor?: PaqueteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaqueteScalarFieldEnum | PaqueteScalarFieldEnum[]
  }

  /**
   * Examen without action
   */
  export type ExamenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
  }


  /**
   * Model Tipo_Resultado
   */

  export type AggregateTipo_Resultado = {
    _count: Tipo_ResultadoCountAggregateOutputType | null
    _avg: Tipo_ResultadoAvgAggregateOutputType | null
    _sum: Tipo_ResultadoSumAggregateOutputType | null
    _min: Tipo_ResultadoMinAggregateOutputType | null
    _max: Tipo_ResultadoMaxAggregateOutputType | null
  }

  export type Tipo_ResultadoAvgAggregateOutputType = {
    id_tipo_resultado: number | null
    examenId: number | null
  }

  export type Tipo_ResultadoSumAggregateOutputType = {
    id_tipo_resultado: number | null
    examenId: number | null
  }

  export type Tipo_ResultadoMinAggregateOutputType = {
    id_tipo_resultado: number | null
    nombre: string | null
    estado: $Enums.Estado | null
    examenId: number | null
  }

  export type Tipo_ResultadoMaxAggregateOutputType = {
    id_tipo_resultado: number | null
    nombre: string | null
    estado: $Enums.Estado | null
    examenId: number | null
  }

  export type Tipo_ResultadoCountAggregateOutputType = {
    id_tipo_resultado: number
    nombre: number
    estado: number
    examenId: number
    _all: number
  }


  export type Tipo_ResultadoAvgAggregateInputType = {
    id_tipo_resultado?: true
    examenId?: true
  }

  export type Tipo_ResultadoSumAggregateInputType = {
    id_tipo_resultado?: true
    examenId?: true
  }

  export type Tipo_ResultadoMinAggregateInputType = {
    id_tipo_resultado?: true
    nombre?: true
    estado?: true
    examenId?: true
  }

  export type Tipo_ResultadoMaxAggregateInputType = {
    id_tipo_resultado?: true
    nombre?: true
    estado?: true
    examenId?: true
  }

  export type Tipo_ResultadoCountAggregateInputType = {
    id_tipo_resultado?: true
    nombre?: true
    estado?: true
    examenId?: true
    _all?: true
  }

  export type Tipo_ResultadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Resultado to aggregate.
     */
    where?: Tipo_ResultadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Resultados to fetch.
     */
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tipo_ResultadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Resultados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Resultados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipo_Resultados
    **/
    _count?: true | Tipo_ResultadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_ResultadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_ResultadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_ResultadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_ResultadoMaxAggregateInputType
  }

  export type GetTipo_ResultadoAggregateType<T extends Tipo_ResultadoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_Resultado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_Resultado[P]>
      : GetScalarType<T[P], AggregateTipo_Resultado[P]>
  }




  export type Tipo_ResultadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ResultadoWhereInput
    orderBy?: Tipo_ResultadoOrderByWithAggregationInput | Tipo_ResultadoOrderByWithAggregationInput[]
    by: Tipo_ResultadoScalarFieldEnum[] | Tipo_ResultadoScalarFieldEnum
    having?: Tipo_ResultadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_ResultadoCountAggregateInputType | true
    _avg?: Tipo_ResultadoAvgAggregateInputType
    _sum?: Tipo_ResultadoSumAggregateInputType
    _min?: Tipo_ResultadoMinAggregateInputType
    _max?: Tipo_ResultadoMaxAggregateInputType
  }

  export type Tipo_ResultadoGroupByOutputType = {
    id_tipo_resultado: number
    nombre: string
    estado: $Enums.Estado
    examenId: number
    _count: Tipo_ResultadoCountAggregateOutputType | null
    _avg: Tipo_ResultadoAvgAggregateOutputType | null
    _sum: Tipo_ResultadoSumAggregateOutputType | null
    _min: Tipo_ResultadoMinAggregateOutputType | null
    _max: Tipo_ResultadoMaxAggregateOutputType | null
  }

  type GetTipo_ResultadoGroupByPayload<T extends Tipo_ResultadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_ResultadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_ResultadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_ResultadoGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_ResultadoGroupByOutputType[P]>
        }
      >
    >


  export type Tipo_ResultadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_resultado?: boolean
    nombre?: boolean
    estado?: boolean
    examenId?: boolean
    examen?: boolean | ExamenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_Resultado"]>


  export type Tipo_ResultadoSelectScalar = {
    id_tipo_resultado?: boolean
    nombre?: boolean
    estado?: boolean
    examenId?: boolean
  }

  export type Tipo_ResultadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examen?: boolean | ExamenDefaultArgs<ExtArgs>
  }

  export type $Tipo_ResultadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tipo_Resultado"
    objects: {
      examen: Prisma.$ExamenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_resultado: number
      nombre: string
      estado: $Enums.Estado
      examenId: number
    }, ExtArgs["result"]["tipo_Resultado"]>
    composites: {}
  }

  type Tipo_ResultadoGetPayload<S extends boolean | null | undefined | Tipo_ResultadoDefaultArgs> = $Result.GetResult<Prisma.$Tipo_ResultadoPayload, S>

  type Tipo_ResultadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tipo_ResultadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_ResultadoCountAggregateInputType | true
    }

  export interface Tipo_ResultadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tipo_Resultado'], meta: { name: 'Tipo_Resultado' } }
    /**
     * Find zero or one Tipo_Resultado that matches the filter.
     * @param {Tipo_ResultadoFindUniqueArgs} args - Arguments to find a Tipo_Resultado
     * @example
     * // Get one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tipo_ResultadoFindUniqueArgs>(args: SelectSubset<T, Tipo_ResultadoFindUniqueArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_Resultado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Tipo_ResultadoFindUniqueOrThrowArgs} args - Arguments to find a Tipo_Resultado
     * @example
     * // Get one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tipo_ResultadoFindUniqueOrThrowArgs>(args: SelectSubset<T, Tipo_ResultadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_Resultado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoFindFirstArgs} args - Arguments to find a Tipo_Resultado
     * @example
     * // Get one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tipo_ResultadoFindFirstArgs>(args?: SelectSubset<T, Tipo_ResultadoFindFirstArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_Resultado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoFindFirstOrThrowArgs} args - Arguments to find a Tipo_Resultado
     * @example
     * // Get one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tipo_ResultadoFindFirstOrThrowArgs>(args?: SelectSubset<T, Tipo_ResultadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_Resultados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_Resultados
     * const tipo_Resultados = await prisma.tipo_Resultado.findMany()
     * 
     * // Get first 10 Tipo_Resultados
     * const tipo_Resultados = await prisma.tipo_Resultado.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_resultado`
     * const tipo_ResultadoWithId_tipo_resultadoOnly = await prisma.tipo_Resultado.findMany({ select: { id_tipo_resultado: true } })
     * 
     */
    findMany<T extends Tipo_ResultadoFindManyArgs>(args?: SelectSubset<T, Tipo_ResultadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_Resultado.
     * @param {Tipo_ResultadoCreateArgs} args - Arguments to create a Tipo_Resultado.
     * @example
     * // Create one Tipo_Resultado
     * const Tipo_Resultado = await prisma.tipo_Resultado.create({
     *   data: {
     *     // ... data to create a Tipo_Resultado
     *   }
     * })
     * 
     */
    create<T extends Tipo_ResultadoCreateArgs>(args: SelectSubset<T, Tipo_ResultadoCreateArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_Resultados.
     * @param {Tipo_ResultadoCreateManyArgs} args - Arguments to create many Tipo_Resultados.
     * @example
     * // Create many Tipo_Resultados
     * const tipo_Resultado = await prisma.tipo_Resultado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tipo_ResultadoCreateManyArgs>(args?: SelectSubset<T, Tipo_ResultadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_Resultado.
     * @param {Tipo_ResultadoDeleteArgs} args - Arguments to delete one Tipo_Resultado.
     * @example
     * // Delete one Tipo_Resultado
     * const Tipo_Resultado = await prisma.tipo_Resultado.delete({
     *   where: {
     *     // ... filter to delete one Tipo_Resultado
     *   }
     * })
     * 
     */
    delete<T extends Tipo_ResultadoDeleteArgs>(args: SelectSubset<T, Tipo_ResultadoDeleteArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_Resultado.
     * @param {Tipo_ResultadoUpdateArgs} args - Arguments to update one Tipo_Resultado.
     * @example
     * // Update one Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tipo_ResultadoUpdateArgs>(args: SelectSubset<T, Tipo_ResultadoUpdateArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_Resultados.
     * @param {Tipo_ResultadoDeleteManyArgs} args - Arguments to filter Tipo_Resultados to delete.
     * @example
     * // Delete a few Tipo_Resultados
     * const { count } = await prisma.tipo_Resultado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tipo_ResultadoDeleteManyArgs>(args?: SelectSubset<T, Tipo_ResultadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_Resultados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_Resultados
     * const tipo_Resultado = await prisma.tipo_Resultado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tipo_ResultadoUpdateManyArgs>(args: SelectSubset<T, Tipo_ResultadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_Resultado.
     * @param {Tipo_ResultadoUpsertArgs} args - Arguments to update or create a Tipo_Resultado.
     * @example
     * // Update or create a Tipo_Resultado
     * const tipo_Resultado = await prisma.tipo_Resultado.upsert({
     *   create: {
     *     // ... data to create a Tipo_Resultado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_Resultado we want to update
     *   }
     * })
     */
    upsert<T extends Tipo_ResultadoUpsertArgs>(args: SelectSubset<T, Tipo_ResultadoUpsertArgs<ExtArgs>>): Prisma__Tipo_ResultadoClient<$Result.GetResult<Prisma.$Tipo_ResultadoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_Resultados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoCountArgs} args - Arguments to filter Tipo_Resultados to count.
     * @example
     * // Count the number of Tipo_Resultados
     * const count = await prisma.tipo_Resultado.count({
     *   where: {
     *     // ... the filter for the Tipo_Resultados we want to count
     *   }
     * })
    **/
    count<T extends Tipo_ResultadoCountArgs>(
      args?: Subset<T, Tipo_ResultadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_ResultadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_Resultado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_ResultadoAggregateArgs>(args: Subset<T, Tipo_ResultadoAggregateArgs>): Prisma.PrismaPromise<GetTipo_ResultadoAggregateType<T>>

    /**
     * Group by Tipo_Resultado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ResultadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_ResultadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_ResultadoGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_ResultadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_ResultadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_ResultadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tipo_Resultado model
   */
  readonly fields: Tipo_ResultadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo_Resultado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tipo_ResultadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examen<T extends ExamenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamenDefaultArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tipo_Resultado model
   */ 
  interface Tipo_ResultadoFieldRefs {
    readonly id_tipo_resultado: FieldRef<"Tipo_Resultado", 'Int'>
    readonly nombre: FieldRef<"Tipo_Resultado", 'String'>
    readonly estado: FieldRef<"Tipo_Resultado", 'Estado'>
    readonly examenId: FieldRef<"Tipo_Resultado", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tipo_Resultado findUnique
   */
  export type Tipo_ResultadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultado to fetch.
     */
    where: Tipo_ResultadoWhereUniqueInput
  }

  /**
   * Tipo_Resultado findUniqueOrThrow
   */
  export type Tipo_ResultadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultado to fetch.
     */
    where: Tipo_ResultadoWhereUniqueInput
  }

  /**
   * Tipo_Resultado findFirst
   */
  export type Tipo_ResultadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultado to fetch.
     */
    where?: Tipo_ResultadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Resultados to fetch.
     */
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Resultados.
     */
    cursor?: Tipo_ResultadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Resultados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Resultados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Resultados.
     */
    distinct?: Tipo_ResultadoScalarFieldEnum | Tipo_ResultadoScalarFieldEnum[]
  }

  /**
   * Tipo_Resultado findFirstOrThrow
   */
  export type Tipo_ResultadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultado to fetch.
     */
    where?: Tipo_ResultadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Resultados to fetch.
     */
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Resultados.
     */
    cursor?: Tipo_ResultadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Resultados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Resultados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Resultados.
     */
    distinct?: Tipo_ResultadoScalarFieldEnum | Tipo_ResultadoScalarFieldEnum[]
  }

  /**
   * Tipo_Resultado findMany
   */
  export type Tipo_ResultadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Resultados to fetch.
     */
    where?: Tipo_ResultadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Resultados to fetch.
     */
    orderBy?: Tipo_ResultadoOrderByWithRelationInput | Tipo_ResultadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipo_Resultados.
     */
    cursor?: Tipo_ResultadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Resultados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Resultados.
     */
    skip?: number
    distinct?: Tipo_ResultadoScalarFieldEnum | Tipo_ResultadoScalarFieldEnum[]
  }

  /**
   * Tipo_Resultado create
   */
  export type Tipo_ResultadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * The data needed to create a Tipo_Resultado.
     */
    data: XOR<Tipo_ResultadoCreateInput, Tipo_ResultadoUncheckedCreateInput>
  }

  /**
   * Tipo_Resultado createMany
   */
  export type Tipo_ResultadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tipo_Resultados.
     */
    data: Tipo_ResultadoCreateManyInput | Tipo_ResultadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tipo_Resultado update
   */
  export type Tipo_ResultadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * The data needed to update a Tipo_Resultado.
     */
    data: XOR<Tipo_ResultadoUpdateInput, Tipo_ResultadoUncheckedUpdateInput>
    /**
     * Choose, which Tipo_Resultado to update.
     */
    where: Tipo_ResultadoWhereUniqueInput
  }

  /**
   * Tipo_Resultado updateMany
   */
  export type Tipo_ResultadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tipo_Resultados.
     */
    data: XOR<Tipo_ResultadoUpdateManyMutationInput, Tipo_ResultadoUncheckedUpdateManyInput>
    /**
     * Filter which Tipo_Resultados to update
     */
    where?: Tipo_ResultadoWhereInput
  }

  /**
   * Tipo_Resultado upsert
   */
  export type Tipo_ResultadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * The filter to search for the Tipo_Resultado to update in case it exists.
     */
    where: Tipo_ResultadoWhereUniqueInput
    /**
     * In case the Tipo_Resultado found by the `where` argument doesn't exist, create a new Tipo_Resultado with this data.
     */
    create: XOR<Tipo_ResultadoCreateInput, Tipo_ResultadoUncheckedCreateInput>
    /**
     * In case the Tipo_Resultado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tipo_ResultadoUpdateInput, Tipo_ResultadoUncheckedUpdateInput>
  }

  /**
   * Tipo_Resultado delete
   */
  export type Tipo_ResultadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
    /**
     * Filter which Tipo_Resultado to delete.
     */
    where: Tipo_ResultadoWhereUniqueInput
  }

  /**
   * Tipo_Resultado deleteMany
   */
  export type Tipo_ResultadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Resultados to delete
     */
    where?: Tipo_ResultadoWhereInput
  }

  /**
   * Tipo_Resultado without action
   */
  export type Tipo_ResultadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Resultado
     */
    select?: Tipo_ResultadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ResultadoInclude<ExtArgs> | null
  }


  /**
   * Model Tipo_Examen
   */

  export type AggregateTipo_Examen = {
    _count: Tipo_ExamenCountAggregateOutputType | null
    _avg: Tipo_ExamenAvgAggregateOutputType | null
    _sum: Tipo_ExamenSumAggregateOutputType | null
    _min: Tipo_ExamenMinAggregateOutputType | null
    _max: Tipo_ExamenMaxAggregateOutputType | null
  }

  export type Tipo_ExamenAvgAggregateOutputType = {
    id_tipo_examen: number | null
  }

  export type Tipo_ExamenSumAggregateOutputType = {
    id_tipo_examen: number | null
  }

  export type Tipo_ExamenMinAggregateOutputType = {
    id_tipo_examen: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type Tipo_ExamenMaxAggregateOutputType = {
    id_tipo_examen: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type Tipo_ExamenCountAggregateOutputType = {
    id_tipo_examen: number
    nombre: number
    estado: number
    _all: number
  }


  export type Tipo_ExamenAvgAggregateInputType = {
    id_tipo_examen?: true
  }

  export type Tipo_ExamenSumAggregateInputType = {
    id_tipo_examen?: true
  }

  export type Tipo_ExamenMinAggregateInputType = {
    id_tipo_examen?: true
    nombre?: true
    estado?: true
  }

  export type Tipo_ExamenMaxAggregateInputType = {
    id_tipo_examen?: true
    nombre?: true
    estado?: true
  }

  export type Tipo_ExamenCountAggregateInputType = {
    id_tipo_examen?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type Tipo_ExamenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Examen to aggregate.
     */
    where?: Tipo_ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Examen to fetch.
     */
    orderBy?: Tipo_ExamenOrderByWithRelationInput | Tipo_ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tipo_ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tipo_Examen
    **/
    _count?: true | Tipo_ExamenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_ExamenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_ExamenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_ExamenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_ExamenMaxAggregateInputType
  }

  export type GetTipo_ExamenAggregateType<T extends Tipo_ExamenAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_Examen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_Examen[P]>
      : GetScalarType<T[P], AggregateTipo_Examen[P]>
  }




  export type Tipo_ExamenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tipo_ExamenWhereInput
    orderBy?: Tipo_ExamenOrderByWithAggregationInput | Tipo_ExamenOrderByWithAggregationInput[]
    by: Tipo_ExamenScalarFieldEnum[] | Tipo_ExamenScalarFieldEnum
    having?: Tipo_ExamenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_ExamenCountAggregateInputType | true
    _avg?: Tipo_ExamenAvgAggregateInputType
    _sum?: Tipo_ExamenSumAggregateInputType
    _min?: Tipo_ExamenMinAggregateInputType
    _max?: Tipo_ExamenMaxAggregateInputType
  }

  export type Tipo_ExamenGroupByOutputType = {
    id_tipo_examen: number
    nombre: string
    estado: $Enums.Estado
    _count: Tipo_ExamenCountAggregateOutputType | null
    _avg: Tipo_ExamenAvgAggregateOutputType | null
    _sum: Tipo_ExamenSumAggregateOutputType | null
    _min: Tipo_ExamenMinAggregateOutputType | null
    _max: Tipo_ExamenMaxAggregateOutputType | null
  }

  type GetTipo_ExamenGroupByPayload<T extends Tipo_ExamenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_ExamenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_ExamenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_ExamenGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_ExamenGroupByOutputType[P]>
        }
      >
    >


  export type Tipo_ExamenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_examen?: boolean
    nombre?: boolean
    estado?: boolean
    examen?: boolean | Tipo_Examen$examenArgs<ExtArgs>
    _count?: boolean | Tipo_ExamenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipo_Examen"]>


  export type Tipo_ExamenSelectScalar = {
    id_tipo_examen?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type Tipo_ExamenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examen?: boolean | Tipo_Examen$examenArgs<ExtArgs>
    _count?: boolean | Tipo_ExamenCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Tipo_ExamenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tipo_Examen"
    objects: {
      examen: Prisma.$ExamenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_examen: number
      nombre: string
      estado: $Enums.Estado
    }, ExtArgs["result"]["tipo_Examen"]>
    composites: {}
  }

  type Tipo_ExamenGetPayload<S extends boolean | null | undefined | Tipo_ExamenDefaultArgs> = $Result.GetResult<Prisma.$Tipo_ExamenPayload, S>

  type Tipo_ExamenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tipo_ExamenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tipo_ExamenCountAggregateInputType | true
    }

  export interface Tipo_ExamenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tipo_Examen'], meta: { name: 'Tipo_Examen' } }
    /**
     * Find zero or one Tipo_Examen that matches the filter.
     * @param {Tipo_ExamenFindUniqueArgs} args - Arguments to find a Tipo_Examen
     * @example
     * // Get one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tipo_ExamenFindUniqueArgs>(args: SelectSubset<T, Tipo_ExamenFindUniqueArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipo_Examen that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Tipo_ExamenFindUniqueOrThrowArgs} args - Arguments to find a Tipo_Examen
     * @example
     * // Get one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tipo_ExamenFindUniqueOrThrowArgs>(args: SelectSubset<T, Tipo_ExamenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipo_Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenFindFirstArgs} args - Arguments to find a Tipo_Examen
     * @example
     * // Get one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tipo_ExamenFindFirstArgs>(args?: SelectSubset<T, Tipo_ExamenFindFirstArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipo_Examen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenFindFirstOrThrowArgs} args - Arguments to find a Tipo_Examen
     * @example
     * // Get one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tipo_ExamenFindFirstOrThrowArgs>(args?: SelectSubset<T, Tipo_ExamenFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipo_Examen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findMany()
     * 
     * // Get first 10 Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_examen`
     * const tipo_ExamenWithId_tipo_examenOnly = await prisma.tipo_Examen.findMany({ select: { id_tipo_examen: true } })
     * 
     */
    findMany<T extends Tipo_ExamenFindManyArgs>(args?: SelectSubset<T, Tipo_ExamenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipo_Examen.
     * @param {Tipo_ExamenCreateArgs} args - Arguments to create a Tipo_Examen.
     * @example
     * // Create one Tipo_Examen
     * const Tipo_Examen = await prisma.tipo_Examen.create({
     *   data: {
     *     // ... data to create a Tipo_Examen
     *   }
     * })
     * 
     */
    create<T extends Tipo_ExamenCreateArgs>(args: SelectSubset<T, Tipo_ExamenCreateArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipo_Examen.
     * @param {Tipo_ExamenCreateManyArgs} args - Arguments to create many Tipo_Examen.
     * @example
     * // Create many Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tipo_ExamenCreateManyArgs>(args?: SelectSubset<T, Tipo_ExamenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_Examen.
     * @param {Tipo_ExamenDeleteArgs} args - Arguments to delete one Tipo_Examen.
     * @example
     * // Delete one Tipo_Examen
     * const Tipo_Examen = await prisma.tipo_Examen.delete({
     *   where: {
     *     // ... filter to delete one Tipo_Examen
     *   }
     * })
     * 
     */
    delete<T extends Tipo_ExamenDeleteArgs>(args: SelectSubset<T, Tipo_ExamenDeleteArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipo_Examen.
     * @param {Tipo_ExamenUpdateArgs} args - Arguments to update one Tipo_Examen.
     * @example
     * // Update one Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tipo_ExamenUpdateArgs>(args: SelectSubset<T, Tipo_ExamenUpdateArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipo_Examen.
     * @param {Tipo_ExamenDeleteManyArgs} args - Arguments to filter Tipo_Examen to delete.
     * @example
     * // Delete a few Tipo_Examen
     * const { count } = await prisma.tipo_Examen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tipo_ExamenDeleteManyArgs>(args?: SelectSubset<T, Tipo_ExamenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tipo_ExamenUpdateManyArgs>(args: SelectSubset<T, Tipo_ExamenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_Examen.
     * @param {Tipo_ExamenUpsertArgs} args - Arguments to update or create a Tipo_Examen.
     * @example
     * // Update or create a Tipo_Examen
     * const tipo_Examen = await prisma.tipo_Examen.upsert({
     *   create: {
     *     // ... data to create a Tipo_Examen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_Examen we want to update
     *   }
     * })
     */
    upsert<T extends Tipo_ExamenUpsertArgs>(args: SelectSubset<T, Tipo_ExamenUpsertArgs<ExtArgs>>): Prisma__Tipo_ExamenClient<$Result.GetResult<Prisma.$Tipo_ExamenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipo_Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenCountArgs} args - Arguments to filter Tipo_Examen to count.
     * @example
     * // Count the number of Tipo_Examen
     * const count = await prisma.tipo_Examen.count({
     *   where: {
     *     // ... the filter for the Tipo_Examen we want to count
     *   }
     * })
    **/
    count<T extends Tipo_ExamenCountArgs>(
      args?: Subset<T, Tipo_ExamenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_ExamenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_ExamenAggregateArgs>(args: Subset<T, Tipo_ExamenAggregateArgs>): Prisma.PrismaPromise<GetTipo_ExamenAggregateType<T>>

    /**
     * Group by Tipo_Examen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_ExamenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_ExamenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_ExamenGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_ExamenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_ExamenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_ExamenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tipo_Examen model
   */
  readonly fields: Tipo_ExamenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tipo_Examen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tipo_ExamenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examen<T extends Tipo_Examen$examenArgs<ExtArgs> = {}>(args?: Subset<T, Tipo_Examen$examenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tipo_Examen model
   */ 
  interface Tipo_ExamenFieldRefs {
    readonly id_tipo_examen: FieldRef<"Tipo_Examen", 'Int'>
    readonly nombre: FieldRef<"Tipo_Examen", 'String'>
    readonly estado: FieldRef<"Tipo_Examen", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Tipo_Examen findUnique
   */
  export type Tipo_ExamenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where: Tipo_ExamenWhereUniqueInput
  }

  /**
   * Tipo_Examen findUniqueOrThrow
   */
  export type Tipo_ExamenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where: Tipo_ExamenWhereUniqueInput
  }

  /**
   * Tipo_Examen findFirst
   */
  export type Tipo_ExamenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where?: Tipo_ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Examen to fetch.
     */
    orderBy?: Tipo_ExamenOrderByWithRelationInput | Tipo_ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Examen.
     */
    cursor?: Tipo_ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Examen.
     */
    distinct?: Tipo_ExamenScalarFieldEnum | Tipo_ExamenScalarFieldEnum[]
  }

  /**
   * Tipo_Examen findFirstOrThrow
   */
  export type Tipo_ExamenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where?: Tipo_ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Examen to fetch.
     */
    orderBy?: Tipo_ExamenOrderByWithRelationInput | Tipo_ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tipo_Examen.
     */
    cursor?: Tipo_ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Examen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tipo_Examen.
     */
    distinct?: Tipo_ExamenScalarFieldEnum | Tipo_ExamenScalarFieldEnum[]
  }

  /**
   * Tipo_Examen findMany
   */
  export type Tipo_ExamenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter, which Tipo_Examen to fetch.
     */
    where?: Tipo_ExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tipo_Examen to fetch.
     */
    orderBy?: Tipo_ExamenOrderByWithRelationInput | Tipo_ExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tipo_Examen.
     */
    cursor?: Tipo_ExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tipo_Examen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tipo_Examen.
     */
    skip?: number
    distinct?: Tipo_ExamenScalarFieldEnum | Tipo_ExamenScalarFieldEnum[]
  }

  /**
   * Tipo_Examen create
   */
  export type Tipo_ExamenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * The data needed to create a Tipo_Examen.
     */
    data: XOR<Tipo_ExamenCreateInput, Tipo_ExamenUncheckedCreateInput>
  }

  /**
   * Tipo_Examen createMany
   */
  export type Tipo_ExamenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tipo_Examen.
     */
    data: Tipo_ExamenCreateManyInput | Tipo_ExamenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tipo_Examen update
   */
  export type Tipo_ExamenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * The data needed to update a Tipo_Examen.
     */
    data: XOR<Tipo_ExamenUpdateInput, Tipo_ExamenUncheckedUpdateInput>
    /**
     * Choose, which Tipo_Examen to update.
     */
    where: Tipo_ExamenWhereUniqueInput
  }

  /**
   * Tipo_Examen updateMany
   */
  export type Tipo_ExamenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tipo_Examen.
     */
    data: XOR<Tipo_ExamenUpdateManyMutationInput, Tipo_ExamenUncheckedUpdateManyInput>
    /**
     * Filter which Tipo_Examen to update
     */
    where?: Tipo_ExamenWhereInput
  }

  /**
   * Tipo_Examen upsert
   */
  export type Tipo_ExamenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * The filter to search for the Tipo_Examen to update in case it exists.
     */
    where: Tipo_ExamenWhereUniqueInput
    /**
     * In case the Tipo_Examen found by the `where` argument doesn't exist, create a new Tipo_Examen with this data.
     */
    create: XOR<Tipo_ExamenCreateInput, Tipo_ExamenUncheckedCreateInput>
    /**
     * In case the Tipo_Examen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tipo_ExamenUpdateInput, Tipo_ExamenUncheckedUpdateInput>
  }

  /**
   * Tipo_Examen delete
   */
  export type Tipo_ExamenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
    /**
     * Filter which Tipo_Examen to delete.
     */
    where: Tipo_ExamenWhereUniqueInput
  }

  /**
   * Tipo_Examen deleteMany
   */
  export type Tipo_ExamenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tipo_Examen to delete
     */
    where?: Tipo_ExamenWhereInput
  }

  /**
   * Tipo_Examen.examen
   */
  export type Tipo_Examen$examenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examen
     */
    select?: ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamenInclude<ExtArgs> | null
    where?: ExamenWhereInput
    orderBy?: ExamenOrderByWithRelationInput | ExamenOrderByWithRelationInput[]
    cursor?: ExamenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamenScalarFieldEnum | ExamenScalarFieldEnum[]
  }

  /**
   * Tipo_Examen without action
   */
  export type Tipo_ExamenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tipo_Examen
     */
    select?: Tipo_ExamenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tipo_ExamenInclude<ExtArgs> | null
  }


  /**
   * Model Prestador
   */

  export type AggregatePrestador = {
    _count: PrestadorCountAggregateOutputType | null
    _avg: PrestadorAvgAggregateOutputType | null
    _sum: PrestadorSumAggregateOutputType | null
    _min: PrestadorMinAggregateOutputType | null
    _max: PrestadorMaxAggregateOutputType | null
  }

  export type PrestadorAvgAggregateOutputType = {
    id_prestador: number | null
  }

  export type PrestadorSumAggregateOutputType = {
    id_prestador: number | null
  }

  export type PrestadorMinAggregateOutputType = {
    id_prestador: number | null
    codigo: string | null
    nit: string | null
    razon_social: string | null
  }

  export type PrestadorMaxAggregateOutputType = {
    id_prestador: number | null
    codigo: string | null
    nit: string | null
    razon_social: string | null
  }

  export type PrestadorCountAggregateOutputType = {
    id_prestador: number
    codigo: number
    nit: number
    razon_social: number
    _all: number
  }


  export type PrestadorAvgAggregateInputType = {
    id_prestador?: true
  }

  export type PrestadorSumAggregateInputType = {
    id_prestador?: true
  }

  export type PrestadorMinAggregateInputType = {
    id_prestador?: true
    codigo?: true
    nit?: true
    razon_social?: true
  }

  export type PrestadorMaxAggregateInputType = {
    id_prestador?: true
    codigo?: true
    nit?: true
    razon_social?: true
  }

  export type PrestadorCountAggregateInputType = {
    id_prestador?: true
    codigo?: true
    nit?: true
    razon_social?: true
    _all?: true
  }

  export type PrestadorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prestador to aggregate.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prestadors
    **/
    _count?: true | PrestadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrestadorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrestadorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrestadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrestadorMaxAggregateInputType
  }

  export type GetPrestadorAggregateType<T extends PrestadorAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestador[P]>
      : GetScalarType<T[P], AggregatePrestador[P]>
  }




  export type PrestadorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrestadorWhereInput
    orderBy?: PrestadorOrderByWithAggregationInput | PrestadorOrderByWithAggregationInput[]
    by: PrestadorScalarFieldEnum[] | PrestadorScalarFieldEnum
    having?: PrestadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrestadorCountAggregateInputType | true
    _avg?: PrestadorAvgAggregateInputType
    _sum?: PrestadorSumAggregateInputType
    _min?: PrestadorMinAggregateInputType
    _max?: PrestadorMaxAggregateInputType
  }

  export type PrestadorGroupByOutputType = {
    id_prestador: number
    codigo: string
    nit: string
    razon_social: string
    _count: PrestadorCountAggregateOutputType | null
    _avg: PrestadorAvgAggregateOutputType | null
    _sum: PrestadorSumAggregateOutputType | null
    _min: PrestadorMinAggregateOutputType | null
    _max: PrestadorMaxAggregateOutputType | null
  }

  type GetPrestadorGroupByPayload<T extends PrestadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrestadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrestadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrestadorGroupByOutputType[P]>
            : GetScalarType<T[P], PrestadorGroupByOutputType[P]>
        }
      >
    >


  export type PrestadorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_prestador?: boolean
    codigo?: boolean
    nit?: boolean
    razon_social?: boolean
    servicio?: boolean | Prestador$servicioArgs<ExtArgs>
    usuario?: boolean | Prestador$usuarioArgs<ExtArgs>
    _count?: boolean | PrestadorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prestador"]>


  export type PrestadorSelectScalar = {
    id_prestador?: boolean
    codigo?: boolean
    nit?: boolean
    razon_social?: boolean
  }

  export type PrestadorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Prestador$servicioArgs<ExtArgs>
    usuario?: boolean | Prestador$usuarioArgs<ExtArgs>
    _count?: boolean | PrestadorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PrestadorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prestador"
    objects: {
      servicio: Prisma.$ServicioPayload<ExtArgs>[]
      usuario: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_prestador: number
      codigo: string
      nit: string
      razon_social: string
    }, ExtArgs["result"]["prestador"]>
    composites: {}
  }

  type PrestadorGetPayload<S extends boolean | null | undefined | PrestadorDefaultArgs> = $Result.GetResult<Prisma.$PrestadorPayload, S>

  type PrestadorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrestadorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrestadorCountAggregateInputType | true
    }

  export interface PrestadorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prestador'], meta: { name: 'Prestador' } }
    /**
     * Find zero or one Prestador that matches the filter.
     * @param {PrestadorFindUniqueArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrestadorFindUniqueArgs>(args: SelectSubset<T, PrestadorFindUniqueArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prestador that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrestadorFindUniqueOrThrowArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrestadorFindUniqueOrThrowArgs>(args: SelectSubset<T, PrestadorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prestador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindFirstArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrestadorFindFirstArgs>(args?: SelectSubset<T, PrestadorFindFirstArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prestador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindFirstOrThrowArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrestadorFindFirstOrThrowArgs>(args?: SelectSubset<T, PrestadorFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prestadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prestadors
     * const prestadors = await prisma.prestador.findMany()
     * 
     * // Get first 10 Prestadors
     * const prestadors = await prisma.prestador.findMany({ take: 10 })
     * 
     * // Only select the `id_prestador`
     * const prestadorWithId_prestadorOnly = await prisma.prestador.findMany({ select: { id_prestador: true } })
     * 
     */
    findMany<T extends PrestadorFindManyArgs>(args?: SelectSubset<T, PrestadorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prestador.
     * @param {PrestadorCreateArgs} args - Arguments to create a Prestador.
     * @example
     * // Create one Prestador
     * const Prestador = await prisma.prestador.create({
     *   data: {
     *     // ... data to create a Prestador
     *   }
     * })
     * 
     */
    create<T extends PrestadorCreateArgs>(args: SelectSubset<T, PrestadorCreateArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prestadors.
     * @param {PrestadorCreateManyArgs} args - Arguments to create many Prestadors.
     * @example
     * // Create many Prestadors
     * const prestador = await prisma.prestador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrestadorCreateManyArgs>(args?: SelectSubset<T, PrestadorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prestador.
     * @param {PrestadorDeleteArgs} args - Arguments to delete one Prestador.
     * @example
     * // Delete one Prestador
     * const Prestador = await prisma.prestador.delete({
     *   where: {
     *     // ... filter to delete one Prestador
     *   }
     * })
     * 
     */
    delete<T extends PrestadorDeleteArgs>(args: SelectSubset<T, PrestadorDeleteArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prestador.
     * @param {PrestadorUpdateArgs} args - Arguments to update one Prestador.
     * @example
     * // Update one Prestador
     * const prestador = await prisma.prestador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrestadorUpdateArgs>(args: SelectSubset<T, PrestadorUpdateArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prestadors.
     * @param {PrestadorDeleteManyArgs} args - Arguments to filter Prestadors to delete.
     * @example
     * // Delete a few Prestadors
     * const { count } = await prisma.prestador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrestadorDeleteManyArgs>(args?: SelectSubset<T, PrestadorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prestadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prestadors
     * const prestador = await prisma.prestador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrestadorUpdateManyArgs>(args: SelectSubset<T, PrestadorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prestador.
     * @param {PrestadorUpsertArgs} args - Arguments to update or create a Prestador.
     * @example
     * // Update or create a Prestador
     * const prestador = await prisma.prestador.upsert({
     *   create: {
     *     // ... data to create a Prestador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prestador we want to update
     *   }
     * })
     */
    upsert<T extends PrestadorUpsertArgs>(args: SelectSubset<T, PrestadorUpsertArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prestadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorCountArgs} args - Arguments to filter Prestadors to count.
     * @example
     * // Count the number of Prestadors
     * const count = await prisma.prestador.count({
     *   where: {
     *     // ... the filter for the Prestadors we want to count
     *   }
     * })
    **/
    count<T extends PrestadorCountArgs>(
      args?: Subset<T, PrestadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrestadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prestador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrestadorAggregateArgs>(args: Subset<T, PrestadorAggregateArgs>): Prisma.PrismaPromise<GetPrestadorAggregateType<T>>

    /**
     * Group by Prestador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrestadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrestadorGroupByArgs['orderBy'] }
        : { orderBy?: PrestadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrestadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prestador model
   */
  readonly fields: PrestadorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prestador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrestadorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends Prestador$servicioArgs<ExtArgs> = {}>(args?: Subset<T, Prestador$servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany"> | Null>
    usuario<T extends Prestador$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Prestador$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prestador model
   */ 
  interface PrestadorFieldRefs {
    readonly id_prestador: FieldRef<"Prestador", 'Int'>
    readonly codigo: FieldRef<"Prestador", 'String'>
    readonly nit: FieldRef<"Prestador", 'String'>
    readonly razon_social: FieldRef<"Prestador", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prestador findUnique
   */
  export type PrestadorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador findUniqueOrThrow
   */
  export type PrestadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador findFirst
   */
  export type PrestadorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prestadors.
     */
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador findFirstOrThrow
   */
  export type PrestadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prestadors.
     */
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador findMany
   */
  export type PrestadorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestadors to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador create
   */
  export type PrestadorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The data needed to create a Prestador.
     */
    data: XOR<PrestadorCreateInput, PrestadorUncheckedCreateInput>
  }

  /**
   * Prestador createMany
   */
  export type PrestadorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prestadors.
     */
    data: PrestadorCreateManyInput | PrestadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prestador update
   */
  export type PrestadorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The data needed to update a Prestador.
     */
    data: XOR<PrestadorUpdateInput, PrestadorUncheckedUpdateInput>
    /**
     * Choose, which Prestador to update.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador updateMany
   */
  export type PrestadorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prestadors.
     */
    data: XOR<PrestadorUpdateManyMutationInput, PrestadorUncheckedUpdateManyInput>
    /**
     * Filter which Prestadors to update
     */
    where?: PrestadorWhereInput
  }

  /**
   * Prestador upsert
   */
  export type PrestadorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The filter to search for the Prestador to update in case it exists.
     */
    where: PrestadorWhereUniqueInput
    /**
     * In case the Prestador found by the `where` argument doesn't exist, create a new Prestador with this data.
     */
    create: XOR<PrestadorCreateInput, PrestadorUncheckedCreateInput>
    /**
     * In case the Prestador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrestadorUpdateInput, PrestadorUncheckedUpdateInput>
  }

  /**
   * Prestador delete
   */
  export type PrestadorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter which Prestador to delete.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador deleteMany
   */
  export type PrestadorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prestadors to delete
     */
    where?: PrestadorWhereInput
  }

  /**
   * Prestador.servicio
   */
  export type Prestador$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    cursor?: ServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Prestador.usuario
   */
  export type Prestador$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Prestador without action
   */
  export type PrestadorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id_usuario: number | null
    prestadorId: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id_usuario: number | null
    prestadorId: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id_usuario: number | null
    identificacion: string | null
    nombre: string | null
    cargo: string | null
    rol: $Enums.Rol | null
    email: string | null
    password: string | null
    estado: $Enums.Estado | null
    prestadorId: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id_usuario: number | null
    identificacion: string | null
    nombre: string | null
    cargo: string | null
    rol: $Enums.Rol | null
    email: string | null
    password: string | null
    estado: $Enums.Estado | null
    prestadorId: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id_usuario: number
    identificacion: number
    nombre: number
    cargo: number
    rol: number
    email: number
    password: number
    estado: number
    prestadorId: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id_usuario?: true
    prestadorId?: true
  }

  export type UsuarioSumAggregateInputType = {
    id_usuario?: true
    prestadorId?: true
  }

  export type UsuarioMinAggregateInputType = {
    id_usuario?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    email?: true
    password?: true
    estado?: true
    prestadorId?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id_usuario?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    email?: true
    password?: true
    estado?: true
    prestadorId?: true
  }

  export type UsuarioCountAggregateInputType = {
    id_usuario?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    email?: true
    password?: true
    estado?: true
    prestadorId?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id_usuario: number
    identificacion: string
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado: $Enums.Estado
    prestadorId: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    identificacion?: boolean
    nombre?: boolean
    cargo?: boolean
    rol?: boolean
    email?: boolean
    password?: boolean
    estado?: boolean
    prestadorId?: boolean
    prestador?: boolean | PrestadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type UsuarioSelectScalar = {
    id_usuario?: boolean
    identificacion?: boolean
    nombre?: boolean
    cargo?: boolean
    rol?: boolean
    email?: boolean
    password?: boolean
    estado?: boolean
    prestadorId?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prestador?: boolean | PrestadorDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      prestador: Prisma.$PrestadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      identificacion: string
      nombre: string
      cargo: string
      rol: $Enums.Rol
      email: string
      password: string
      estado: $Enums.Estado
      prestadorId: number
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prestador<T extends PrestadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrestadorDefaultArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id_usuario: FieldRef<"Usuario", 'Int'>
    readonly identificacion: FieldRef<"Usuario", 'String'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly cargo: FieldRef<"Usuario", 'String'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly password: FieldRef<"Usuario", 'String'>
    readonly estado: FieldRef<"Usuario", 'Estado'>
    readonly prestadorId: FieldRef<"Usuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaAvgAggregateOutputType = {
    id_empresa: number | null
    codigo: number | null
    municipioId: number | null
  }

  export type EmpresaSumAggregateOutputType = {
    id_empresa: number | null
    codigo: number | null
    municipioId: number | null
  }

  export type EmpresaMinAggregateOutputType = {
    id_empresa: number | null
    nit: string | null
    codigo: number | null
    nombre: string | null
    sigla: string | null
    tipo: $Enums.Tipo_Empresa | null
    estado: $Enums.Estado | null
    municipioId: number | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id_empresa: number | null
    nit: string | null
    codigo: number | null
    nombre: string | null
    sigla: string | null
    tipo: $Enums.Tipo_Empresa | null
    estado: $Enums.Estado | null
    municipioId: number | null
  }

  export type EmpresaCountAggregateOutputType = {
    id_empresa: number
    nit: number
    codigo: number
    nombre: number
    sigla: number
    tipo: number
    estado: number
    municipioId: number
    _all: number
  }


  export type EmpresaAvgAggregateInputType = {
    id_empresa?: true
    codigo?: true
    municipioId?: true
  }

  export type EmpresaSumAggregateInputType = {
    id_empresa?: true
    codigo?: true
    municipioId?: true
  }

  export type EmpresaMinAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipioId?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipioId?: true
  }

  export type EmpresaCountAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipioId?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresa to aggregate.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithAggregationInput | EmpresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: EmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _avg?: EmpresaAvgAggregateInputType
    _sum?: EmpresaSumAggregateInputType
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id_empresa: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipioId: number
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empresa?: boolean
    nit?: boolean
    codigo?: boolean
    nombre?: boolean
    sigla?: boolean
    tipo?: boolean
    estado?: boolean
    municipioId?: boolean
    municipio?: boolean | MunicipioDefaultArgs<ExtArgs>
    contrato?: boolean | Empresa$contratoArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>


  export type EmpresaSelectScalar = {
    id_empresa?: boolean
    nit?: boolean
    codigo?: boolean
    nombre?: boolean
    sigla?: boolean
    tipo?: boolean
    estado?: boolean
    municipioId?: boolean
  }

  export type EmpresaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | MunicipioDefaultArgs<ExtArgs>
    contrato?: boolean | Empresa$contratoArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmpresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empresa"
    objects: {
      municipio: Prisma.$MunicipioPayload<ExtArgs>
      contrato: Prisma.$ContratoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_empresa: number
      nit: string
      codigo: number
      nombre: string
      sigla: string
      tipo: $Enums.Tipo_Empresa
      estado: $Enums.Estado
      municipioId: number
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type EmpresaGetPayload<S extends boolean | null | undefined | EmpresaDefaultArgs> = $Result.GetResult<Prisma.$EmpresaPayload, S>

  type EmpresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface EmpresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empresa'], meta: { name: 'Empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {EmpresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaFindUniqueArgs>(args: SelectSubset<T, EmpresaFindUniqueArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaFindFirstArgs>(args?: SelectSubset<T, EmpresaFindFirstArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id_empresa`
     * const empresaWithId_empresaOnly = await prisma.empresa.findMany({ select: { id_empresa: true } })
     * 
     */
    findMany<T extends EmpresaFindManyArgs>(args?: SelectSubset<T, EmpresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empresa.
     * @param {EmpresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends EmpresaCreateArgs>(args: SelectSubset<T, EmpresaCreateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empresas.
     * @param {EmpresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaCreateManyArgs>(args?: SelectSubset<T, EmpresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empresa.
     * @param {EmpresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends EmpresaDeleteArgs>(args: SelectSubset<T, EmpresaDeleteArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empresa.
     * @param {EmpresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaUpdateArgs>(args: SelectSubset<T, EmpresaUpdateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {EmpresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaDeleteManyArgs>(args?: SelectSubset<T, EmpresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaUpdateManyArgs>(args: SelectSubset<T, EmpresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {EmpresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaUpsertArgs>(args: SelectSubset<T, EmpresaUpsertArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends EmpresaCountArgs>(
      args?: Subset<T, EmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empresa model
   */
  readonly fields: EmpresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipio<T extends MunicipioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipioDefaultArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contrato<T extends Empresa$contratoArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$contratoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empresa model
   */ 
  interface EmpresaFieldRefs {
    readonly id_empresa: FieldRef<"Empresa", 'Int'>
    readonly nit: FieldRef<"Empresa", 'String'>
    readonly codigo: FieldRef<"Empresa", 'Int'>
    readonly nombre: FieldRef<"Empresa", 'String'>
    readonly sigla: FieldRef<"Empresa", 'String'>
    readonly tipo: FieldRef<"Empresa", 'Tipo_Empresa'>
    readonly estado: FieldRef<"Empresa", 'Estado'>
    readonly municipioId: FieldRef<"Empresa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Empresa findUnique
   */
  export type EmpresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findUniqueOrThrow
   */
  export type EmpresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findFirst
   */
  export type EmpresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findFirstOrThrow
   */
  export type EmpresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findMany
   */
  export type EmpresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresas to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa create
   */
  export type EmpresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to create a Empresa.
     */
    data: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
  }

  /**
   * Empresa createMany
   */
  export type EmpresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa update
   */
  export type EmpresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to update a Empresa.
     */
    data: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
    /**
     * Choose, which Empresa to update.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa updateMany
   */
  export type EmpresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa upsert
   */
  export type EmpresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The filter to search for the Empresa to update in case it exists.
     */
    where: EmpresaWhereUniqueInput
    /**
     * In case the Empresa found by the `where` argument doesn't exist, create a new Empresa with this data.
     */
    create: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
    /**
     * In case the Empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
  }

  /**
   * Empresa delete
   */
  export type EmpresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter which Empresa to delete.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa deleteMany
   */
  export type EmpresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresas to delete
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa.contrato
   */
  export type Empresa$contratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    where?: ContratoWhereInput
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    cursor?: ContratoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Empresa without action
   */
  export type EmpresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
  }


  /**
   * Model Contrato
   */

  export type AggregateContrato = {
    _count: ContratoCountAggregateOutputType | null
    _avg: ContratoAvgAggregateOutputType | null
    _sum: ContratoSumAggregateOutputType | null
    _min: ContratoMinAggregateOutputType | null
    _max: ContratoMaxAggregateOutputType | null
  }

  export type ContratoAvgAggregateOutputType = {
    id_contrato: number | null
    empresaId: number | null
  }

  export type ContratoSumAggregateOutputType = {
    id_contrato: number | null
    empresaId: number | null
  }

  export type ContratoMinAggregateOutputType = {
    id_contrato: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: $Enums.Estado | null
    empresaId: number | null
  }

  export type ContratoMaxAggregateOutputType = {
    id_contrato: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: $Enums.Estado | null
    empresaId: number | null
  }

  export type ContratoCountAggregateOutputType = {
    id_contrato: number
    fecha_inicio: number
    fecha_fin: number
    estado: number
    empresaId: number
    _all: number
  }


  export type ContratoAvgAggregateInputType = {
    id_contrato?: true
    empresaId?: true
  }

  export type ContratoSumAggregateInputType = {
    id_contrato?: true
    empresaId?: true
  }

  export type ContratoMinAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresaId?: true
  }

  export type ContratoMaxAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresaId?: true
  }

  export type ContratoCountAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresaId?: true
    _all?: true
  }

  export type ContratoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contrato to aggregate.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contratoes
    **/
    _count?: true | ContratoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContratoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContratoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContratoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContratoMaxAggregateInputType
  }

  export type GetContratoAggregateType<T extends ContratoAggregateArgs> = {
        [P in keyof T & keyof AggregateContrato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContrato[P]>
      : GetScalarType<T[P], AggregateContrato[P]>
  }




  export type ContratoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratoWhereInput
    orderBy?: ContratoOrderByWithAggregationInput | ContratoOrderByWithAggregationInput[]
    by: ContratoScalarFieldEnum[] | ContratoScalarFieldEnum
    having?: ContratoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContratoCountAggregateInputType | true
    _avg?: ContratoAvgAggregateInputType
    _sum?: ContratoSumAggregateInputType
    _min?: ContratoMinAggregateInputType
    _max?: ContratoMaxAggregateInputType
  }

  export type ContratoGroupByOutputType = {
    id_contrato: number
    fecha_inicio: Date
    fecha_fin: Date
    estado: $Enums.Estado
    empresaId: number
    _count: ContratoCountAggregateOutputType | null
    _avg: ContratoAvgAggregateOutputType | null
    _sum: ContratoSumAggregateOutputType | null
    _min: ContratoMinAggregateOutputType | null
    _max: ContratoMaxAggregateOutputType | null
  }

  type GetContratoGroupByPayload<T extends ContratoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContratoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContratoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContratoGroupByOutputType[P]>
            : GetScalarType<T[P], ContratoGroupByOutputType[P]>
        }
      >
    >


  export type ContratoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_contrato?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empresaId?: boolean
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    acuerdo?: boolean | Contrato$acuerdoArgs<ExtArgs>
    _count?: boolean | ContratoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contrato"]>


  export type ContratoSelectScalar = {
    id_contrato?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empresaId?: boolean
  }

  export type ContratoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    acuerdo?: boolean | Contrato$acuerdoArgs<ExtArgs>
    _count?: boolean | ContratoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContratoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contrato"
    objects: {
      empresa: Prisma.$EmpresaPayload<ExtArgs>
      acuerdo: Prisma.$AcuerdoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_contrato: number
      fecha_inicio: Date
      fecha_fin: Date
      estado: $Enums.Estado
      empresaId: number
    }, ExtArgs["result"]["contrato"]>
    composites: {}
  }

  type ContratoGetPayload<S extends boolean | null | undefined | ContratoDefaultArgs> = $Result.GetResult<Prisma.$ContratoPayload, S>

  type ContratoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContratoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContratoCountAggregateInputType | true
    }

  export interface ContratoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contrato'], meta: { name: 'Contrato' } }
    /**
     * Find zero or one Contrato that matches the filter.
     * @param {ContratoFindUniqueArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContratoFindUniqueArgs>(args: SelectSubset<T, ContratoFindUniqueArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contrato that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContratoFindUniqueOrThrowArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContratoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContratoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contrato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindFirstArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContratoFindFirstArgs>(args?: SelectSubset<T, ContratoFindFirstArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contrato that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindFirstOrThrowArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContratoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContratoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contratoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contratoes
     * const contratoes = await prisma.contrato.findMany()
     * 
     * // Get first 10 Contratoes
     * const contratoes = await prisma.contrato.findMany({ take: 10 })
     * 
     * // Only select the `id_contrato`
     * const contratoWithId_contratoOnly = await prisma.contrato.findMany({ select: { id_contrato: true } })
     * 
     */
    findMany<T extends ContratoFindManyArgs>(args?: SelectSubset<T, ContratoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contrato.
     * @param {ContratoCreateArgs} args - Arguments to create a Contrato.
     * @example
     * // Create one Contrato
     * const Contrato = await prisma.contrato.create({
     *   data: {
     *     // ... data to create a Contrato
     *   }
     * })
     * 
     */
    create<T extends ContratoCreateArgs>(args: SelectSubset<T, ContratoCreateArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contratoes.
     * @param {ContratoCreateManyArgs} args - Arguments to create many Contratoes.
     * @example
     * // Create many Contratoes
     * const contrato = await prisma.contrato.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContratoCreateManyArgs>(args?: SelectSubset<T, ContratoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contrato.
     * @param {ContratoDeleteArgs} args - Arguments to delete one Contrato.
     * @example
     * // Delete one Contrato
     * const Contrato = await prisma.contrato.delete({
     *   where: {
     *     // ... filter to delete one Contrato
     *   }
     * })
     * 
     */
    delete<T extends ContratoDeleteArgs>(args: SelectSubset<T, ContratoDeleteArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contrato.
     * @param {ContratoUpdateArgs} args - Arguments to update one Contrato.
     * @example
     * // Update one Contrato
     * const contrato = await prisma.contrato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContratoUpdateArgs>(args: SelectSubset<T, ContratoUpdateArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contratoes.
     * @param {ContratoDeleteManyArgs} args - Arguments to filter Contratoes to delete.
     * @example
     * // Delete a few Contratoes
     * const { count } = await prisma.contrato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContratoDeleteManyArgs>(args?: SelectSubset<T, ContratoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contratoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contratoes
     * const contrato = await prisma.contrato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContratoUpdateManyArgs>(args: SelectSubset<T, ContratoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contrato.
     * @param {ContratoUpsertArgs} args - Arguments to update or create a Contrato.
     * @example
     * // Update or create a Contrato
     * const contrato = await prisma.contrato.upsert({
     *   create: {
     *     // ... data to create a Contrato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contrato we want to update
     *   }
     * })
     */
    upsert<T extends ContratoUpsertArgs>(args: SelectSubset<T, ContratoUpsertArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contratoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoCountArgs} args - Arguments to filter Contratoes to count.
     * @example
     * // Count the number of Contratoes
     * const count = await prisma.contrato.count({
     *   where: {
     *     // ... the filter for the Contratoes we want to count
     *   }
     * })
    **/
    count<T extends ContratoCountArgs>(
      args?: Subset<T, ContratoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContratoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contrato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContratoAggregateArgs>(args: Subset<T, ContratoAggregateArgs>): Prisma.PrismaPromise<GetContratoAggregateType<T>>

    /**
     * Group by Contrato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContratoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContratoGroupByArgs['orderBy'] }
        : { orderBy?: ContratoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContratoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContratoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contrato model
   */
  readonly fields: ContratoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contrato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContratoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    acuerdo<T extends Contrato$acuerdoArgs<ExtArgs> = {}>(args?: Subset<T, Contrato$acuerdoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contrato model
   */ 
  interface ContratoFieldRefs {
    readonly id_contrato: FieldRef<"Contrato", 'Int'>
    readonly fecha_inicio: FieldRef<"Contrato", 'DateTime'>
    readonly fecha_fin: FieldRef<"Contrato", 'DateTime'>
    readonly estado: FieldRef<"Contrato", 'Estado'>
    readonly empresaId: FieldRef<"Contrato", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Contrato findUnique
   */
  export type ContratoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato findUniqueOrThrow
   */
  export type ContratoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato findFirst
   */
  export type ContratoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contratoes.
     */
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato findFirstOrThrow
   */
  export type ContratoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contratoes.
     */
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato findMany
   */
  export type ContratoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contratoes to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato create
   */
  export type ContratoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The data needed to create a Contrato.
     */
    data: XOR<ContratoCreateInput, ContratoUncheckedCreateInput>
  }

  /**
   * Contrato createMany
   */
  export type ContratoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contratoes.
     */
    data: ContratoCreateManyInput | ContratoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contrato update
   */
  export type ContratoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The data needed to update a Contrato.
     */
    data: XOR<ContratoUpdateInput, ContratoUncheckedUpdateInput>
    /**
     * Choose, which Contrato to update.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato updateMany
   */
  export type ContratoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contratoes.
     */
    data: XOR<ContratoUpdateManyMutationInput, ContratoUncheckedUpdateManyInput>
    /**
     * Filter which Contratoes to update
     */
    where?: ContratoWhereInput
  }

  /**
   * Contrato upsert
   */
  export type ContratoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The filter to search for the Contrato to update in case it exists.
     */
    where: ContratoWhereUniqueInput
    /**
     * In case the Contrato found by the `where` argument doesn't exist, create a new Contrato with this data.
     */
    create: XOR<ContratoCreateInput, ContratoUncheckedCreateInput>
    /**
     * In case the Contrato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContratoUpdateInput, ContratoUncheckedUpdateInput>
  }

  /**
   * Contrato delete
   */
  export type ContratoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter which Contrato to delete.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato deleteMany
   */
  export type ContratoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contratoes to delete
     */
    where?: ContratoWhereInput
  }

  /**
   * Contrato.acuerdo
   */
  export type Contrato$acuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    where?: AcuerdoWhereInput
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    cursor?: AcuerdoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Contrato without action
   */
  export type ContratoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
  }


  /**
   * Model Acuerdo
   */

  export type AggregateAcuerdo = {
    _count: AcuerdoCountAggregateOutputType | null
    _avg: AcuerdoAvgAggregateOutputType | null
    _sum: AcuerdoSumAggregateOutputType | null
    _min: AcuerdoMinAggregateOutputType | null
    _max: AcuerdoMaxAggregateOutputType | null
  }

  export type AcuerdoAvgAggregateOutputType = {
    id_acuerdo: number | null
    precio: Decimal | null
    iva: Decimal | null
    contratoId: number | null
    servicioId: number | null
  }

  export type AcuerdoSumAggregateOutputType = {
    id_acuerdo: number | null
    precio: Decimal | null
    iva: Decimal | null
    contratoId: number | null
    servicioId: number | null
  }

  export type AcuerdoMinAggregateOutputType = {
    id_acuerdo: number | null
    estado: $Enums.Estado | null
    precio: Decimal | null
    iva: Decimal | null
    createAt: Date | null
    updateAt: Date | null
    contratoId: number | null
    servicioId: number | null
  }

  export type AcuerdoMaxAggregateOutputType = {
    id_acuerdo: number | null
    estado: $Enums.Estado | null
    precio: Decimal | null
    iva: Decimal | null
    createAt: Date | null
    updateAt: Date | null
    contratoId: number | null
    servicioId: number | null
  }

  export type AcuerdoCountAggregateOutputType = {
    id_acuerdo: number
    estado: number
    precio: number
    iva: number
    createAt: number
    updateAt: number
    contratoId: number
    servicioId: number
    _all: number
  }


  export type AcuerdoAvgAggregateInputType = {
    id_acuerdo?: true
    precio?: true
    iva?: true
    contratoId?: true
    servicioId?: true
  }

  export type AcuerdoSumAggregateInputType = {
    id_acuerdo?: true
    precio?: true
    iva?: true
    contratoId?: true
    servicioId?: true
  }

  export type AcuerdoMinAggregateInputType = {
    id_acuerdo?: true
    estado?: true
    precio?: true
    iva?: true
    createAt?: true
    updateAt?: true
    contratoId?: true
    servicioId?: true
  }

  export type AcuerdoMaxAggregateInputType = {
    id_acuerdo?: true
    estado?: true
    precio?: true
    iva?: true
    createAt?: true
    updateAt?: true
    contratoId?: true
    servicioId?: true
  }

  export type AcuerdoCountAggregateInputType = {
    id_acuerdo?: true
    estado?: true
    precio?: true
    iva?: true
    createAt?: true
    updateAt?: true
    contratoId?: true
    servicioId?: true
    _all?: true
  }

  export type AcuerdoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acuerdo to aggregate.
     */
    where?: AcuerdoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acuerdos to fetch.
     */
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcuerdoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acuerdos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acuerdos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Acuerdos
    **/
    _count?: true | AcuerdoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcuerdoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcuerdoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcuerdoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcuerdoMaxAggregateInputType
  }

  export type GetAcuerdoAggregateType<T extends AcuerdoAggregateArgs> = {
        [P in keyof T & keyof AggregateAcuerdo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcuerdo[P]>
      : GetScalarType<T[P], AggregateAcuerdo[P]>
  }




  export type AcuerdoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcuerdoWhereInput
    orderBy?: AcuerdoOrderByWithAggregationInput | AcuerdoOrderByWithAggregationInput[]
    by: AcuerdoScalarFieldEnum[] | AcuerdoScalarFieldEnum
    having?: AcuerdoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcuerdoCountAggregateInputType | true
    _avg?: AcuerdoAvgAggregateInputType
    _sum?: AcuerdoSumAggregateInputType
    _min?: AcuerdoMinAggregateInputType
    _max?: AcuerdoMaxAggregateInputType
  }

  export type AcuerdoGroupByOutputType = {
    id_acuerdo: number
    estado: $Enums.Estado
    precio: Decimal
    iva: Decimal
    createAt: Date
    updateAt: Date
    contratoId: number
    servicioId: number
    _count: AcuerdoCountAggregateOutputType | null
    _avg: AcuerdoAvgAggregateOutputType | null
    _sum: AcuerdoSumAggregateOutputType | null
    _min: AcuerdoMinAggregateOutputType | null
    _max: AcuerdoMaxAggregateOutputType | null
  }

  type GetAcuerdoGroupByPayload<T extends AcuerdoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcuerdoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcuerdoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcuerdoGroupByOutputType[P]>
            : GetScalarType<T[P], AcuerdoGroupByOutputType[P]>
        }
      >
    >


  export type AcuerdoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_acuerdo?: boolean
    estado?: boolean
    precio?: boolean
    iva?: boolean
    createAt?: boolean
    updateAt?: boolean
    contratoId?: boolean
    servicioId?: boolean
    procedimiento?: boolean | Acuerdo$procedimientoArgs<ExtArgs>
    contrato?: boolean | ContratoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
    _count?: boolean | AcuerdoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acuerdo"]>


  export type AcuerdoSelectScalar = {
    id_acuerdo?: boolean
    estado?: boolean
    precio?: boolean
    iva?: boolean
    createAt?: boolean
    updateAt?: boolean
    contratoId?: boolean
    servicioId?: boolean
  }

  export type AcuerdoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Acuerdo$procedimientoArgs<ExtArgs>
    contrato?: boolean | ContratoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
    _count?: boolean | AcuerdoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AcuerdoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Acuerdo"
    objects: {
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>[]
      contrato: Prisma.$ContratoPayload<ExtArgs>
      servicio: Prisma.$ServicioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_acuerdo: number
      estado: $Enums.Estado
      precio: Prisma.Decimal
      iva: Prisma.Decimal
      createAt: Date
      updateAt: Date
      contratoId: number
      servicioId: number
    }, ExtArgs["result"]["acuerdo"]>
    composites: {}
  }

  type AcuerdoGetPayload<S extends boolean | null | undefined | AcuerdoDefaultArgs> = $Result.GetResult<Prisma.$AcuerdoPayload, S>

  type AcuerdoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcuerdoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcuerdoCountAggregateInputType | true
    }

  export interface AcuerdoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Acuerdo'], meta: { name: 'Acuerdo' } }
    /**
     * Find zero or one Acuerdo that matches the filter.
     * @param {AcuerdoFindUniqueArgs} args - Arguments to find a Acuerdo
     * @example
     * // Get one Acuerdo
     * const acuerdo = await prisma.acuerdo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcuerdoFindUniqueArgs>(args: SelectSubset<T, AcuerdoFindUniqueArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Acuerdo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcuerdoFindUniqueOrThrowArgs} args - Arguments to find a Acuerdo
     * @example
     * // Get one Acuerdo
     * const acuerdo = await prisma.acuerdo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcuerdoFindUniqueOrThrowArgs>(args: SelectSubset<T, AcuerdoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Acuerdo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoFindFirstArgs} args - Arguments to find a Acuerdo
     * @example
     * // Get one Acuerdo
     * const acuerdo = await prisma.acuerdo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcuerdoFindFirstArgs>(args?: SelectSubset<T, AcuerdoFindFirstArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Acuerdo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoFindFirstOrThrowArgs} args - Arguments to find a Acuerdo
     * @example
     * // Get one Acuerdo
     * const acuerdo = await prisma.acuerdo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcuerdoFindFirstOrThrowArgs>(args?: SelectSubset<T, AcuerdoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Acuerdos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Acuerdos
     * const acuerdos = await prisma.acuerdo.findMany()
     * 
     * // Get first 10 Acuerdos
     * const acuerdos = await prisma.acuerdo.findMany({ take: 10 })
     * 
     * // Only select the `id_acuerdo`
     * const acuerdoWithId_acuerdoOnly = await prisma.acuerdo.findMany({ select: { id_acuerdo: true } })
     * 
     */
    findMany<T extends AcuerdoFindManyArgs>(args?: SelectSubset<T, AcuerdoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Acuerdo.
     * @param {AcuerdoCreateArgs} args - Arguments to create a Acuerdo.
     * @example
     * // Create one Acuerdo
     * const Acuerdo = await prisma.acuerdo.create({
     *   data: {
     *     // ... data to create a Acuerdo
     *   }
     * })
     * 
     */
    create<T extends AcuerdoCreateArgs>(args: SelectSubset<T, AcuerdoCreateArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Acuerdos.
     * @param {AcuerdoCreateManyArgs} args - Arguments to create many Acuerdos.
     * @example
     * // Create many Acuerdos
     * const acuerdo = await prisma.acuerdo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcuerdoCreateManyArgs>(args?: SelectSubset<T, AcuerdoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Acuerdo.
     * @param {AcuerdoDeleteArgs} args - Arguments to delete one Acuerdo.
     * @example
     * // Delete one Acuerdo
     * const Acuerdo = await prisma.acuerdo.delete({
     *   where: {
     *     // ... filter to delete one Acuerdo
     *   }
     * })
     * 
     */
    delete<T extends AcuerdoDeleteArgs>(args: SelectSubset<T, AcuerdoDeleteArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Acuerdo.
     * @param {AcuerdoUpdateArgs} args - Arguments to update one Acuerdo.
     * @example
     * // Update one Acuerdo
     * const acuerdo = await prisma.acuerdo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcuerdoUpdateArgs>(args: SelectSubset<T, AcuerdoUpdateArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Acuerdos.
     * @param {AcuerdoDeleteManyArgs} args - Arguments to filter Acuerdos to delete.
     * @example
     * // Delete a few Acuerdos
     * const { count } = await prisma.acuerdo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcuerdoDeleteManyArgs>(args?: SelectSubset<T, AcuerdoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Acuerdos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Acuerdos
     * const acuerdo = await prisma.acuerdo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcuerdoUpdateManyArgs>(args: SelectSubset<T, AcuerdoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Acuerdo.
     * @param {AcuerdoUpsertArgs} args - Arguments to update or create a Acuerdo.
     * @example
     * // Update or create a Acuerdo
     * const acuerdo = await prisma.acuerdo.upsert({
     *   create: {
     *     // ... data to create a Acuerdo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Acuerdo we want to update
     *   }
     * })
     */
    upsert<T extends AcuerdoUpsertArgs>(args: SelectSubset<T, AcuerdoUpsertArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Acuerdos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoCountArgs} args - Arguments to filter Acuerdos to count.
     * @example
     * // Count the number of Acuerdos
     * const count = await prisma.acuerdo.count({
     *   where: {
     *     // ... the filter for the Acuerdos we want to count
     *   }
     * })
    **/
    count<T extends AcuerdoCountArgs>(
      args?: Subset<T, AcuerdoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcuerdoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Acuerdo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcuerdoAggregateArgs>(args: Subset<T, AcuerdoAggregateArgs>): Prisma.PrismaPromise<GetAcuerdoAggregateType<T>>

    /**
     * Group by Acuerdo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcuerdoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcuerdoGroupByArgs['orderBy'] }
        : { orderBy?: AcuerdoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcuerdoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcuerdoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Acuerdo model
   */
  readonly fields: AcuerdoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Acuerdo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcuerdoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedimiento<T extends Acuerdo$procedimientoArgs<ExtArgs> = {}>(args?: Subset<T, Acuerdo$procedimientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany"> | Null>
    contrato<T extends ContratoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContratoDefaultArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    servicio<T extends ServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicioDefaultArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Acuerdo model
   */ 
  interface AcuerdoFieldRefs {
    readonly id_acuerdo: FieldRef<"Acuerdo", 'Int'>
    readonly estado: FieldRef<"Acuerdo", 'Estado'>
    readonly precio: FieldRef<"Acuerdo", 'Decimal'>
    readonly iva: FieldRef<"Acuerdo", 'Decimal'>
    readonly createAt: FieldRef<"Acuerdo", 'DateTime'>
    readonly updateAt: FieldRef<"Acuerdo", 'DateTime'>
    readonly contratoId: FieldRef<"Acuerdo", 'Int'>
    readonly servicioId: FieldRef<"Acuerdo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Acuerdo findUnique
   */
  export type AcuerdoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdo to fetch.
     */
    where: AcuerdoWhereUniqueInput
  }

  /**
   * Acuerdo findUniqueOrThrow
   */
  export type AcuerdoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdo to fetch.
     */
    where: AcuerdoWhereUniqueInput
  }

  /**
   * Acuerdo findFirst
   */
  export type AcuerdoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdo to fetch.
     */
    where?: AcuerdoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acuerdos to fetch.
     */
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Acuerdos.
     */
    cursor?: AcuerdoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acuerdos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acuerdos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Acuerdos.
     */
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Acuerdo findFirstOrThrow
   */
  export type AcuerdoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdo to fetch.
     */
    where?: AcuerdoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acuerdos to fetch.
     */
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Acuerdos.
     */
    cursor?: AcuerdoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acuerdos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acuerdos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Acuerdos.
     */
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Acuerdo findMany
   */
  export type AcuerdoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdos to fetch.
     */
    where?: AcuerdoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acuerdos to fetch.
     */
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Acuerdos.
     */
    cursor?: AcuerdoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acuerdos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acuerdos.
     */
    skip?: number
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Acuerdo create
   */
  export type AcuerdoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * The data needed to create a Acuerdo.
     */
    data: XOR<AcuerdoCreateInput, AcuerdoUncheckedCreateInput>
  }

  /**
   * Acuerdo createMany
   */
  export type AcuerdoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Acuerdos.
     */
    data: AcuerdoCreateManyInput | AcuerdoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Acuerdo update
   */
  export type AcuerdoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * The data needed to update a Acuerdo.
     */
    data: XOR<AcuerdoUpdateInput, AcuerdoUncheckedUpdateInput>
    /**
     * Choose, which Acuerdo to update.
     */
    where: AcuerdoWhereUniqueInput
  }

  /**
   * Acuerdo updateMany
   */
  export type AcuerdoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Acuerdos.
     */
    data: XOR<AcuerdoUpdateManyMutationInput, AcuerdoUncheckedUpdateManyInput>
    /**
     * Filter which Acuerdos to update
     */
    where?: AcuerdoWhereInput
  }

  /**
   * Acuerdo upsert
   */
  export type AcuerdoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * The filter to search for the Acuerdo to update in case it exists.
     */
    where: AcuerdoWhereUniqueInput
    /**
     * In case the Acuerdo found by the `where` argument doesn't exist, create a new Acuerdo with this data.
     */
    create: XOR<AcuerdoCreateInput, AcuerdoUncheckedCreateInput>
    /**
     * In case the Acuerdo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcuerdoUpdateInput, AcuerdoUncheckedUpdateInput>
  }

  /**
   * Acuerdo delete
   */
  export type AcuerdoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter which Acuerdo to delete.
     */
    where: AcuerdoWhereUniqueInput
  }

  /**
   * Acuerdo deleteMany
   */
  export type AcuerdoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acuerdos to delete
     */
    where?: AcuerdoWhereInput
  }

  /**
   * Acuerdo.procedimiento
   */
  export type Acuerdo$procedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    cursor?: ProcedimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Acuerdo without action
   */
  export type AcuerdoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
  }


  /**
   * Model Paquete
   */

  export type AggregatePaquete = {
    _count: PaqueteCountAggregateOutputType | null
    _avg: PaqueteAvgAggregateOutputType | null
    _sum: PaqueteSumAggregateOutputType | null
    _min: PaqueteMinAggregateOutputType | null
    _max: PaqueteMaxAggregateOutputType | null
  }

  export type PaqueteAvgAggregateOutputType = {
    id_paquete: number | null
    examenId: number | null
    servicioId: number | null
  }

  export type PaqueteSumAggregateOutputType = {
    id_paquete: number | null
    examenId: number | null
    servicioId: number | null
  }

  export type PaqueteMinAggregateOutputType = {
    id_paquete: number | null
    estado: $Enums.Estado | null
    examenId: number | null
    servicioId: number | null
  }

  export type PaqueteMaxAggregateOutputType = {
    id_paquete: number | null
    estado: $Enums.Estado | null
    examenId: number | null
    servicioId: number | null
  }

  export type PaqueteCountAggregateOutputType = {
    id_paquete: number
    estado: number
    examenId: number
    servicioId: number
    _all: number
  }


  export type PaqueteAvgAggregateInputType = {
    id_paquete?: true
    examenId?: true
    servicioId?: true
  }

  export type PaqueteSumAggregateInputType = {
    id_paquete?: true
    examenId?: true
    servicioId?: true
  }

  export type PaqueteMinAggregateInputType = {
    id_paquete?: true
    estado?: true
    examenId?: true
    servicioId?: true
  }

  export type PaqueteMaxAggregateInputType = {
    id_paquete?: true
    estado?: true
    examenId?: true
    servicioId?: true
  }

  export type PaqueteCountAggregateInputType = {
    id_paquete?: true
    estado?: true
    examenId?: true
    servicioId?: true
    _all?: true
  }

  export type PaqueteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paquete to aggregate.
     */
    where?: PaqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paquetes to fetch.
     */
    orderBy?: PaqueteOrderByWithRelationInput | PaqueteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paquetes
    **/
    _count?: true | PaqueteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaqueteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaqueteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaqueteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaqueteMaxAggregateInputType
  }

  export type GetPaqueteAggregateType<T extends PaqueteAggregateArgs> = {
        [P in keyof T & keyof AggregatePaquete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaquete[P]>
      : GetScalarType<T[P], AggregatePaquete[P]>
  }




  export type PaqueteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteWhereInput
    orderBy?: PaqueteOrderByWithAggregationInput | PaqueteOrderByWithAggregationInput[]
    by: PaqueteScalarFieldEnum[] | PaqueteScalarFieldEnum
    having?: PaqueteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaqueteCountAggregateInputType | true
    _avg?: PaqueteAvgAggregateInputType
    _sum?: PaqueteSumAggregateInputType
    _min?: PaqueteMinAggregateInputType
    _max?: PaqueteMaxAggregateInputType
  }

  export type PaqueteGroupByOutputType = {
    id_paquete: number
    estado: $Enums.Estado
    examenId: number
    servicioId: number
    _count: PaqueteCountAggregateOutputType | null
    _avg: PaqueteAvgAggregateOutputType | null
    _sum: PaqueteSumAggregateOutputType | null
    _min: PaqueteMinAggregateOutputType | null
    _max: PaqueteMaxAggregateOutputType | null
  }

  type GetPaqueteGroupByPayload<T extends PaqueteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaqueteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaqueteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaqueteGroupByOutputType[P]>
            : GetScalarType<T[P], PaqueteGroupByOutputType[P]>
        }
      >
    >


  export type PaqueteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paquete?: boolean
    estado?: boolean
    examenId?: boolean
    servicioId?: boolean
    estudio?: boolean | Paquete$estudioArgs<ExtArgs>
    examen?: boolean | ExamenDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
    _count?: boolean | PaqueteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paquete"]>


  export type PaqueteSelectScalar = {
    id_paquete?: boolean
    estado?: boolean
    examenId?: boolean
    servicioId?: boolean
  }

  export type PaqueteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudio?: boolean | Paquete$estudioArgs<ExtArgs>
    examen?: boolean | ExamenDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
    _count?: boolean | PaqueteCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PaquetePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paquete"
    objects: {
      estudio: Prisma.$EstudioPayload<ExtArgs>[]
      examen: Prisma.$ExamenPayload<ExtArgs>
      servicio: Prisma.$ServicioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_paquete: number
      estado: $Enums.Estado
      examenId: number
      servicioId: number
    }, ExtArgs["result"]["paquete"]>
    composites: {}
  }

  type PaqueteGetPayload<S extends boolean | null | undefined | PaqueteDefaultArgs> = $Result.GetResult<Prisma.$PaquetePayload, S>

  type PaqueteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaqueteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaqueteCountAggregateInputType | true
    }

  export interface PaqueteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paquete'], meta: { name: 'Paquete' } }
    /**
     * Find zero or one Paquete that matches the filter.
     * @param {PaqueteFindUniqueArgs} args - Arguments to find a Paquete
     * @example
     * // Get one Paquete
     * const paquete = await prisma.paquete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaqueteFindUniqueArgs>(args: SelectSubset<T, PaqueteFindUniqueArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Paquete that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaqueteFindUniqueOrThrowArgs} args - Arguments to find a Paquete
     * @example
     * // Get one Paquete
     * const paquete = await prisma.paquete.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaqueteFindUniqueOrThrowArgs>(args: SelectSubset<T, PaqueteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Paquete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteFindFirstArgs} args - Arguments to find a Paquete
     * @example
     * // Get one Paquete
     * const paquete = await prisma.paquete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaqueteFindFirstArgs>(args?: SelectSubset<T, PaqueteFindFirstArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Paquete that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteFindFirstOrThrowArgs} args - Arguments to find a Paquete
     * @example
     * // Get one Paquete
     * const paquete = await prisma.paquete.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaqueteFindFirstOrThrowArgs>(args?: SelectSubset<T, PaqueteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Paquetes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paquetes
     * const paquetes = await prisma.paquete.findMany()
     * 
     * // Get first 10 Paquetes
     * const paquetes = await prisma.paquete.findMany({ take: 10 })
     * 
     * // Only select the `id_paquete`
     * const paqueteWithId_paqueteOnly = await prisma.paquete.findMany({ select: { id_paquete: true } })
     * 
     */
    findMany<T extends PaqueteFindManyArgs>(args?: SelectSubset<T, PaqueteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Paquete.
     * @param {PaqueteCreateArgs} args - Arguments to create a Paquete.
     * @example
     * // Create one Paquete
     * const Paquete = await prisma.paquete.create({
     *   data: {
     *     // ... data to create a Paquete
     *   }
     * })
     * 
     */
    create<T extends PaqueteCreateArgs>(args: SelectSubset<T, PaqueteCreateArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Paquetes.
     * @param {PaqueteCreateManyArgs} args - Arguments to create many Paquetes.
     * @example
     * // Create many Paquetes
     * const paquete = await prisma.paquete.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaqueteCreateManyArgs>(args?: SelectSubset<T, PaqueteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Paquete.
     * @param {PaqueteDeleteArgs} args - Arguments to delete one Paquete.
     * @example
     * // Delete one Paquete
     * const Paquete = await prisma.paquete.delete({
     *   where: {
     *     // ... filter to delete one Paquete
     *   }
     * })
     * 
     */
    delete<T extends PaqueteDeleteArgs>(args: SelectSubset<T, PaqueteDeleteArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Paquete.
     * @param {PaqueteUpdateArgs} args - Arguments to update one Paquete.
     * @example
     * // Update one Paquete
     * const paquete = await prisma.paquete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaqueteUpdateArgs>(args: SelectSubset<T, PaqueteUpdateArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Paquetes.
     * @param {PaqueteDeleteManyArgs} args - Arguments to filter Paquetes to delete.
     * @example
     * // Delete a few Paquetes
     * const { count } = await prisma.paquete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaqueteDeleteManyArgs>(args?: SelectSubset<T, PaqueteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paquetes
     * const paquete = await prisma.paquete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaqueteUpdateManyArgs>(args: SelectSubset<T, PaqueteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paquete.
     * @param {PaqueteUpsertArgs} args - Arguments to update or create a Paquete.
     * @example
     * // Update or create a Paquete
     * const paquete = await prisma.paquete.upsert({
     *   create: {
     *     // ... data to create a Paquete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paquete we want to update
     *   }
     * })
     */
    upsert<T extends PaqueteUpsertArgs>(args: SelectSubset<T, PaqueteUpsertArgs<ExtArgs>>): Prisma__PaqueteClient<$Result.GetResult<Prisma.$PaquetePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Paquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteCountArgs} args - Arguments to filter Paquetes to count.
     * @example
     * // Count the number of Paquetes
     * const count = await prisma.paquete.count({
     *   where: {
     *     // ... the filter for the Paquetes we want to count
     *   }
     * })
    **/
    count<T extends PaqueteCountArgs>(
      args?: Subset<T, PaqueteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaqueteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paquete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaqueteAggregateArgs>(args: Subset<T, PaqueteAggregateArgs>): Prisma.PrismaPromise<GetPaqueteAggregateType<T>>

    /**
     * Group by Paquete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaqueteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaqueteGroupByArgs['orderBy'] }
        : { orderBy?: PaqueteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaqueteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaqueteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paquete model
   */
  readonly fields: PaqueteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paquete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaqueteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudio<T extends Paquete$estudioArgs<ExtArgs> = {}>(args?: Subset<T, Paquete$estudioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudioPayload<ExtArgs>, T, "findMany"> | Null>
    examen<T extends ExamenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamenDefaultArgs<ExtArgs>>): Prisma__ExamenClient<$Result.GetResult<Prisma.$ExamenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    servicio<T extends ServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicioDefaultArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paquete model
   */ 
  interface PaqueteFieldRefs {
    readonly id_paquete: FieldRef<"Paquete", 'Int'>
    readonly estado: FieldRef<"Paquete", 'Estado'>
    readonly examenId: FieldRef<"Paquete", 'Int'>
    readonly servicioId: FieldRef<"Paquete", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Paquete findUnique
   */
  export type PaqueteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * Filter, which Paquete to fetch.
     */
    where: PaqueteWhereUniqueInput
  }

  /**
   * Paquete findUniqueOrThrow
   */
  export type PaqueteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * Filter, which Paquete to fetch.
     */
    where: PaqueteWhereUniqueInput
  }

  /**
   * Paquete findFirst
   */
  export type PaqueteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * Filter, which Paquete to fetch.
     */
    where?: PaqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paquetes to fetch.
     */
    orderBy?: PaqueteOrderByWithRelationInput | PaqueteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paquetes.
     */
    cursor?: PaqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paquetes.
     */
    distinct?: PaqueteScalarFieldEnum | PaqueteScalarFieldEnum[]
  }

  /**
   * Paquete findFirstOrThrow
   */
  export type PaqueteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * Filter, which Paquete to fetch.
     */
    where?: PaqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paquetes to fetch.
     */
    orderBy?: PaqueteOrderByWithRelationInput | PaqueteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paquetes.
     */
    cursor?: PaqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paquetes.
     */
    distinct?: PaqueteScalarFieldEnum | PaqueteScalarFieldEnum[]
  }

  /**
   * Paquete findMany
   */
  export type PaqueteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * Filter, which Paquetes to fetch.
     */
    where?: PaqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paquetes to fetch.
     */
    orderBy?: PaqueteOrderByWithRelationInput | PaqueteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paquetes.
     */
    cursor?: PaqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paquetes.
     */
    skip?: number
    distinct?: PaqueteScalarFieldEnum | PaqueteScalarFieldEnum[]
  }

  /**
   * Paquete create
   */
  export type PaqueteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * The data needed to create a Paquete.
     */
    data: XOR<PaqueteCreateInput, PaqueteUncheckedCreateInput>
  }

  /**
   * Paquete createMany
   */
  export type PaqueteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paquetes.
     */
    data: PaqueteCreateManyInput | PaqueteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paquete update
   */
  export type PaqueteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * The data needed to update a Paquete.
     */
    data: XOR<PaqueteUpdateInput, PaqueteUncheckedUpdateInput>
    /**
     * Choose, which Paquete to update.
     */
    where: PaqueteWhereUniqueInput
  }

  /**
   * Paquete updateMany
   */
  export type PaqueteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paquetes.
     */
    data: XOR<PaqueteUpdateManyMutationInput, PaqueteUncheckedUpdateManyInput>
    /**
     * Filter which Paquetes to update
     */
    where?: PaqueteWhereInput
  }

  /**
   * Paquete upsert
   */
  export type PaqueteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * The filter to search for the Paquete to update in case it exists.
     */
    where: PaqueteWhereUniqueInput
    /**
     * In case the Paquete found by the `where` argument doesn't exist, create a new Paquete with this data.
     */
    create: XOR<PaqueteCreateInput, PaqueteUncheckedCreateInput>
    /**
     * In case the Paquete was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaqueteUpdateInput, PaqueteUncheckedUpdateInput>
  }

  /**
   * Paquete delete
   */
  export type PaqueteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
    /**
     * Filter which Paquete to delete.
     */
    where: PaqueteWhereUniqueInput
  }

  /**
   * Paquete deleteMany
   */
  export type PaqueteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paquetes to delete
     */
    where?: PaqueteWhereInput
  }

  /**
   * Paquete.estudio
   */
  export type Paquete$estudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudio
     */
    select?: EstudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudioInclude<ExtArgs> | null
    where?: EstudioWhereInput
    orderBy?: EstudioOrderByWithRelationInput | EstudioOrderByWithRelationInput[]
    cursor?: EstudioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudioScalarFieldEnum | EstudioScalarFieldEnum[]
  }

  /**
   * Paquete without action
   */
  export type PaqueteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paquete
     */
    select?: PaqueteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PacienteScalarFieldEnum: {
    id_paciente: 'id_paciente',
    tipo_identificacion: 'tipo_identificacion',
    identificacion: 'identificacion',
    primer_nombre: 'primer_nombre',
    segundo_nombre: 'segundo_nombre',
    primer_apellido: 'primer_apellido',
    segundo_apellido: 'segundo_apellido',
    fecha_nacimiento: 'fecha_nacimiento',
    sexo: 'sexo',
    email: 'email',
    telefono: 'telefono',
    direccion: 'direccion',
    tipo_paciente: 'tipo_paciente',
    estado: 'estado',
    municipioId: 'municipioId',
    epsId: 'epsId'
  };

  export type PacienteScalarFieldEnum = (typeof PacienteScalarFieldEnum)[keyof typeof PacienteScalarFieldEnum]


  export const EpsScalarFieldEnum: {
    id_eps: 'id_eps',
    codigo: 'codigo',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type EpsScalarFieldEnum = (typeof EpsScalarFieldEnum)[keyof typeof EpsScalarFieldEnum]


  export const Tipo_ProcedimientoScalarFieldEnum: {
    id_tipo_procedimiento: 'id_tipo_procedimiento',
    nombre: 'nombre'
  };

  export type Tipo_ProcedimientoScalarFieldEnum = (typeof Tipo_ProcedimientoScalarFieldEnum)[keyof typeof Tipo_ProcedimientoScalarFieldEnum]


  export const ProcedimientoScalarFieldEnum: {
    id_procedimiento: 'id_procedimiento',
    factura: 'factura',
    fecha: 'fecha',
    edad_persona: 'edad_persona',
    estado: 'estado',
    createAt: 'createAt',
    updateAt: 'updateAt',
    acuerdoId: 'acuerdoId',
    tipo_procedimientoId: 'tipo_procedimientoId',
    pacienteId: 'pacienteId'
  };

  export type ProcedimientoScalarFieldEnum = (typeof ProcedimientoScalarFieldEnum)[keyof typeof ProcedimientoScalarFieldEnum]


  export const EstudioScalarFieldEnum: {
    id_estudio: 'id_estudio',
    consecutivo: 'consecutivo',
    cantidad: 'cantidad',
    fecha_muestra: 'fecha_muestra',
    fecha_resultado: 'fecha_resultado',
    resultado: 'resultado',
    observacion: 'observacion',
    profesional: 'profesional',
    paqueteId: 'paqueteId',
    procedimientoId: 'procedimientoId'
  };

  export type EstudioScalarFieldEnum = (typeof EstudioScalarFieldEnum)[keyof typeof EstudioScalarFieldEnum]


  export const DepartamentoScalarFieldEnum: {
    id_departamento: 'id_departamento',
    nombre: 'nombre'
  };

  export type DepartamentoScalarFieldEnum = (typeof DepartamentoScalarFieldEnum)[keyof typeof DepartamentoScalarFieldEnum]


  export const MunicipioScalarFieldEnum: {
    id_municipio: 'id_municipio',
    nombre: 'nombre',
    departamentoId: 'departamentoId'
  };

  export type MunicipioScalarFieldEnum = (typeof MunicipioScalarFieldEnum)[keyof typeof MunicipioScalarFieldEnum]


  export const Tipo_ServicioScalarFieldEnum: {
    id_tipo_servicio: 'id_tipo_servicio',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type Tipo_ServicioScalarFieldEnum = (typeof Tipo_ServicioScalarFieldEnum)[keyof typeof Tipo_ServicioScalarFieldEnum]


  export const ServicioScalarFieldEnum: {
    id_servicio: 'id_servicio',
    nombre: 'nombre',
    nivel: 'nivel',
    precio: 'precio',
    estado: 'estado',
    tipo_servicioId: 'tipo_servicioId',
    prestadorId: 'prestadorId'
  };

  export type ServicioScalarFieldEnum = (typeof ServicioScalarFieldEnum)[keyof typeof ServicioScalarFieldEnum]


  export const ExamenScalarFieldEnum: {
    id_examen: 'id_examen',
    nombre: 'nombre',
    unidades: 'unidades',
    rango_biologico: 'rango_biologico',
    metodo: 'metodo',
    precio: 'precio',
    estado: 'estado',
    tipo_examenId: 'tipo_examenId'
  };

  export type ExamenScalarFieldEnum = (typeof ExamenScalarFieldEnum)[keyof typeof ExamenScalarFieldEnum]


  export const Tipo_ResultadoScalarFieldEnum: {
    id_tipo_resultado: 'id_tipo_resultado',
    nombre: 'nombre',
    estado: 'estado',
    examenId: 'examenId'
  };

  export type Tipo_ResultadoScalarFieldEnum = (typeof Tipo_ResultadoScalarFieldEnum)[keyof typeof Tipo_ResultadoScalarFieldEnum]


  export const Tipo_ExamenScalarFieldEnum: {
    id_tipo_examen: 'id_tipo_examen',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type Tipo_ExamenScalarFieldEnum = (typeof Tipo_ExamenScalarFieldEnum)[keyof typeof Tipo_ExamenScalarFieldEnum]


  export const PrestadorScalarFieldEnum: {
    id_prestador: 'id_prestador',
    codigo: 'codigo',
    nit: 'nit',
    razon_social: 'razon_social'
  };

  export type PrestadorScalarFieldEnum = (typeof PrestadorScalarFieldEnum)[keyof typeof PrestadorScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id_usuario: 'id_usuario',
    identificacion: 'identificacion',
    nombre: 'nombre',
    cargo: 'cargo',
    rol: 'rol',
    email: 'email',
    password: 'password',
    estado: 'estado',
    prestadorId: 'prestadorId'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const EmpresaScalarFieldEnum: {
    id_empresa: 'id_empresa',
    nit: 'nit',
    codigo: 'codigo',
    nombre: 'nombre',
    sigla: 'sigla',
    tipo: 'tipo',
    estado: 'estado',
    municipioId: 'municipioId'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const ContratoScalarFieldEnum: {
    id_contrato: 'id_contrato',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    estado: 'estado',
    empresaId: 'empresaId'
  };

  export type ContratoScalarFieldEnum = (typeof ContratoScalarFieldEnum)[keyof typeof ContratoScalarFieldEnum]


  export const AcuerdoScalarFieldEnum: {
    id_acuerdo: 'id_acuerdo',
    estado: 'estado',
    precio: 'precio',
    iva: 'iva',
    createAt: 'createAt',
    updateAt: 'updateAt',
    contratoId: 'contratoId',
    servicioId: 'servicioId'
  };

  export type AcuerdoScalarFieldEnum = (typeof AcuerdoScalarFieldEnum)[keyof typeof AcuerdoScalarFieldEnum]


  export const PaqueteScalarFieldEnum: {
    id_paquete: 'id_paquete',
    estado: 'estado',
    examenId: 'examenId',
    servicioId: 'servicioId'
  };

  export type PaqueteScalarFieldEnum = (typeof PaqueteScalarFieldEnum)[keyof typeof PaqueteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Tipo_Ident'
   */
  export type EnumTipo_IdentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Ident'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Sex'
   */
  export type EnumSexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sex'>
    


  /**
   * Reference to a field of type 'Tipo_Paciente'
   */
  export type EnumTipo_PacienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Paciente'>
    


  /**
   * Reference to a field of type 'Estado'
   */
  export type EnumEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Estado'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Tipo_Empresa'
   */
  export type EnumTipo_EmpresaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Empresa'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type PacienteWhereInput = {
    AND?: PacienteWhereInput | PacienteWhereInput[]
    OR?: PacienteWhereInput[]
    NOT?: PacienteWhereInput | PacienteWhereInput[]
    id_paciente?: IntFilter<"Paciente"> | number
    tipo_identificacion?: EnumTipo_IdentFilter<"Paciente"> | $Enums.Tipo_Ident
    identificacion?: StringFilter<"Paciente"> | string
    primer_nombre?: StringFilter<"Paciente"> | string
    segundo_nombre?: StringNullableFilter<"Paciente"> | string | null
    primer_apellido?: StringFilter<"Paciente"> | string
    segundo_apellido?: StringNullableFilter<"Paciente"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Paciente"> | Date | string
    sexo?: EnumSexFilter<"Paciente"> | $Enums.Sex
    email?: StringFilter<"Paciente"> | string
    telefono?: StringNullableFilter<"Paciente"> | string | null
    direccion?: StringNullableFilter<"Paciente"> | string | null
    tipo_paciente?: EnumTipo_PacienteFilter<"Paciente"> | $Enums.Tipo_Paciente
    estado?: EnumEstadoFilter<"Paciente"> | $Enums.Estado
    municipioId?: IntFilter<"Paciente"> | number
    epsId?: IntFilter<"Paciente"> | number
    procedimiento?: ProcedimientoListRelationFilter
    municipio?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    eps?: XOR<EpsRelationFilter, EpsWhereInput>
  }

  export type PacienteOrderByWithRelationInput = {
    id_paciente?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrderInput | SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    tipo_paciente?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
    epsId?: SortOrder
    procedimiento?: ProcedimientoOrderByRelationAggregateInput
    municipio?: MunicipioOrderByWithRelationInput
    eps?: EpsOrderByWithRelationInput
  }

  export type PacienteWhereUniqueInput = Prisma.AtLeast<{
    id_paciente?: number
    identificacion?: string
    email?: string
    AND?: PacienteWhereInput | PacienteWhereInput[]
    OR?: PacienteWhereInput[]
    NOT?: PacienteWhereInput | PacienteWhereInput[]
    tipo_identificacion?: EnumTipo_IdentFilter<"Paciente"> | $Enums.Tipo_Ident
    primer_nombre?: StringFilter<"Paciente"> | string
    segundo_nombre?: StringNullableFilter<"Paciente"> | string | null
    primer_apellido?: StringFilter<"Paciente"> | string
    segundo_apellido?: StringNullableFilter<"Paciente"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Paciente"> | Date | string
    sexo?: EnumSexFilter<"Paciente"> | $Enums.Sex
    telefono?: StringNullableFilter<"Paciente"> | string | null
    direccion?: StringNullableFilter<"Paciente"> | string | null
    tipo_paciente?: EnumTipo_PacienteFilter<"Paciente"> | $Enums.Tipo_Paciente
    estado?: EnumEstadoFilter<"Paciente"> | $Enums.Estado
    municipioId?: IntFilter<"Paciente"> | number
    epsId?: IntFilter<"Paciente"> | number
    procedimiento?: ProcedimientoListRelationFilter
    municipio?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    eps?: XOR<EpsRelationFilter, EpsWhereInput>
  }, "id_paciente" | "identificacion" | "email">

  export type PacienteOrderByWithAggregationInput = {
    id_paciente?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrderInput | SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    tipo_paciente?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
    epsId?: SortOrder
    _count?: PacienteCountOrderByAggregateInput
    _avg?: PacienteAvgOrderByAggregateInput
    _max?: PacienteMaxOrderByAggregateInput
    _min?: PacienteMinOrderByAggregateInput
    _sum?: PacienteSumOrderByAggregateInput
  }

  export type PacienteScalarWhereWithAggregatesInput = {
    AND?: PacienteScalarWhereWithAggregatesInput | PacienteScalarWhereWithAggregatesInput[]
    OR?: PacienteScalarWhereWithAggregatesInput[]
    NOT?: PacienteScalarWhereWithAggregatesInput | PacienteScalarWhereWithAggregatesInput[]
    id_paciente?: IntWithAggregatesFilter<"Paciente"> | number
    tipo_identificacion?: EnumTipo_IdentWithAggregatesFilter<"Paciente"> | $Enums.Tipo_Ident
    identificacion?: StringWithAggregatesFilter<"Paciente"> | string
    primer_nombre?: StringWithAggregatesFilter<"Paciente"> | string
    segundo_nombre?: StringNullableWithAggregatesFilter<"Paciente"> | string | null
    primer_apellido?: StringWithAggregatesFilter<"Paciente"> | string
    segundo_apellido?: StringNullableWithAggregatesFilter<"Paciente"> | string | null
    fecha_nacimiento?: DateTimeWithAggregatesFilter<"Paciente"> | Date | string
    sexo?: EnumSexWithAggregatesFilter<"Paciente"> | $Enums.Sex
    email?: StringWithAggregatesFilter<"Paciente"> | string
    telefono?: StringNullableWithAggregatesFilter<"Paciente"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Paciente"> | string | null
    tipo_paciente?: EnumTipo_PacienteWithAggregatesFilter<"Paciente"> | $Enums.Tipo_Paciente
    estado?: EnumEstadoWithAggregatesFilter<"Paciente"> | $Enums.Estado
    municipioId?: IntWithAggregatesFilter<"Paciente"> | number
    epsId?: IntWithAggregatesFilter<"Paciente"> | number
  }

  export type EpsWhereInput = {
    AND?: EpsWhereInput | EpsWhereInput[]
    OR?: EpsWhereInput[]
    NOT?: EpsWhereInput | EpsWhereInput[]
    id_eps?: IntFilter<"Eps"> | number
    codigo?: StringFilter<"Eps"> | string
    nombre?: StringFilter<"Eps"> | string
    estado?: EnumEstadoFilter<"Eps"> | $Enums.Estado
    paciente?: PacienteListRelationFilter
  }

  export type EpsOrderByWithRelationInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    paciente?: PacienteOrderByRelationAggregateInput
  }

  export type EpsWhereUniqueInput = Prisma.AtLeast<{
    id_eps?: number
    AND?: EpsWhereInput | EpsWhereInput[]
    OR?: EpsWhereInput[]
    NOT?: EpsWhereInput | EpsWhereInput[]
    codigo?: StringFilter<"Eps"> | string
    nombre?: StringFilter<"Eps"> | string
    estado?: EnumEstadoFilter<"Eps"> | $Enums.Estado
    paciente?: PacienteListRelationFilter
  }, "id_eps">

  export type EpsOrderByWithAggregationInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    _count?: EpsCountOrderByAggregateInput
    _avg?: EpsAvgOrderByAggregateInput
    _max?: EpsMaxOrderByAggregateInput
    _min?: EpsMinOrderByAggregateInput
    _sum?: EpsSumOrderByAggregateInput
  }

  export type EpsScalarWhereWithAggregatesInput = {
    AND?: EpsScalarWhereWithAggregatesInput | EpsScalarWhereWithAggregatesInput[]
    OR?: EpsScalarWhereWithAggregatesInput[]
    NOT?: EpsScalarWhereWithAggregatesInput | EpsScalarWhereWithAggregatesInput[]
    id_eps?: IntWithAggregatesFilter<"Eps"> | number
    codigo?: StringWithAggregatesFilter<"Eps"> | string
    nombre?: StringWithAggregatesFilter<"Eps"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Eps"> | $Enums.Estado
  }

  export type Tipo_ProcedimientoWhereInput = {
    AND?: Tipo_ProcedimientoWhereInput | Tipo_ProcedimientoWhereInput[]
    OR?: Tipo_ProcedimientoWhereInput[]
    NOT?: Tipo_ProcedimientoWhereInput | Tipo_ProcedimientoWhereInput[]
    id_tipo_procedimiento?: IntFilter<"Tipo_Procedimiento"> | number
    nombre?: StringFilter<"Tipo_Procedimiento"> | string
    procedimiento?: ProcedimientoListRelationFilter
  }

  export type Tipo_ProcedimientoOrderByWithRelationInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
    procedimiento?: ProcedimientoOrderByRelationAggregateInput
  }

  export type Tipo_ProcedimientoWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_procedimiento?: number
    AND?: Tipo_ProcedimientoWhereInput | Tipo_ProcedimientoWhereInput[]
    OR?: Tipo_ProcedimientoWhereInput[]
    NOT?: Tipo_ProcedimientoWhereInput | Tipo_ProcedimientoWhereInput[]
    nombre?: StringFilter<"Tipo_Procedimiento"> | string
    procedimiento?: ProcedimientoListRelationFilter
  }, "id_tipo_procedimiento">

  export type Tipo_ProcedimientoOrderByWithAggregationInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
    _count?: Tipo_ProcedimientoCountOrderByAggregateInput
    _avg?: Tipo_ProcedimientoAvgOrderByAggregateInput
    _max?: Tipo_ProcedimientoMaxOrderByAggregateInput
    _min?: Tipo_ProcedimientoMinOrderByAggregateInput
    _sum?: Tipo_ProcedimientoSumOrderByAggregateInput
  }

  export type Tipo_ProcedimientoScalarWhereWithAggregatesInput = {
    AND?: Tipo_ProcedimientoScalarWhereWithAggregatesInput | Tipo_ProcedimientoScalarWhereWithAggregatesInput[]
    OR?: Tipo_ProcedimientoScalarWhereWithAggregatesInput[]
    NOT?: Tipo_ProcedimientoScalarWhereWithAggregatesInput | Tipo_ProcedimientoScalarWhereWithAggregatesInput[]
    id_tipo_procedimiento?: IntWithAggregatesFilter<"Tipo_Procedimiento"> | number
    nombre?: StringWithAggregatesFilter<"Tipo_Procedimiento"> | string
  }

  export type ProcedimientoWhereInput = {
    AND?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    OR?: ProcedimientoWhereInput[]
    NOT?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    id_procedimiento?: IntFilter<"Procedimiento"> | number
    factura?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    edad_persona?: StringFilter<"Procedimiento"> | string
    estado?: EnumEstadoFilter<"Procedimiento"> | $Enums.Estado
    createAt?: DateTimeFilter<"Procedimiento"> | Date | string
    updateAt?: DateTimeFilter<"Procedimiento"> | Date | string
    acuerdoId?: IntFilter<"Procedimiento"> | number
    tipo_procedimientoId?: IntFilter<"Procedimiento"> | number
    pacienteId?: IntFilter<"Procedimiento"> | number
    estudio?: EstudioListRelationFilter
    acuerdo?: XOR<AcuerdoRelationFilter, AcuerdoWhereInput>
    tipo_procedimiento?: XOR<Tipo_ProcedimientoRelationFilter, Tipo_ProcedimientoWhereInput>
    paciente?: XOR<PacienteRelationFilter, PacienteWhereInput>
  }

  export type ProcedimientoOrderByWithRelationInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    acuerdoId?: SortOrder
    tipo_procedimientoId?: SortOrder
    pacienteId?: SortOrder
    estudio?: EstudioOrderByRelationAggregateInput
    acuerdo?: AcuerdoOrderByWithRelationInput
    tipo_procedimiento?: Tipo_ProcedimientoOrderByWithRelationInput
    paciente?: PacienteOrderByWithRelationInput
  }

  export type ProcedimientoWhereUniqueInput = Prisma.AtLeast<{
    id_procedimiento?: number
    AND?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    OR?: ProcedimientoWhereInput[]
    NOT?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    factura?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    edad_persona?: StringFilter<"Procedimiento"> | string
    estado?: EnumEstadoFilter<"Procedimiento"> | $Enums.Estado
    createAt?: DateTimeFilter<"Procedimiento"> | Date | string
    updateAt?: DateTimeFilter<"Procedimiento"> | Date | string
    acuerdoId?: IntFilter<"Procedimiento"> | number
    tipo_procedimientoId?: IntFilter<"Procedimiento"> | number
    pacienteId?: IntFilter<"Procedimiento"> | number
    estudio?: EstudioListRelationFilter
    acuerdo?: XOR<AcuerdoRelationFilter, AcuerdoWhereInput>
    tipo_procedimiento?: XOR<Tipo_ProcedimientoRelationFilter, Tipo_ProcedimientoWhereInput>
    paciente?: XOR<PacienteRelationFilter, PacienteWhereInput>
  }, "id_procedimiento">

  export type ProcedimientoOrderByWithAggregationInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    acuerdoId?: SortOrder
    tipo_procedimientoId?: SortOrder
    pacienteId?: SortOrder
    _count?: ProcedimientoCountOrderByAggregateInput
    _avg?: ProcedimientoAvgOrderByAggregateInput
    _max?: ProcedimientoMaxOrderByAggregateInput
    _min?: ProcedimientoMinOrderByAggregateInput
    _sum?: ProcedimientoSumOrderByAggregateInput
  }

  export type ProcedimientoScalarWhereWithAggregatesInput = {
    AND?: ProcedimientoScalarWhereWithAggregatesInput | ProcedimientoScalarWhereWithAggregatesInput[]
    OR?: ProcedimientoScalarWhereWithAggregatesInput[]
    NOT?: ProcedimientoScalarWhereWithAggregatesInput | ProcedimientoScalarWhereWithAggregatesInput[]
    id_procedimiento?: IntWithAggregatesFilter<"Procedimiento"> | number
    factura?: IntWithAggregatesFilter<"Procedimiento"> | number
    fecha?: DateTimeWithAggregatesFilter<"Procedimiento"> | Date | string
    edad_persona?: StringWithAggregatesFilter<"Procedimiento"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Procedimiento"> | $Enums.Estado
    createAt?: DateTimeWithAggregatesFilter<"Procedimiento"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Procedimiento"> | Date | string
    acuerdoId?: IntWithAggregatesFilter<"Procedimiento"> | number
    tipo_procedimientoId?: IntWithAggregatesFilter<"Procedimiento"> | number
    pacienteId?: IntWithAggregatesFilter<"Procedimiento"> | number
  }

  export type EstudioWhereInput = {
    AND?: EstudioWhereInput | EstudioWhereInput[]
    OR?: EstudioWhereInput[]
    NOT?: EstudioWhereInput | EstudioWhereInput[]
    id_estudio?: IntFilter<"Estudio"> | number
    consecutivo?: IntFilter<"Estudio"> | number
    cantidad?: IntFilter<"Estudio"> | number
    fecha_muestra?: DateTimeFilter<"Estudio"> | Date | string
    fecha_resultado?: DateTimeFilter<"Estudio"> | Date | string
    resultado?: StringFilter<"Estudio"> | string
    observacion?: StringFilter<"Estudio"> | string
    profesional?: IntFilter<"Estudio"> | number
    paqueteId?: IntFilter<"Estudio"> | number
    procedimientoId?: IntFilter<"Estudio"> | number
    paquete?: XOR<PaqueteRelationFilter, PaqueteWhereInput>
    procedimiento?: XOR<ProcedimientoRelationFilter, ProcedimientoWhereInput>
  }

  export type EstudioOrderByWithRelationInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    paqueteId?: SortOrder
    procedimientoId?: SortOrder
    paquete?: PaqueteOrderByWithRelationInput
    procedimiento?: ProcedimientoOrderByWithRelationInput
  }

  export type EstudioWhereUniqueInput = Prisma.AtLeast<{
    id_estudio?: number
    AND?: EstudioWhereInput | EstudioWhereInput[]
    OR?: EstudioWhereInput[]
    NOT?: EstudioWhereInput | EstudioWhereInput[]
    consecutivo?: IntFilter<"Estudio"> | number
    cantidad?: IntFilter<"Estudio"> | number
    fecha_muestra?: DateTimeFilter<"Estudio"> | Date | string
    fecha_resultado?: DateTimeFilter<"Estudio"> | Date | string
    resultado?: StringFilter<"Estudio"> | string
    observacion?: StringFilter<"Estudio"> | string
    profesional?: IntFilter<"Estudio"> | number
    paqueteId?: IntFilter<"Estudio"> | number
    procedimientoId?: IntFilter<"Estudio"> | number
    paquete?: XOR<PaqueteRelationFilter, PaqueteWhereInput>
    procedimiento?: XOR<ProcedimientoRelationFilter, ProcedimientoWhereInput>
  }, "id_estudio">

  export type EstudioOrderByWithAggregationInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    paqueteId?: SortOrder
    procedimientoId?: SortOrder
    _count?: EstudioCountOrderByAggregateInput
    _avg?: EstudioAvgOrderByAggregateInput
    _max?: EstudioMaxOrderByAggregateInput
    _min?: EstudioMinOrderByAggregateInput
    _sum?: EstudioSumOrderByAggregateInput
  }

  export type EstudioScalarWhereWithAggregatesInput = {
    AND?: EstudioScalarWhereWithAggregatesInput | EstudioScalarWhereWithAggregatesInput[]
    OR?: EstudioScalarWhereWithAggregatesInput[]
    NOT?: EstudioScalarWhereWithAggregatesInput | EstudioScalarWhereWithAggregatesInput[]
    id_estudio?: IntWithAggregatesFilter<"Estudio"> | number
    consecutivo?: IntWithAggregatesFilter<"Estudio"> | number
    cantidad?: IntWithAggregatesFilter<"Estudio"> | number
    fecha_muestra?: DateTimeWithAggregatesFilter<"Estudio"> | Date | string
    fecha_resultado?: DateTimeWithAggregatesFilter<"Estudio"> | Date | string
    resultado?: StringWithAggregatesFilter<"Estudio"> | string
    observacion?: StringWithAggregatesFilter<"Estudio"> | string
    profesional?: IntWithAggregatesFilter<"Estudio"> | number
    paqueteId?: IntWithAggregatesFilter<"Estudio"> | number
    procedimientoId?: IntWithAggregatesFilter<"Estudio"> | number
  }

  export type DepartamentoWhereInput = {
    AND?: DepartamentoWhereInput | DepartamentoWhereInput[]
    OR?: DepartamentoWhereInput[]
    NOT?: DepartamentoWhereInput | DepartamentoWhereInput[]
    id_departamento?: IntFilter<"Departamento"> | number
    nombre?: StringFilter<"Departamento"> | string
    municipio?: MunicipioListRelationFilter
  }

  export type DepartamentoOrderByWithRelationInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
    municipio?: MunicipioOrderByRelationAggregateInput
  }

  export type DepartamentoWhereUniqueInput = Prisma.AtLeast<{
    id_departamento?: number
    AND?: DepartamentoWhereInput | DepartamentoWhereInput[]
    OR?: DepartamentoWhereInput[]
    NOT?: DepartamentoWhereInput | DepartamentoWhereInput[]
    nombre?: StringFilter<"Departamento"> | string
    municipio?: MunicipioListRelationFilter
  }, "id_departamento">

  export type DepartamentoOrderByWithAggregationInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
    _count?: DepartamentoCountOrderByAggregateInput
    _avg?: DepartamentoAvgOrderByAggregateInput
    _max?: DepartamentoMaxOrderByAggregateInput
    _min?: DepartamentoMinOrderByAggregateInput
    _sum?: DepartamentoSumOrderByAggregateInput
  }

  export type DepartamentoScalarWhereWithAggregatesInput = {
    AND?: DepartamentoScalarWhereWithAggregatesInput | DepartamentoScalarWhereWithAggregatesInput[]
    OR?: DepartamentoScalarWhereWithAggregatesInput[]
    NOT?: DepartamentoScalarWhereWithAggregatesInput | DepartamentoScalarWhereWithAggregatesInput[]
    id_departamento?: IntWithAggregatesFilter<"Departamento"> | number
    nombre?: StringWithAggregatesFilter<"Departamento"> | string
  }

  export type MunicipioWhereInput = {
    AND?: MunicipioWhereInput | MunicipioWhereInput[]
    OR?: MunicipioWhereInput[]
    NOT?: MunicipioWhereInput | MunicipioWhereInput[]
    id_municipio?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
    departamentoId?: IntFilter<"Municipio"> | number
    departamento?: XOR<DepartamentoRelationFilter, DepartamentoWhereInput>
    paciente?: PacienteListRelationFilter
    empresa?: EmpresaListRelationFilter
  }

  export type MunicipioOrderByWithRelationInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamentoId?: SortOrder
    departamento?: DepartamentoOrderByWithRelationInput
    paciente?: PacienteOrderByRelationAggregateInput
    empresa?: EmpresaOrderByRelationAggregateInput
  }

  export type MunicipioWhereUniqueInput = Prisma.AtLeast<{
    id_municipio?: number
    AND?: MunicipioWhereInput | MunicipioWhereInput[]
    OR?: MunicipioWhereInput[]
    NOT?: MunicipioWhereInput | MunicipioWhereInput[]
    nombre?: StringFilter<"Municipio"> | string
    departamentoId?: IntFilter<"Municipio"> | number
    departamento?: XOR<DepartamentoRelationFilter, DepartamentoWhereInput>
    paciente?: PacienteListRelationFilter
    empresa?: EmpresaListRelationFilter
  }, "id_municipio">

  export type MunicipioOrderByWithAggregationInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamentoId?: SortOrder
    _count?: MunicipioCountOrderByAggregateInput
    _avg?: MunicipioAvgOrderByAggregateInput
    _max?: MunicipioMaxOrderByAggregateInput
    _min?: MunicipioMinOrderByAggregateInput
    _sum?: MunicipioSumOrderByAggregateInput
  }

  export type MunicipioScalarWhereWithAggregatesInput = {
    AND?: MunicipioScalarWhereWithAggregatesInput | MunicipioScalarWhereWithAggregatesInput[]
    OR?: MunicipioScalarWhereWithAggregatesInput[]
    NOT?: MunicipioScalarWhereWithAggregatesInput | MunicipioScalarWhereWithAggregatesInput[]
    id_municipio?: IntWithAggregatesFilter<"Municipio"> | number
    nombre?: StringWithAggregatesFilter<"Municipio"> | string
    departamentoId?: IntWithAggregatesFilter<"Municipio"> | number
  }

  export type Tipo_ServicioWhereInput = {
    AND?: Tipo_ServicioWhereInput | Tipo_ServicioWhereInput[]
    OR?: Tipo_ServicioWhereInput[]
    NOT?: Tipo_ServicioWhereInput | Tipo_ServicioWhereInput[]
    id_tipo_servicio?: IntFilter<"Tipo_Servicio"> | number
    nombre?: StringFilter<"Tipo_Servicio"> | string
    estado?: EnumEstadoFilter<"Tipo_Servicio"> | $Enums.Estado
    servicio?: ServicioListRelationFilter
  }

  export type Tipo_ServicioOrderByWithRelationInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    servicio?: ServicioOrderByRelationAggregateInput
  }

  export type Tipo_ServicioWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_servicio?: number
    AND?: Tipo_ServicioWhereInput | Tipo_ServicioWhereInput[]
    OR?: Tipo_ServicioWhereInput[]
    NOT?: Tipo_ServicioWhereInput | Tipo_ServicioWhereInput[]
    nombre?: StringFilter<"Tipo_Servicio"> | string
    estado?: EnumEstadoFilter<"Tipo_Servicio"> | $Enums.Estado
    servicio?: ServicioListRelationFilter
  }, "id_tipo_servicio">

  export type Tipo_ServicioOrderByWithAggregationInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    _count?: Tipo_ServicioCountOrderByAggregateInput
    _avg?: Tipo_ServicioAvgOrderByAggregateInput
    _max?: Tipo_ServicioMaxOrderByAggregateInput
    _min?: Tipo_ServicioMinOrderByAggregateInput
    _sum?: Tipo_ServicioSumOrderByAggregateInput
  }

  export type Tipo_ServicioScalarWhereWithAggregatesInput = {
    AND?: Tipo_ServicioScalarWhereWithAggregatesInput | Tipo_ServicioScalarWhereWithAggregatesInput[]
    OR?: Tipo_ServicioScalarWhereWithAggregatesInput[]
    NOT?: Tipo_ServicioScalarWhereWithAggregatesInput | Tipo_ServicioScalarWhereWithAggregatesInput[]
    id_tipo_servicio?: IntWithAggregatesFilter<"Tipo_Servicio"> | number
    nombre?: StringWithAggregatesFilter<"Tipo_Servicio"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Tipo_Servicio"> | $Enums.Estado
  }

  export type ServicioWhereInput = {
    AND?: ServicioWhereInput | ServicioWhereInput[]
    OR?: ServicioWhereInput[]
    NOT?: ServicioWhereInput | ServicioWhereInput[]
    id_servicio?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    nivel?: IntFilter<"Servicio"> | number
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Servicio"> | $Enums.Estado
    tipo_servicioId?: IntFilter<"Servicio"> | number
    prestadorId?: IntFilter<"Servicio"> | number
    paquete?: PaqueteListRelationFilter
    acuerdo?: AcuerdoListRelationFilter
    tipo_servicio?: XOR<Tipo_ServicioRelationFilter, Tipo_ServicioWhereInput>
    prestador?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }

  export type ServicioOrderByWithRelationInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    nivel?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_servicioId?: SortOrder
    prestadorId?: SortOrder
    paquete?: PaqueteOrderByRelationAggregateInput
    acuerdo?: AcuerdoOrderByRelationAggregateInput
    tipo_servicio?: Tipo_ServicioOrderByWithRelationInput
    prestador?: PrestadorOrderByWithRelationInput
  }

  export type ServicioWhereUniqueInput = Prisma.AtLeast<{
    id_servicio?: number
    AND?: ServicioWhereInput | ServicioWhereInput[]
    OR?: ServicioWhereInput[]
    NOT?: ServicioWhereInput | ServicioWhereInput[]
    nombre?: StringFilter<"Servicio"> | string
    nivel?: IntFilter<"Servicio"> | number
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Servicio"> | $Enums.Estado
    tipo_servicioId?: IntFilter<"Servicio"> | number
    prestadorId?: IntFilter<"Servicio"> | number
    paquete?: PaqueteListRelationFilter
    acuerdo?: AcuerdoListRelationFilter
    tipo_servicio?: XOR<Tipo_ServicioRelationFilter, Tipo_ServicioWhereInput>
    prestador?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }, "id_servicio">

  export type ServicioOrderByWithAggregationInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    nivel?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_servicioId?: SortOrder
    prestadorId?: SortOrder
    _count?: ServicioCountOrderByAggregateInput
    _avg?: ServicioAvgOrderByAggregateInput
    _max?: ServicioMaxOrderByAggregateInput
    _min?: ServicioMinOrderByAggregateInput
    _sum?: ServicioSumOrderByAggregateInput
  }

  export type ServicioScalarWhereWithAggregatesInput = {
    AND?: ServicioScalarWhereWithAggregatesInput | ServicioScalarWhereWithAggregatesInput[]
    OR?: ServicioScalarWhereWithAggregatesInput[]
    NOT?: ServicioScalarWhereWithAggregatesInput | ServicioScalarWhereWithAggregatesInput[]
    id_servicio?: IntWithAggregatesFilter<"Servicio"> | number
    nombre?: StringWithAggregatesFilter<"Servicio"> | string
    nivel?: IntWithAggregatesFilter<"Servicio"> | number
    precio?: DecimalWithAggregatesFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoWithAggregatesFilter<"Servicio"> | $Enums.Estado
    tipo_servicioId?: IntWithAggregatesFilter<"Servicio"> | number
    prestadorId?: IntWithAggregatesFilter<"Servicio"> | number
  }

  export type ExamenWhereInput = {
    AND?: ExamenWhereInput | ExamenWhereInput[]
    OR?: ExamenWhereInput[]
    NOT?: ExamenWhereInput | ExamenWhereInput[]
    id_examen?: IntFilter<"Examen"> | number
    nombre?: StringFilter<"Examen"> | string
    unidades?: StringFilter<"Examen"> | string
    rango_biologico?: StringFilter<"Examen"> | string
    metodo?: StringFilter<"Examen"> | string
    precio?: DecimalFilter<"Examen"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Examen"> | $Enums.Estado
    tipo_examenId?: IntFilter<"Examen"> | number
    tipo_examen?: XOR<Tipo_ExamenRelationFilter, Tipo_ExamenWhereInput>
    tipo_resultado?: Tipo_ResultadoListRelationFilter
    paquete?: PaqueteListRelationFilter
  }

  export type ExamenOrderByWithRelationInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examenId?: SortOrder
    tipo_examen?: Tipo_ExamenOrderByWithRelationInput
    tipo_resultado?: Tipo_ResultadoOrderByRelationAggregateInput
    paquete?: PaqueteOrderByRelationAggregateInput
  }

  export type ExamenWhereUniqueInput = Prisma.AtLeast<{
    id_examen?: number
    AND?: ExamenWhereInput | ExamenWhereInput[]
    OR?: ExamenWhereInput[]
    NOT?: ExamenWhereInput | ExamenWhereInput[]
    nombre?: StringFilter<"Examen"> | string
    unidades?: StringFilter<"Examen"> | string
    rango_biologico?: StringFilter<"Examen"> | string
    metodo?: StringFilter<"Examen"> | string
    precio?: DecimalFilter<"Examen"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Examen"> | $Enums.Estado
    tipo_examenId?: IntFilter<"Examen"> | number
    tipo_examen?: XOR<Tipo_ExamenRelationFilter, Tipo_ExamenWhereInput>
    tipo_resultado?: Tipo_ResultadoListRelationFilter
    paquete?: PaqueteListRelationFilter
  }, "id_examen">

  export type ExamenOrderByWithAggregationInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examenId?: SortOrder
    _count?: ExamenCountOrderByAggregateInput
    _avg?: ExamenAvgOrderByAggregateInput
    _max?: ExamenMaxOrderByAggregateInput
    _min?: ExamenMinOrderByAggregateInput
    _sum?: ExamenSumOrderByAggregateInput
  }

  export type ExamenScalarWhereWithAggregatesInput = {
    AND?: ExamenScalarWhereWithAggregatesInput | ExamenScalarWhereWithAggregatesInput[]
    OR?: ExamenScalarWhereWithAggregatesInput[]
    NOT?: ExamenScalarWhereWithAggregatesInput | ExamenScalarWhereWithAggregatesInput[]
    id_examen?: IntWithAggregatesFilter<"Examen"> | number
    nombre?: StringWithAggregatesFilter<"Examen"> | string
    unidades?: StringWithAggregatesFilter<"Examen"> | string
    rango_biologico?: StringWithAggregatesFilter<"Examen"> | string
    metodo?: StringWithAggregatesFilter<"Examen"> | string
    precio?: DecimalWithAggregatesFilter<"Examen"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoWithAggregatesFilter<"Examen"> | $Enums.Estado
    tipo_examenId?: IntWithAggregatesFilter<"Examen"> | number
  }

  export type Tipo_ResultadoWhereInput = {
    AND?: Tipo_ResultadoWhereInput | Tipo_ResultadoWhereInput[]
    OR?: Tipo_ResultadoWhereInput[]
    NOT?: Tipo_ResultadoWhereInput | Tipo_ResultadoWhereInput[]
    id_tipo_resultado?: IntFilter<"Tipo_Resultado"> | number
    nombre?: StringFilter<"Tipo_Resultado"> | string
    estado?: EnumEstadoFilter<"Tipo_Resultado"> | $Enums.Estado
    examenId?: IntFilter<"Tipo_Resultado"> | number
    examen?: XOR<ExamenRelationFilter, ExamenWhereInput>
  }

  export type Tipo_ResultadoOrderByWithRelationInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
    examen?: ExamenOrderByWithRelationInput
  }

  export type Tipo_ResultadoWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_resultado?: number
    AND?: Tipo_ResultadoWhereInput | Tipo_ResultadoWhereInput[]
    OR?: Tipo_ResultadoWhereInput[]
    NOT?: Tipo_ResultadoWhereInput | Tipo_ResultadoWhereInput[]
    nombre?: StringFilter<"Tipo_Resultado"> | string
    estado?: EnumEstadoFilter<"Tipo_Resultado"> | $Enums.Estado
    examenId?: IntFilter<"Tipo_Resultado"> | number
    examen?: XOR<ExamenRelationFilter, ExamenWhereInput>
  }, "id_tipo_resultado">

  export type Tipo_ResultadoOrderByWithAggregationInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
    _count?: Tipo_ResultadoCountOrderByAggregateInput
    _avg?: Tipo_ResultadoAvgOrderByAggregateInput
    _max?: Tipo_ResultadoMaxOrderByAggregateInput
    _min?: Tipo_ResultadoMinOrderByAggregateInput
    _sum?: Tipo_ResultadoSumOrderByAggregateInput
  }

  export type Tipo_ResultadoScalarWhereWithAggregatesInput = {
    AND?: Tipo_ResultadoScalarWhereWithAggregatesInput | Tipo_ResultadoScalarWhereWithAggregatesInput[]
    OR?: Tipo_ResultadoScalarWhereWithAggregatesInput[]
    NOT?: Tipo_ResultadoScalarWhereWithAggregatesInput | Tipo_ResultadoScalarWhereWithAggregatesInput[]
    id_tipo_resultado?: IntWithAggregatesFilter<"Tipo_Resultado"> | number
    nombre?: StringWithAggregatesFilter<"Tipo_Resultado"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Tipo_Resultado"> | $Enums.Estado
    examenId?: IntWithAggregatesFilter<"Tipo_Resultado"> | number
  }

  export type Tipo_ExamenWhereInput = {
    AND?: Tipo_ExamenWhereInput | Tipo_ExamenWhereInput[]
    OR?: Tipo_ExamenWhereInput[]
    NOT?: Tipo_ExamenWhereInput | Tipo_ExamenWhereInput[]
    id_tipo_examen?: IntFilter<"Tipo_Examen"> | number
    nombre?: StringFilter<"Tipo_Examen"> | string
    estado?: EnumEstadoFilter<"Tipo_Examen"> | $Enums.Estado
    examen?: ExamenListRelationFilter
  }

  export type Tipo_ExamenOrderByWithRelationInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examen?: ExamenOrderByRelationAggregateInput
  }

  export type Tipo_ExamenWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_examen?: number
    AND?: Tipo_ExamenWhereInput | Tipo_ExamenWhereInput[]
    OR?: Tipo_ExamenWhereInput[]
    NOT?: Tipo_ExamenWhereInput | Tipo_ExamenWhereInput[]
    nombre?: StringFilter<"Tipo_Examen"> | string
    estado?: EnumEstadoFilter<"Tipo_Examen"> | $Enums.Estado
    examen?: ExamenListRelationFilter
  }, "id_tipo_examen">

  export type Tipo_ExamenOrderByWithAggregationInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    _count?: Tipo_ExamenCountOrderByAggregateInput
    _avg?: Tipo_ExamenAvgOrderByAggregateInput
    _max?: Tipo_ExamenMaxOrderByAggregateInput
    _min?: Tipo_ExamenMinOrderByAggregateInput
    _sum?: Tipo_ExamenSumOrderByAggregateInput
  }

  export type Tipo_ExamenScalarWhereWithAggregatesInput = {
    AND?: Tipo_ExamenScalarWhereWithAggregatesInput | Tipo_ExamenScalarWhereWithAggregatesInput[]
    OR?: Tipo_ExamenScalarWhereWithAggregatesInput[]
    NOT?: Tipo_ExamenScalarWhereWithAggregatesInput | Tipo_ExamenScalarWhereWithAggregatesInput[]
    id_tipo_examen?: IntWithAggregatesFilter<"Tipo_Examen"> | number
    nombre?: StringWithAggregatesFilter<"Tipo_Examen"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Tipo_Examen"> | $Enums.Estado
  }

  export type PrestadorWhereInput = {
    AND?: PrestadorWhereInput | PrestadorWhereInput[]
    OR?: PrestadorWhereInput[]
    NOT?: PrestadorWhereInput | PrestadorWhereInput[]
    id_prestador?: IntFilter<"Prestador"> | number
    codigo?: StringFilter<"Prestador"> | string
    nit?: StringFilter<"Prestador"> | string
    razon_social?: StringFilter<"Prestador"> | string
    servicio?: ServicioListRelationFilter
    usuario?: UsuarioListRelationFilter
  }

  export type PrestadorOrderByWithRelationInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
    servicio?: ServicioOrderByRelationAggregateInput
    usuario?: UsuarioOrderByRelationAggregateInput
  }

  export type PrestadorWhereUniqueInput = Prisma.AtLeast<{
    id_prestador?: number
    codigo?: string
    AND?: PrestadorWhereInput | PrestadorWhereInput[]
    OR?: PrestadorWhereInput[]
    NOT?: PrestadorWhereInput | PrestadorWhereInput[]
    nit?: StringFilter<"Prestador"> | string
    razon_social?: StringFilter<"Prestador"> | string
    servicio?: ServicioListRelationFilter
    usuario?: UsuarioListRelationFilter
  }, "id_prestador" | "codigo">

  export type PrestadorOrderByWithAggregationInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
    _count?: PrestadorCountOrderByAggregateInput
    _avg?: PrestadorAvgOrderByAggregateInput
    _max?: PrestadorMaxOrderByAggregateInput
    _min?: PrestadorMinOrderByAggregateInput
    _sum?: PrestadorSumOrderByAggregateInput
  }

  export type PrestadorScalarWhereWithAggregatesInput = {
    AND?: PrestadorScalarWhereWithAggregatesInput | PrestadorScalarWhereWithAggregatesInput[]
    OR?: PrestadorScalarWhereWithAggregatesInput[]
    NOT?: PrestadorScalarWhereWithAggregatesInput | PrestadorScalarWhereWithAggregatesInput[]
    id_prestador?: IntWithAggregatesFilter<"Prestador"> | number
    codigo?: StringWithAggregatesFilter<"Prestador"> | string
    nit?: StringWithAggregatesFilter<"Prestador"> | string
    razon_social?: StringWithAggregatesFilter<"Prestador"> | string
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id_usuario?: IntFilter<"Usuario"> | number
    identificacion?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    cargo?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    email?: StringFilter<"Usuario"> | string
    password?: StringFilter<"Usuario"> | string
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    prestadorId?: IntFilter<"Usuario"> | number
    prestador?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }

  export type UsuarioOrderByWithRelationInput = {
    id_usuario?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestadorId?: SortOrder
    prestador?: PrestadorOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    identificacion?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    cargo?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    email?: StringFilter<"Usuario"> | string
    password?: StringFilter<"Usuario"> | string
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    prestadorId?: IntFilter<"Usuario"> | number
    prestador?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }, "id_usuario" | "identificacion">

  export type UsuarioOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestadorId?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"Usuario"> | number
    identificacion?: StringWithAggregatesFilter<"Usuario"> | string
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    cargo?: StringWithAggregatesFilter<"Usuario"> | string
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    email?: StringWithAggregatesFilter<"Usuario"> | string
    password?: StringWithAggregatesFilter<"Usuario"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Usuario"> | $Enums.Estado
    prestadorId?: IntWithAggregatesFilter<"Usuario"> | number
  }

  export type EmpresaWhereInput = {
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    id_empresa?: IntFilter<"Empresa"> | number
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipioId?: IntFilter<"Empresa"> | number
    municipio?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    contrato?: ContratoListRelationFilter
  }

  export type EmpresaOrderByWithRelationInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
    municipio?: MunicipioOrderByWithRelationInput
    contrato?: ContratoOrderByRelationAggregateInput
  }

  export type EmpresaWhereUniqueInput = Prisma.AtLeast<{
    id_empresa?: number
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipioId?: IntFilter<"Empresa"> | number
    municipio?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    contrato?: ContratoListRelationFilter
  }, "id_empresa">

  export type EmpresaOrderByWithAggregationInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
    _count?: EmpresaCountOrderByAggregateInput
    _avg?: EmpresaAvgOrderByAggregateInput
    _max?: EmpresaMaxOrderByAggregateInput
    _min?: EmpresaMinOrderByAggregateInput
    _sum?: EmpresaSumOrderByAggregateInput
  }

  export type EmpresaScalarWhereWithAggregatesInput = {
    AND?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    OR?: EmpresaScalarWhereWithAggregatesInput[]
    NOT?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    id_empresa?: IntWithAggregatesFilter<"Empresa"> | number
    nit?: StringWithAggregatesFilter<"Empresa"> | string
    codigo?: IntWithAggregatesFilter<"Empresa"> | number
    nombre?: StringWithAggregatesFilter<"Empresa"> | string
    sigla?: StringWithAggregatesFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaWithAggregatesFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoWithAggregatesFilter<"Empresa"> | $Enums.Estado
    municipioId?: IntWithAggregatesFilter<"Empresa"> | number
  }

  export type ContratoWhereInput = {
    AND?: ContratoWhereInput | ContratoWhereInput[]
    OR?: ContratoWhereInput[]
    NOT?: ContratoWhereInput | ContratoWhereInput[]
    id_contrato?: IntFilter<"Contrato"> | number
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresaId?: IntFilter<"Contrato"> | number
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    acuerdo?: AcuerdoListRelationFilter
  }

  export type ContratoOrderByWithRelationInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresaId?: SortOrder
    empresa?: EmpresaOrderByWithRelationInput
    acuerdo?: AcuerdoOrderByRelationAggregateInput
  }

  export type ContratoWhereUniqueInput = Prisma.AtLeast<{
    id_contrato?: number
    AND?: ContratoWhereInput | ContratoWhereInput[]
    OR?: ContratoWhereInput[]
    NOT?: ContratoWhereInput | ContratoWhereInput[]
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresaId?: IntFilter<"Contrato"> | number
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    acuerdo?: AcuerdoListRelationFilter
  }, "id_contrato">

  export type ContratoOrderByWithAggregationInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresaId?: SortOrder
    _count?: ContratoCountOrderByAggregateInput
    _avg?: ContratoAvgOrderByAggregateInput
    _max?: ContratoMaxOrderByAggregateInput
    _min?: ContratoMinOrderByAggregateInput
    _sum?: ContratoSumOrderByAggregateInput
  }

  export type ContratoScalarWhereWithAggregatesInput = {
    AND?: ContratoScalarWhereWithAggregatesInput | ContratoScalarWhereWithAggregatesInput[]
    OR?: ContratoScalarWhereWithAggregatesInput[]
    NOT?: ContratoScalarWhereWithAggregatesInput | ContratoScalarWhereWithAggregatesInput[]
    id_contrato?: IntWithAggregatesFilter<"Contrato"> | number
    fecha_inicio?: DateTimeWithAggregatesFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeWithAggregatesFilter<"Contrato"> | Date | string
    estado?: EnumEstadoWithAggregatesFilter<"Contrato"> | $Enums.Estado
    empresaId?: IntWithAggregatesFilter<"Contrato"> | number
  }

  export type AcuerdoWhereInput = {
    AND?: AcuerdoWhereInput | AcuerdoWhereInput[]
    OR?: AcuerdoWhereInput[]
    NOT?: AcuerdoWhereInput | AcuerdoWhereInput[]
    id_acuerdo?: IntFilter<"Acuerdo"> | number
    estado?: EnumEstadoFilter<"Acuerdo"> | $Enums.Estado
    precio?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFilter<"Acuerdo"> | Date | string
    updateAt?: DateTimeFilter<"Acuerdo"> | Date | string
    contratoId?: IntFilter<"Acuerdo"> | number
    servicioId?: IntFilter<"Acuerdo"> | number
    procedimiento?: ProcedimientoListRelationFilter
    contrato?: XOR<ContratoRelationFilter, ContratoWhereInput>
    servicio?: XOR<ServicioRelationFilter, ServicioWhereInput>
  }

  export type AcuerdoOrderByWithRelationInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contratoId?: SortOrder
    servicioId?: SortOrder
    procedimiento?: ProcedimientoOrderByRelationAggregateInput
    contrato?: ContratoOrderByWithRelationInput
    servicio?: ServicioOrderByWithRelationInput
  }

  export type AcuerdoWhereUniqueInput = Prisma.AtLeast<{
    id_acuerdo?: number
    AND?: AcuerdoWhereInput | AcuerdoWhereInput[]
    OR?: AcuerdoWhereInput[]
    NOT?: AcuerdoWhereInput | AcuerdoWhereInput[]
    estado?: EnumEstadoFilter<"Acuerdo"> | $Enums.Estado
    precio?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFilter<"Acuerdo"> | Date | string
    updateAt?: DateTimeFilter<"Acuerdo"> | Date | string
    contratoId?: IntFilter<"Acuerdo"> | number
    servicioId?: IntFilter<"Acuerdo"> | number
    procedimiento?: ProcedimientoListRelationFilter
    contrato?: XOR<ContratoRelationFilter, ContratoWhereInput>
    servicio?: XOR<ServicioRelationFilter, ServicioWhereInput>
  }, "id_acuerdo">

  export type AcuerdoOrderByWithAggregationInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contratoId?: SortOrder
    servicioId?: SortOrder
    _count?: AcuerdoCountOrderByAggregateInput
    _avg?: AcuerdoAvgOrderByAggregateInput
    _max?: AcuerdoMaxOrderByAggregateInput
    _min?: AcuerdoMinOrderByAggregateInput
    _sum?: AcuerdoSumOrderByAggregateInput
  }

  export type AcuerdoScalarWhereWithAggregatesInput = {
    AND?: AcuerdoScalarWhereWithAggregatesInput | AcuerdoScalarWhereWithAggregatesInput[]
    OR?: AcuerdoScalarWhereWithAggregatesInput[]
    NOT?: AcuerdoScalarWhereWithAggregatesInput | AcuerdoScalarWhereWithAggregatesInput[]
    id_acuerdo?: IntWithAggregatesFilter<"Acuerdo"> | number
    estado?: EnumEstadoWithAggregatesFilter<"Acuerdo"> | $Enums.Estado
    precio?: DecimalWithAggregatesFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalWithAggregatesFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeWithAggregatesFilter<"Acuerdo"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Acuerdo"> | Date | string
    contratoId?: IntWithAggregatesFilter<"Acuerdo"> | number
    servicioId?: IntWithAggregatesFilter<"Acuerdo"> | number
  }

  export type PaqueteWhereInput = {
    AND?: PaqueteWhereInput | PaqueteWhereInput[]
    OR?: PaqueteWhereInput[]
    NOT?: PaqueteWhereInput | PaqueteWhereInput[]
    id_paquete?: IntFilter<"Paquete"> | number
    estado?: EnumEstadoFilter<"Paquete"> | $Enums.Estado
    examenId?: IntFilter<"Paquete"> | number
    servicioId?: IntFilter<"Paquete"> | number
    estudio?: EstudioListRelationFilter
    examen?: XOR<ExamenRelationFilter, ExamenWhereInput>
    servicio?: XOR<ServicioRelationFilter, ServicioWhereInput>
  }

  export type PaqueteOrderByWithRelationInput = {
    id_paquete?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
    servicioId?: SortOrder
    estudio?: EstudioOrderByRelationAggregateInput
    examen?: ExamenOrderByWithRelationInput
    servicio?: ServicioOrderByWithRelationInput
  }

  export type PaqueteWhereUniqueInput = Prisma.AtLeast<{
    id_paquete?: number
    AND?: PaqueteWhereInput | PaqueteWhereInput[]
    OR?: PaqueteWhereInput[]
    NOT?: PaqueteWhereInput | PaqueteWhereInput[]
    estado?: EnumEstadoFilter<"Paquete"> | $Enums.Estado
    examenId?: IntFilter<"Paquete"> | number
    servicioId?: IntFilter<"Paquete"> | number
    estudio?: EstudioListRelationFilter
    examen?: XOR<ExamenRelationFilter, ExamenWhereInput>
    servicio?: XOR<ServicioRelationFilter, ServicioWhereInput>
  }, "id_paquete">

  export type PaqueteOrderByWithAggregationInput = {
    id_paquete?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
    servicioId?: SortOrder
    _count?: PaqueteCountOrderByAggregateInput
    _avg?: PaqueteAvgOrderByAggregateInput
    _max?: PaqueteMaxOrderByAggregateInput
    _min?: PaqueteMinOrderByAggregateInput
    _sum?: PaqueteSumOrderByAggregateInput
  }

  export type PaqueteScalarWhereWithAggregatesInput = {
    AND?: PaqueteScalarWhereWithAggregatesInput | PaqueteScalarWhereWithAggregatesInput[]
    OR?: PaqueteScalarWhereWithAggregatesInput[]
    NOT?: PaqueteScalarWhereWithAggregatesInput | PaqueteScalarWhereWithAggregatesInput[]
    id_paquete?: IntWithAggregatesFilter<"Paquete"> | number
    estado?: EnumEstadoWithAggregatesFilter<"Paquete"> | $Enums.Estado
    examenId?: IntWithAggregatesFilter<"Paquete"> | number
    servicioId?: IntWithAggregatesFilter<"Paquete"> | number
  }

  export type PacienteCreateInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    procedimiento?: ProcedimientoCreateNestedManyWithoutPacienteInput
    municipio: MunicipioCreateNestedOneWithoutPacienteInput
    eps: EpsCreateNestedOneWithoutPacienteInput
  }

  export type PacienteUncheckedCreateInput = {
    id_paciente?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    municipioId: number
    epsId: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUpdateInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    procedimiento?: ProcedimientoUpdateManyWithoutPacienteNestedInput
    municipio?: MunicipioUpdateOneRequiredWithoutPacienteNestedInput
    eps?: EpsUpdateOneRequiredWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipioId?: IntFieldUpdateOperationsInput | number
    epsId?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteCreateManyInput = {
    id_paciente?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    municipioId: number
    epsId: number
  }

  export type PacienteUpdateManyMutationInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PacienteUncheckedUpdateManyInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipioId?: IntFieldUpdateOperationsInput | number
    epsId?: IntFieldUpdateOperationsInput | number
  }

  export type EpsCreateInput = {
    codigo: string
    nombre: string
    estado?: $Enums.Estado
    paciente?: PacienteCreateNestedManyWithoutEpsInput
  }

  export type EpsUncheckedCreateInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado?: $Enums.Estado
    paciente?: PacienteUncheckedCreateNestedManyWithoutEpsInput
  }

  export type EpsUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    paciente?: PacienteUpdateManyWithoutEpsNestedInput
  }

  export type EpsUncheckedUpdateInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    paciente?: PacienteUncheckedUpdateManyWithoutEpsNestedInput
  }

  export type EpsCreateManyInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado?: $Enums.Estado
  }

  export type EpsUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EpsUncheckedUpdateManyInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ProcedimientoCreateInput = {
    nombre: string
    procedimiento?: ProcedimientoCreateNestedManyWithoutTipo_procedimientoInput
  }

  export type Tipo_ProcedimientoUncheckedCreateInput = {
    id_tipo_procedimiento?: number
    nombre: string
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutTipo_procedimientoInput
  }

  export type Tipo_ProcedimientoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    procedimiento?: ProcedimientoUpdateManyWithoutTipo_procedimientoNestedInput
  }

  export type Tipo_ProcedimientoUncheckedUpdateInput = {
    id_tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutTipo_procedimientoNestedInput
  }

  export type Tipo_ProcedimientoCreateManyInput = {
    id_tipo_procedimiento?: number
    nombre: string
  }

  export type Tipo_ProcedimientoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type Tipo_ProcedimientoUncheckedUpdateManyInput = {
    id_tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProcedimientoCreateInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutProcedimientoInput
    acuerdo: AcuerdoCreateNestedOneWithoutProcedimientoInput
    tipo_procedimiento: Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput
    paciente: PacienteCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    acuerdoId: number
    tipo_procedimientoId: number
    pacienteId: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutProcedimientoInput
  }

  export type ProcedimientoUpdateInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutProcedimientoNestedInput
    acuerdo?: AcuerdoUpdateOneRequiredWithoutProcedimientoNestedInput
    tipo_procedimiento?: Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acuerdoId?: IntFieldUpdateOperationsInput | number
    tipo_procedimientoId?: IntFieldUpdateOperationsInput | number
    pacienteId?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutProcedimientoNestedInput
  }

  export type ProcedimientoCreateManyInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    acuerdoId: number
    tipo_procedimientoId: number
    pacienteId: number
  }

  export type ProcedimientoUpdateManyMutationInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedimientoUncheckedUpdateManyInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acuerdoId?: IntFieldUpdateOperationsInput | number
    tipo_procedimientoId?: IntFieldUpdateOperationsInput | number
    pacienteId?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateInput = {
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    paquete: PaqueteCreateNestedOneWithoutEstudioInput
    procedimiento: ProcedimientoCreateNestedOneWithoutEstudioInput
  }

  export type EstudioUncheckedCreateInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    paqueteId: number
    procedimientoId: number
  }

  export type EstudioUpdateInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    paquete?: PaqueteUpdateOneRequiredWithoutEstudioNestedInput
    procedimiento?: ProcedimientoUpdateOneRequiredWithoutEstudioNestedInput
  }

  export type EstudioUncheckedUpdateInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    paqueteId?: IntFieldUpdateOperationsInput | number
    procedimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateManyInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    paqueteId: number
    procedimientoId: number
  }

  export type EstudioUpdateManyMutationInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioUncheckedUpdateManyInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    paqueteId?: IntFieldUpdateOperationsInput | number
    procedimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type DepartamentoCreateInput = {
    nombre: string
    municipio?: MunicipioCreateNestedManyWithoutDepartamentoInput
  }

  export type DepartamentoUncheckedCreateInput = {
    id_departamento?: number
    nombre: string
    municipio?: MunicipioUncheckedCreateNestedManyWithoutDepartamentoInput
  }

  export type DepartamentoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    municipio?: MunicipioUpdateManyWithoutDepartamentoNestedInput
  }

  export type DepartamentoUncheckedUpdateInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    municipio?: MunicipioUncheckedUpdateManyWithoutDepartamentoNestedInput
  }

  export type DepartamentoCreateManyInput = {
    id_departamento?: number
    nombre: string
  }

  export type DepartamentoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentoUncheckedUpdateManyInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipioCreateInput = {
    nombre: string
    departamento: DepartamentoCreateNestedOneWithoutMunicipioInput
    paciente?: PacienteCreateNestedManyWithoutMunicipioInput
    empresa?: EmpresaCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateInput = {
    id_municipio?: number
    nombre: string
    departamentoId: number
    paciente?: PacienteUncheckedCreateNestedManyWithoutMunicipioInput
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
    paciente?: PacienteUpdateManyWithoutMunicipioNestedInput
    empresa?: EmpresaUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamentoId?: IntFieldUpdateOperationsInput | number
    paciente?: PacienteUncheckedUpdateManyWithoutMunicipioNestedInput
    empresa?: EmpresaUncheckedUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioCreateManyInput = {
    id_municipio?: number
    nombre: string
    departamentoId: number
  }

  export type MunicipioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipioUncheckedUpdateManyInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamentoId?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ServicioCreateInput = {
    nombre: string
    estado?: $Enums.Estado
    servicio?: ServicioCreateNestedManyWithoutTipo_servicioInput
  }

  export type Tipo_ServicioUncheckedCreateInput = {
    id_tipo_servicio?: number
    nombre: string
    estado?: $Enums.Estado
    servicio?: ServicioUncheckedCreateNestedManyWithoutTipo_servicioInput
  }

  export type Tipo_ServicioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUpdateManyWithoutTipo_servicioNestedInput
  }

  export type Tipo_ServicioUncheckedUpdateInput = {
    id_tipo_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUncheckedUpdateManyWithoutTipo_servicioNestedInput
  }

  export type Tipo_ServicioCreateManyInput = {
    id_tipo_servicio?: number
    nombre: string
    estado?: $Enums.Estado
  }

  export type Tipo_ServicioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ServicioUncheckedUpdateManyInput = {
    id_tipo_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ServicioCreateInput = {
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    paquete?: PaqueteCreateNestedManyWithoutServicioInput
    acuerdo?: AcuerdoCreateNestedManyWithoutServicioInput
    tipo_servicio: Tipo_ServicioCreateNestedOneWithoutServicioInput
    prestador: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateInput = {
    id_servicio?: number
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_servicioId: number
    prestadorId: number
    paquete?: PaqueteUncheckedCreateNestedManyWithoutServicioInput
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    paquete?: PaqueteUpdateManyWithoutServicioNestedInput
    acuerdo?: AcuerdoUpdateManyWithoutServicioNestedInput
    tipo_servicio?: Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput
    prestador?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_servicioId?: IntFieldUpdateOperationsInput | number
    prestadorId?: IntFieldUpdateOperationsInput | number
    paquete?: PaqueteUncheckedUpdateManyWithoutServicioNestedInput
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ServicioCreateManyInput = {
    id_servicio?: number
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_servicioId: number
    prestadorId: number
  }

  export type ServicioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ServicioUncheckedUpdateManyInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_servicioId?: IntFieldUpdateOperationsInput | number
    prestadorId?: IntFieldUpdateOperationsInput | number
  }

  export type ExamenCreateInput = {
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_examen: Tipo_ExamenCreateNestedOneWithoutExamenInput
    tipo_resultado?: Tipo_ResultadoCreateNestedManyWithoutExamenInput
    paquete?: PaqueteCreateNestedManyWithoutExamenInput
  }

  export type ExamenUncheckedCreateInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_examenId: number
    tipo_resultado?: Tipo_ResultadoUncheckedCreateNestedManyWithoutExamenInput
    paquete?: PaqueteUncheckedCreateNestedManyWithoutExamenInput
  }

  export type ExamenUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examen?: Tipo_ExamenUpdateOneRequiredWithoutExamenNestedInput
    tipo_resultado?: Tipo_ResultadoUpdateManyWithoutExamenNestedInput
    paquete?: PaqueteUpdateManyWithoutExamenNestedInput
  }

  export type ExamenUncheckedUpdateInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examenId?: IntFieldUpdateOperationsInput | number
    tipo_resultado?: Tipo_ResultadoUncheckedUpdateManyWithoutExamenNestedInput
    paquete?: PaqueteUncheckedUpdateManyWithoutExamenNestedInput
  }

  export type ExamenCreateManyInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_examenId: number
  }

  export type ExamenUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ExamenUncheckedUpdateManyInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examenId?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ResultadoCreateInput = {
    nombre: string
    estado?: $Enums.Estado
    examen: ExamenCreateNestedOneWithoutTipo_resultadoInput
  }

  export type Tipo_ResultadoUncheckedCreateInput = {
    id_tipo_resultado?: number
    nombre: string
    estado?: $Enums.Estado
    examenId: number
  }

  export type Tipo_ResultadoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examen?: ExamenUpdateOneRequiredWithoutTipo_resultadoNestedInput
  }

  export type Tipo_ResultadoUncheckedUpdateInput = {
    id_tipo_resultado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examenId?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ResultadoCreateManyInput = {
    id_tipo_resultado?: number
    nombre: string
    estado?: $Enums.Estado
    examenId: number
  }

  export type Tipo_ResultadoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ResultadoUncheckedUpdateManyInput = {
    id_tipo_resultado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examenId?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ExamenCreateInput = {
    nombre: string
    estado?: $Enums.Estado
    examen?: ExamenCreateNestedManyWithoutTipo_examenInput
  }

  export type Tipo_ExamenUncheckedCreateInput = {
    id_tipo_examen?: number
    nombre: string
    estado?: $Enums.Estado
    examen?: ExamenUncheckedCreateNestedManyWithoutTipo_examenInput
  }

  export type Tipo_ExamenUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examen?: ExamenUpdateManyWithoutTipo_examenNestedInput
  }

  export type Tipo_ExamenUncheckedUpdateInput = {
    id_tipo_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examen?: ExamenUncheckedUpdateManyWithoutTipo_examenNestedInput
  }

  export type Tipo_ExamenCreateManyInput = {
    id_tipo_examen?: number
    nombre: string
    estado?: $Enums.Estado
  }

  export type Tipo_ExamenUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ExamenUncheckedUpdateManyInput = {
    id_tipo_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PrestadorCreateInput = {
    codigo: string
    nit: string
    razon_social: string
    servicio?: ServicioCreateNestedManyWithoutPrestadorInput
    usuario?: UsuarioCreateNestedManyWithoutPrestadorInput
  }

  export type PrestadorUncheckedCreateInput = {
    id_prestador?: number
    codigo: string
    nit: string
    razon_social: string
    servicio?: ServicioUncheckedCreateNestedManyWithoutPrestadorInput
    usuario?: UsuarioUncheckedCreateNestedManyWithoutPrestadorInput
  }

  export type PrestadorUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    servicio?: ServicioUpdateManyWithoutPrestadorNestedInput
    usuario?: UsuarioUpdateManyWithoutPrestadorNestedInput
  }

  export type PrestadorUncheckedUpdateInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    servicio?: ServicioUncheckedUpdateManyWithoutPrestadorNestedInput
    usuario?: UsuarioUncheckedUpdateManyWithoutPrestadorNestedInput
  }

  export type PrestadorCreateManyInput = {
    id_prestador?: number
    codigo: string
    nit: string
    razon_social: string
  }

  export type PrestadorUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
  }

  export type PrestadorUncheckedUpdateManyInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateInput = {
    identificacion: string
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado?: $Enums.Estado
    prestador: PrestadorCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id_usuario?: number
    identificacion: string
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado?: $Enums.Estado
    prestadorId: number
  }

  export type UsuarioUpdateInput = {
    identificacion?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    prestador?: PrestadorUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    identificacion?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    prestadorId?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateManyInput = {
    id_usuario?: number
    identificacion: string
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado?: $Enums.Estado
    prestadorId: number
  }

  export type UsuarioUpdateManyMutationInput = {
    identificacion?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    identificacion?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    prestadorId?: IntFieldUpdateOperationsInput | number
  }

  export type EmpresaCreateInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado?: $Enums.Estado
    municipio: MunicipioCreateNestedOneWithoutEmpresaInput
    contrato?: ContratoCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado?: $Enums.Estado
    municipioId: number
    contrato?: ContratoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUpdateInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: MunicipioUpdateOneRequiredWithoutEmpresaNestedInput
    contrato?: ContratoUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipioId?: IntFieldUpdateOperationsInput | number
    contrato?: ContratoUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateManyInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado?: $Enums.Estado
    municipioId: number
  }

  export type EmpresaUpdateManyMutationInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EmpresaUncheckedUpdateManyInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipioId?: IntFieldUpdateOperationsInput | number
  }

  export type ContratoCreateInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado?: $Enums.Estado
    empresa: EmpresaCreateNestedOneWithoutContratoInput
    acuerdo?: AcuerdoCreateNestedManyWithoutContratoInput
  }

  export type ContratoUncheckedCreateInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado?: $Enums.Estado
    empresaId: number
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutContratoInput
  }

  export type ContratoUpdateInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: EmpresaUpdateOneRequiredWithoutContratoNestedInput
    acuerdo?: AcuerdoUpdateManyWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresaId?: IntFieldUpdateOperationsInput | number
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutContratoNestedInput
  }

  export type ContratoCreateManyInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado?: $Enums.Estado
    empresaId: number
  }

  export type ContratoUpdateManyMutationInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ContratoUncheckedUpdateManyInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresaId?: IntFieldUpdateOperationsInput | number
  }

  export type AcuerdoCreateInput = {
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutAcuerdoInput
    contrato: ContratoCreateNestedOneWithoutAcuerdoInput
    servicio: ServicioCreateNestedOneWithoutAcuerdoInput
  }

  export type AcuerdoUncheckedCreateInput = {
    id_acuerdo?: number
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    contratoId: number
    servicioId: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutAcuerdoInput
  }

  export type AcuerdoUpdateInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutAcuerdoNestedInput
    contrato?: ContratoUpdateOneRequiredWithoutAcuerdoNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contratoId?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutAcuerdoNestedInput
  }

  export type AcuerdoCreateManyInput = {
    id_acuerdo?: number
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    contratoId: number
    servicioId: number
  }

  export type AcuerdoUpdateManyMutationInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcuerdoUncheckedUpdateManyInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contratoId?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteCreateInput = {
    estado?: $Enums.Estado
    estudio?: EstudioCreateNestedManyWithoutPaqueteInput
    examen: ExamenCreateNestedOneWithoutPaqueteInput
    servicio: ServicioCreateNestedOneWithoutPaqueteInput
  }

  export type PaqueteUncheckedCreateInput = {
    id_paquete?: number
    estado?: $Enums.Estado
    examenId: number
    servicioId: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutPaqueteInput
  }

  export type PaqueteUpdateInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    estudio?: EstudioUpdateManyWithoutPaqueteNestedInput
    examen?: ExamenUpdateOneRequiredWithoutPaqueteNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutPaqueteNestedInput
  }

  export type PaqueteUncheckedUpdateInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examenId?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutPaqueteNestedInput
  }

  export type PaqueteCreateManyInput = {
    id_paquete?: number
    estado?: $Enums.Estado
    examenId: number
    servicioId: number
  }

  export type PaqueteUpdateManyMutationInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PaqueteUncheckedUpdateManyInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examenId?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumTipo_IdentFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentFilter<$PrismaModel> | $Enums.Tipo_Ident
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumSexFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexFilter<$PrismaModel> | $Enums.Sex
  }

  export type EnumTipo_PacienteFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Paciente | EnumTipo_PacienteFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Paciente[]
    notIn?: $Enums.Tipo_Paciente[]
    not?: NestedEnumTipo_PacienteFilter<$PrismaModel> | $Enums.Tipo_Paciente
  }

  export type EnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type ProcedimientoListRelationFilter = {
    every?: ProcedimientoWhereInput
    some?: ProcedimientoWhereInput
    none?: ProcedimientoWhereInput
  }

  export type MunicipioRelationFilter = {
    is?: MunicipioWhereInput
    isNot?: MunicipioWhereInput
  }

  export type EpsRelationFilter = {
    is?: EpsWhereInput
    isNot?: EpsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProcedimientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PacienteCountOrderByAggregateInput = {
    id_paciente?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    tipo_paciente?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
    epsId?: SortOrder
  }

  export type PacienteAvgOrderByAggregateInput = {
    id_paciente?: SortOrder
    municipioId?: SortOrder
    epsId?: SortOrder
  }

  export type PacienteMaxOrderByAggregateInput = {
    id_paciente?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    tipo_paciente?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
    epsId?: SortOrder
  }

  export type PacienteMinOrderByAggregateInput = {
    id_paciente?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    tipo_paciente?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
    epsId?: SortOrder
  }

  export type PacienteSumOrderByAggregateInput = {
    id_paciente?: SortOrder
    municipioId?: SortOrder
    epsId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTipo_IdentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Ident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_IdentFilter<$PrismaModel>
    _max?: NestedEnumTipo_IdentFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexWithAggregatesFilter<$PrismaModel> | $Enums.Sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexFilter<$PrismaModel>
    _max?: NestedEnumSexFilter<$PrismaModel>
  }

  export type EnumTipo_PacienteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Paciente | EnumTipo_PacienteFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Paciente[]
    notIn?: $Enums.Tipo_Paciente[]
    not?: NestedEnumTipo_PacienteWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Paciente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_PacienteFilter<$PrismaModel>
    _max?: NestedEnumTipo_PacienteFilter<$PrismaModel>
  }

  export type EnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type PacienteListRelationFilter = {
    every?: PacienteWhereInput
    some?: PacienteWhereInput
    none?: PacienteWhereInput
  }

  export type PacienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EpsCountOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsAvgOrderByAggregateInput = {
    id_eps?: SortOrder
  }

  export type EpsMaxOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsMinOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsSumOrderByAggregateInput = {
    id_eps?: SortOrder
  }

  export type Tipo_ProcedimientoCountOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
  }

  export type Tipo_ProcedimientoAvgOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
  }

  export type Tipo_ProcedimientoMaxOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
  }

  export type Tipo_ProcedimientoMinOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
    nombre?: SortOrder
  }

  export type Tipo_ProcedimientoSumOrderByAggregateInput = {
    id_tipo_procedimiento?: SortOrder
  }

  export type EstudioListRelationFilter = {
    every?: EstudioWhereInput
    some?: EstudioWhereInput
    none?: EstudioWhereInput
  }

  export type AcuerdoRelationFilter = {
    is?: AcuerdoWhereInput
    isNot?: AcuerdoWhereInput
  }

  export type Tipo_ProcedimientoRelationFilter = {
    is?: Tipo_ProcedimientoWhereInput
    isNot?: Tipo_ProcedimientoWhereInput
  }

  export type PacienteRelationFilter = {
    is?: PacienteWhereInput
    isNot?: PacienteWhereInput
  }

  export type EstudioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcedimientoCountOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    acuerdoId?: SortOrder
    tipo_procedimientoId?: SortOrder
    pacienteId?: SortOrder
  }

  export type ProcedimientoAvgOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    acuerdoId?: SortOrder
    tipo_procedimientoId?: SortOrder
    pacienteId?: SortOrder
  }

  export type ProcedimientoMaxOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    acuerdoId?: SortOrder
    tipo_procedimientoId?: SortOrder
    pacienteId?: SortOrder
  }

  export type ProcedimientoMinOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    fecha?: SortOrder
    edad_persona?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    acuerdoId?: SortOrder
    tipo_procedimientoId?: SortOrder
    pacienteId?: SortOrder
  }

  export type ProcedimientoSumOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    factura?: SortOrder
    acuerdoId?: SortOrder
    tipo_procedimientoId?: SortOrder
    pacienteId?: SortOrder
  }

  export type PaqueteRelationFilter = {
    is?: PaqueteWhereInput
    isNot?: PaqueteWhereInput
  }

  export type ProcedimientoRelationFilter = {
    is?: ProcedimientoWhereInput
    isNot?: ProcedimientoWhereInput
  }

  export type EstudioCountOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    paqueteId?: SortOrder
    procedimientoId?: SortOrder
  }

  export type EstudioAvgOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    profesional?: SortOrder
    paqueteId?: SortOrder
    procedimientoId?: SortOrder
  }

  export type EstudioMaxOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    paqueteId?: SortOrder
    procedimientoId?: SortOrder
  }

  export type EstudioMinOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    fecha_muestra?: SortOrder
    fecha_resultado?: SortOrder
    resultado?: SortOrder
    observacion?: SortOrder
    profesional?: SortOrder
    paqueteId?: SortOrder
    procedimientoId?: SortOrder
  }

  export type EstudioSumOrderByAggregateInput = {
    id_estudio?: SortOrder
    consecutivo?: SortOrder
    cantidad?: SortOrder
    profesional?: SortOrder
    paqueteId?: SortOrder
    procedimientoId?: SortOrder
  }

  export type MunicipioListRelationFilter = {
    every?: MunicipioWhereInput
    some?: MunicipioWhereInput
    none?: MunicipioWhereInput
  }

  export type MunicipioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartamentoCountOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoAvgOrderByAggregateInput = {
    id_departamento?: SortOrder
  }

  export type DepartamentoMaxOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoMinOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoSumOrderByAggregateInput = {
    id_departamento?: SortOrder
  }

  export type DepartamentoRelationFilter = {
    is?: DepartamentoWhereInput
    isNot?: DepartamentoWhereInput
  }

  export type EmpresaListRelationFilter = {
    every?: EmpresaWhereInput
    some?: EmpresaWhereInput
    none?: EmpresaWhereInput
  }

  export type EmpresaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipioCountOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamentoId?: SortOrder
  }

  export type MunicipioAvgOrderByAggregateInput = {
    id_municipio?: SortOrder
    departamentoId?: SortOrder
  }

  export type MunicipioMaxOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamentoId?: SortOrder
  }

  export type MunicipioMinOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamentoId?: SortOrder
  }

  export type MunicipioSumOrderByAggregateInput = {
    id_municipio?: SortOrder
    departamentoId?: SortOrder
  }

  export type ServicioListRelationFilter = {
    every?: ServicioWhereInput
    some?: ServicioWhereInput
    none?: ServicioWhereInput
  }

  export type ServicioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Tipo_ServicioCountOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ServicioAvgOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
  }

  export type Tipo_ServicioMaxOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ServicioMinOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ServicioSumOrderByAggregateInput = {
    id_tipo_servicio?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PaqueteListRelationFilter = {
    every?: PaqueteWhereInput
    some?: PaqueteWhereInput
    none?: PaqueteWhereInput
  }

  export type AcuerdoListRelationFilter = {
    every?: AcuerdoWhereInput
    some?: AcuerdoWhereInput
    none?: AcuerdoWhereInput
  }

  export type Tipo_ServicioRelationFilter = {
    is?: Tipo_ServicioWhereInput
    isNot?: Tipo_ServicioWhereInput
  }

  export type PrestadorRelationFilter = {
    is?: PrestadorWhereInput
    isNot?: PrestadorWhereInput
  }

  export type PaqueteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcuerdoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicioCountOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    nivel?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_servicioId?: SortOrder
    prestadorId?: SortOrder
  }

  export type ServicioAvgOrderByAggregateInput = {
    id_servicio?: SortOrder
    nivel?: SortOrder
    precio?: SortOrder
    tipo_servicioId?: SortOrder
    prestadorId?: SortOrder
  }

  export type ServicioMaxOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    nivel?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_servicioId?: SortOrder
    prestadorId?: SortOrder
  }

  export type ServicioMinOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    nivel?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_servicioId?: SortOrder
    prestadorId?: SortOrder
  }

  export type ServicioSumOrderByAggregateInput = {
    id_servicio?: SortOrder
    nivel?: SortOrder
    precio?: SortOrder
    tipo_servicioId?: SortOrder
    prestadorId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Tipo_ExamenRelationFilter = {
    is?: Tipo_ExamenWhereInput
    isNot?: Tipo_ExamenWhereInput
  }

  export type Tipo_ResultadoListRelationFilter = {
    every?: Tipo_ResultadoWhereInput
    some?: Tipo_ResultadoWhereInput
    none?: Tipo_ResultadoWhereInput
  }

  export type Tipo_ResultadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamenCountOrderByAggregateInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examenId?: SortOrder
  }

  export type ExamenAvgOrderByAggregateInput = {
    id_examen?: SortOrder
    precio?: SortOrder
    tipo_examenId?: SortOrder
  }

  export type ExamenMaxOrderByAggregateInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examenId?: SortOrder
  }

  export type ExamenMinOrderByAggregateInput = {
    id_examen?: SortOrder
    nombre?: SortOrder
    unidades?: SortOrder
    rango_biologico?: SortOrder
    metodo?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    tipo_examenId?: SortOrder
  }

  export type ExamenSumOrderByAggregateInput = {
    id_examen?: SortOrder
    precio?: SortOrder
    tipo_examenId?: SortOrder
  }

  export type ExamenRelationFilter = {
    is?: ExamenWhereInput
    isNot?: ExamenWhereInput
  }

  export type Tipo_ResultadoCountOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
  }

  export type Tipo_ResultadoAvgOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    examenId?: SortOrder
  }

  export type Tipo_ResultadoMaxOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
  }

  export type Tipo_ResultadoMinOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
  }

  export type Tipo_ResultadoSumOrderByAggregateInput = {
    id_tipo_resultado?: SortOrder
    examenId?: SortOrder
  }

  export type ExamenListRelationFilter = {
    every?: ExamenWhereInput
    some?: ExamenWhereInput
    none?: ExamenWhereInput
  }

  export type ExamenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Tipo_ExamenCountOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ExamenAvgOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
  }

  export type Tipo_ExamenMaxOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ExamenMinOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type Tipo_ExamenSumOrderByAggregateInput = {
    id_tipo_examen?: SortOrder
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrestadorCountOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
  }

  export type PrestadorAvgOrderByAggregateInput = {
    id_prestador?: SortOrder
  }

  export type PrestadorMaxOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
  }

  export type PrestadorMinOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    nit?: SortOrder
    razon_social?: SortOrder
  }

  export type PrestadorSumOrderByAggregateInput = {
    id_prestador?: SortOrder
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type UsuarioCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestadorId?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    prestadorId?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestadorId?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    email?: SortOrder
    password?: SortOrder
    estado?: SortOrder
    prestadorId?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    prestadorId?: SortOrder
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type EnumTipo_EmpresaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaFilter<$PrismaModel> | $Enums.Tipo_Empresa
  }

  export type ContratoListRelationFilter = {
    every?: ContratoWhereInput
    some?: ContratoWhereInput
    none?: ContratoWhereInput
  }

  export type ContratoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaCountOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
  }

  export type EmpresaAvgOrderByAggregateInput = {
    id_empresa?: SortOrder
    codigo?: SortOrder
    municipioId?: SortOrder
  }

  export type EmpresaMaxOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
  }

  export type EmpresaMinOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipioId?: SortOrder
  }

  export type EmpresaSumOrderByAggregateInput = {
    id_empresa?: SortOrder
    codigo?: SortOrder
    municipioId?: SortOrder
  }

  export type EnumTipo_EmpresaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Empresa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
    _max?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
  }

  export type EmpresaRelationFilter = {
    is?: EmpresaWhereInput
    isNot?: EmpresaWhereInput
  }

  export type ContratoCountOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresaId?: SortOrder
  }

  export type ContratoAvgOrderByAggregateInput = {
    id_contrato?: SortOrder
    empresaId?: SortOrder
  }

  export type ContratoMaxOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresaId?: SortOrder
  }

  export type ContratoMinOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresaId?: SortOrder
  }

  export type ContratoSumOrderByAggregateInput = {
    id_contrato?: SortOrder
    empresaId?: SortOrder
  }

  export type ContratoRelationFilter = {
    is?: ContratoWhereInput
    isNot?: ContratoWhereInput
  }

  export type ServicioRelationFilter = {
    is?: ServicioWhereInput
    isNot?: ServicioWhereInput
  }

  export type AcuerdoCountOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contratoId?: SortOrder
    servicioId?: SortOrder
  }

  export type AcuerdoAvgOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    contratoId?: SortOrder
    servicioId?: SortOrder
  }

  export type AcuerdoMaxOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contratoId?: SortOrder
    servicioId?: SortOrder
  }

  export type AcuerdoMinOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    contratoId?: SortOrder
    servicioId?: SortOrder
  }

  export type AcuerdoSumOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    contratoId?: SortOrder
    servicioId?: SortOrder
  }

  export type PaqueteCountOrderByAggregateInput = {
    id_paquete?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
    servicioId?: SortOrder
  }

  export type PaqueteAvgOrderByAggregateInput = {
    id_paquete?: SortOrder
    examenId?: SortOrder
    servicioId?: SortOrder
  }

  export type PaqueteMaxOrderByAggregateInput = {
    id_paquete?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
    servicioId?: SortOrder
  }

  export type PaqueteMinOrderByAggregateInput = {
    id_paquete?: SortOrder
    estado?: SortOrder
    examenId?: SortOrder
    servicioId?: SortOrder
  }

  export type PaqueteSumOrderByAggregateInput = {
    id_paquete?: SortOrder
    examenId?: SortOrder
    servicioId?: SortOrder
  }

  export type ProcedimientoCreateNestedManyWithoutPacienteInput = {
    create?: XOR<ProcedimientoCreateWithoutPacienteInput, ProcedimientoUncheckedCreateWithoutPacienteInput> | ProcedimientoCreateWithoutPacienteInput[] | ProcedimientoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutPacienteInput | ProcedimientoCreateOrConnectWithoutPacienteInput[]
    createMany?: ProcedimientoCreateManyPacienteInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type MunicipioCreateNestedOneWithoutPacienteInput = {
    create?: XOR<MunicipioCreateWithoutPacienteInput, MunicipioUncheckedCreateWithoutPacienteInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutPacienteInput
    connect?: MunicipioWhereUniqueInput
  }

  export type EpsCreateNestedOneWithoutPacienteInput = {
    create?: XOR<EpsCreateWithoutPacienteInput, EpsUncheckedCreateWithoutPacienteInput>
    connectOrCreate?: EpsCreateOrConnectWithoutPacienteInput
    connect?: EpsWhereUniqueInput
  }

  export type ProcedimientoUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<ProcedimientoCreateWithoutPacienteInput, ProcedimientoUncheckedCreateWithoutPacienteInput> | ProcedimientoCreateWithoutPacienteInput[] | ProcedimientoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutPacienteInput | ProcedimientoCreateOrConnectWithoutPacienteInput[]
    createMany?: ProcedimientoCreateManyPacienteInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type EnumTipo_IdentFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Ident
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumSexFieldUpdateOperationsInput = {
    set?: $Enums.Sex
  }

  export type EnumTipo_PacienteFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Paciente
  }

  export type EnumEstadoFieldUpdateOperationsInput = {
    set?: $Enums.Estado
  }

  export type ProcedimientoUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutPacienteInput, ProcedimientoUncheckedCreateWithoutPacienteInput> | ProcedimientoCreateWithoutPacienteInput[] | ProcedimientoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutPacienteInput | ProcedimientoCreateOrConnectWithoutPacienteInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutPacienteInput | ProcedimientoUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: ProcedimientoCreateManyPacienteInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutPacienteInput | ProcedimientoUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutPacienteInput | ProcedimientoUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type MunicipioUpdateOneRequiredWithoutPacienteNestedInput = {
    create?: XOR<MunicipioCreateWithoutPacienteInput, MunicipioUncheckedCreateWithoutPacienteInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutPacienteInput
    upsert?: MunicipioUpsertWithoutPacienteInput
    connect?: MunicipioWhereUniqueInput
    update?: XOR<XOR<MunicipioUpdateToOneWithWhereWithoutPacienteInput, MunicipioUpdateWithoutPacienteInput>, MunicipioUncheckedUpdateWithoutPacienteInput>
  }

  export type EpsUpdateOneRequiredWithoutPacienteNestedInput = {
    create?: XOR<EpsCreateWithoutPacienteInput, EpsUncheckedCreateWithoutPacienteInput>
    connectOrCreate?: EpsCreateOrConnectWithoutPacienteInput
    upsert?: EpsUpsertWithoutPacienteInput
    connect?: EpsWhereUniqueInput
    update?: XOR<XOR<EpsUpdateToOneWithWhereWithoutPacienteInput, EpsUpdateWithoutPacienteInput>, EpsUncheckedUpdateWithoutPacienteInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProcedimientoUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutPacienteInput, ProcedimientoUncheckedCreateWithoutPacienteInput> | ProcedimientoCreateWithoutPacienteInput[] | ProcedimientoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutPacienteInput | ProcedimientoCreateOrConnectWithoutPacienteInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutPacienteInput | ProcedimientoUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: ProcedimientoCreateManyPacienteInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutPacienteInput | ProcedimientoUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutPacienteInput | ProcedimientoUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type PacienteCreateNestedManyWithoutEpsInput = {
    create?: XOR<PacienteCreateWithoutEpsInput, PacienteUncheckedCreateWithoutEpsInput> | PacienteCreateWithoutEpsInput[] | PacienteUncheckedCreateWithoutEpsInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutEpsInput | PacienteCreateOrConnectWithoutEpsInput[]
    createMany?: PacienteCreateManyEpsInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type PacienteUncheckedCreateNestedManyWithoutEpsInput = {
    create?: XOR<PacienteCreateWithoutEpsInput, PacienteUncheckedCreateWithoutEpsInput> | PacienteCreateWithoutEpsInput[] | PacienteUncheckedCreateWithoutEpsInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutEpsInput | PacienteCreateOrConnectWithoutEpsInput[]
    createMany?: PacienteCreateManyEpsInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type PacienteUpdateManyWithoutEpsNestedInput = {
    create?: XOR<PacienteCreateWithoutEpsInput, PacienteUncheckedCreateWithoutEpsInput> | PacienteCreateWithoutEpsInput[] | PacienteUncheckedCreateWithoutEpsInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutEpsInput | PacienteCreateOrConnectWithoutEpsInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutEpsInput | PacienteUpsertWithWhereUniqueWithoutEpsInput[]
    createMany?: PacienteCreateManyEpsInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutEpsInput | PacienteUpdateWithWhereUniqueWithoutEpsInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutEpsInput | PacienteUpdateManyWithWhereWithoutEpsInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type PacienteUncheckedUpdateManyWithoutEpsNestedInput = {
    create?: XOR<PacienteCreateWithoutEpsInput, PacienteUncheckedCreateWithoutEpsInput> | PacienteCreateWithoutEpsInput[] | PacienteUncheckedCreateWithoutEpsInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutEpsInput | PacienteCreateOrConnectWithoutEpsInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutEpsInput | PacienteUpsertWithWhereUniqueWithoutEpsInput[]
    createMany?: PacienteCreateManyEpsInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutEpsInput | PacienteUpdateWithWhereUniqueWithoutEpsInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutEpsInput | PacienteUpdateManyWithWhereWithoutEpsInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type ProcedimientoCreateNestedManyWithoutTipo_procedimientoInput = {
    create?: XOR<ProcedimientoCreateWithoutTipo_procedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput> | ProcedimientoCreateWithoutTipo_procedimientoInput[] | ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput | ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput[]
    createMany?: ProcedimientoCreateManyTipo_procedimientoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type ProcedimientoUncheckedCreateNestedManyWithoutTipo_procedimientoInput = {
    create?: XOR<ProcedimientoCreateWithoutTipo_procedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput> | ProcedimientoCreateWithoutTipo_procedimientoInput[] | ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput | ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput[]
    createMany?: ProcedimientoCreateManyTipo_procedimientoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type ProcedimientoUpdateManyWithoutTipo_procedimientoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutTipo_procedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput> | ProcedimientoCreateWithoutTipo_procedimientoInput[] | ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput | ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutTipo_procedimientoInput | ProcedimientoUpsertWithWhereUniqueWithoutTipo_procedimientoInput[]
    createMany?: ProcedimientoCreateManyTipo_procedimientoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutTipo_procedimientoInput | ProcedimientoUpdateWithWhereUniqueWithoutTipo_procedimientoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutTipo_procedimientoInput | ProcedimientoUpdateManyWithWhereWithoutTipo_procedimientoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type ProcedimientoUncheckedUpdateManyWithoutTipo_procedimientoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutTipo_procedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput> | ProcedimientoCreateWithoutTipo_procedimientoInput[] | ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput | ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutTipo_procedimientoInput | ProcedimientoUpsertWithWhereUniqueWithoutTipo_procedimientoInput[]
    createMany?: ProcedimientoCreateManyTipo_procedimientoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutTipo_procedimientoInput | ProcedimientoUpdateWithWhereUniqueWithoutTipo_procedimientoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutTipo_procedimientoInput | ProcedimientoUpdateManyWithWhereWithoutTipo_procedimientoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type EstudioCreateNestedManyWithoutProcedimientoInput = {
    create?: XOR<EstudioCreateWithoutProcedimientoInput, EstudioUncheckedCreateWithoutProcedimientoInput> | EstudioCreateWithoutProcedimientoInput[] | EstudioUncheckedCreateWithoutProcedimientoInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutProcedimientoInput | EstudioCreateOrConnectWithoutProcedimientoInput[]
    createMany?: EstudioCreateManyProcedimientoInputEnvelope
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
  }

  export type AcuerdoCreateNestedOneWithoutProcedimientoInput = {
    create?: XOR<AcuerdoCreateWithoutProcedimientoInput, AcuerdoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: AcuerdoCreateOrConnectWithoutProcedimientoInput
    connect?: AcuerdoWhereUniqueInput
  }

  export type Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput = {
    create?: XOR<Tipo_ProcedimientoCreateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: Tipo_ProcedimientoCreateOrConnectWithoutProcedimientoInput
    connect?: Tipo_ProcedimientoWhereUniqueInput
  }

  export type PacienteCreateNestedOneWithoutProcedimientoInput = {
    create?: XOR<PacienteCreateWithoutProcedimientoInput, PacienteUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutProcedimientoInput
    connect?: PacienteWhereUniqueInput
  }

  export type EstudioUncheckedCreateNestedManyWithoutProcedimientoInput = {
    create?: XOR<EstudioCreateWithoutProcedimientoInput, EstudioUncheckedCreateWithoutProcedimientoInput> | EstudioCreateWithoutProcedimientoInput[] | EstudioUncheckedCreateWithoutProcedimientoInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutProcedimientoInput | EstudioCreateOrConnectWithoutProcedimientoInput[]
    createMany?: EstudioCreateManyProcedimientoInputEnvelope
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
  }

  export type EstudioUpdateManyWithoutProcedimientoNestedInput = {
    create?: XOR<EstudioCreateWithoutProcedimientoInput, EstudioUncheckedCreateWithoutProcedimientoInput> | EstudioCreateWithoutProcedimientoInput[] | EstudioUncheckedCreateWithoutProcedimientoInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutProcedimientoInput | EstudioCreateOrConnectWithoutProcedimientoInput[]
    upsert?: EstudioUpsertWithWhereUniqueWithoutProcedimientoInput | EstudioUpsertWithWhereUniqueWithoutProcedimientoInput[]
    createMany?: EstudioCreateManyProcedimientoInputEnvelope
    set?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    disconnect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    delete?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    update?: EstudioUpdateWithWhereUniqueWithoutProcedimientoInput | EstudioUpdateWithWhereUniqueWithoutProcedimientoInput[]
    updateMany?: EstudioUpdateManyWithWhereWithoutProcedimientoInput | EstudioUpdateManyWithWhereWithoutProcedimientoInput[]
    deleteMany?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
  }

  export type AcuerdoUpdateOneRequiredWithoutProcedimientoNestedInput = {
    create?: XOR<AcuerdoCreateWithoutProcedimientoInput, AcuerdoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: AcuerdoCreateOrConnectWithoutProcedimientoInput
    upsert?: AcuerdoUpsertWithoutProcedimientoInput
    connect?: AcuerdoWhereUniqueInput
    update?: XOR<XOR<AcuerdoUpdateToOneWithWhereWithoutProcedimientoInput, AcuerdoUpdateWithoutProcedimientoInput>, AcuerdoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput = {
    create?: XOR<Tipo_ProcedimientoCreateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: Tipo_ProcedimientoCreateOrConnectWithoutProcedimientoInput
    upsert?: Tipo_ProcedimientoUpsertWithoutProcedimientoInput
    connect?: Tipo_ProcedimientoWhereUniqueInput
    update?: XOR<XOR<Tipo_ProcedimientoUpdateToOneWithWhereWithoutProcedimientoInput, Tipo_ProcedimientoUpdateWithoutProcedimientoInput>, Tipo_ProcedimientoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type PacienteUpdateOneRequiredWithoutProcedimientoNestedInput = {
    create?: XOR<PacienteCreateWithoutProcedimientoInput, PacienteUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutProcedimientoInput
    upsert?: PacienteUpsertWithoutProcedimientoInput
    connect?: PacienteWhereUniqueInput
    update?: XOR<XOR<PacienteUpdateToOneWithWhereWithoutProcedimientoInput, PacienteUpdateWithoutProcedimientoInput>, PacienteUncheckedUpdateWithoutProcedimientoInput>
  }

  export type EstudioUncheckedUpdateManyWithoutProcedimientoNestedInput = {
    create?: XOR<EstudioCreateWithoutProcedimientoInput, EstudioUncheckedCreateWithoutProcedimientoInput> | EstudioCreateWithoutProcedimientoInput[] | EstudioUncheckedCreateWithoutProcedimientoInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutProcedimientoInput | EstudioCreateOrConnectWithoutProcedimientoInput[]
    upsert?: EstudioUpsertWithWhereUniqueWithoutProcedimientoInput | EstudioUpsertWithWhereUniqueWithoutProcedimientoInput[]
    createMany?: EstudioCreateManyProcedimientoInputEnvelope
    set?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    disconnect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    delete?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    update?: EstudioUpdateWithWhereUniqueWithoutProcedimientoInput | EstudioUpdateWithWhereUniqueWithoutProcedimientoInput[]
    updateMany?: EstudioUpdateManyWithWhereWithoutProcedimientoInput | EstudioUpdateManyWithWhereWithoutProcedimientoInput[]
    deleteMany?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
  }

  export type PaqueteCreateNestedOneWithoutEstudioInput = {
    create?: XOR<PaqueteCreateWithoutEstudioInput, PaqueteUncheckedCreateWithoutEstudioInput>
    connectOrCreate?: PaqueteCreateOrConnectWithoutEstudioInput
    connect?: PaqueteWhereUniqueInput
  }

  export type ProcedimientoCreateNestedOneWithoutEstudioInput = {
    create?: XOR<ProcedimientoCreateWithoutEstudioInput, ProcedimientoUncheckedCreateWithoutEstudioInput>
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutEstudioInput
    connect?: ProcedimientoWhereUniqueInput
  }

  export type PaqueteUpdateOneRequiredWithoutEstudioNestedInput = {
    create?: XOR<PaqueteCreateWithoutEstudioInput, PaqueteUncheckedCreateWithoutEstudioInput>
    connectOrCreate?: PaqueteCreateOrConnectWithoutEstudioInput
    upsert?: PaqueteUpsertWithoutEstudioInput
    connect?: PaqueteWhereUniqueInput
    update?: XOR<XOR<PaqueteUpdateToOneWithWhereWithoutEstudioInput, PaqueteUpdateWithoutEstudioInput>, PaqueteUncheckedUpdateWithoutEstudioInput>
  }

  export type ProcedimientoUpdateOneRequiredWithoutEstudioNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutEstudioInput, ProcedimientoUncheckedCreateWithoutEstudioInput>
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutEstudioInput
    upsert?: ProcedimientoUpsertWithoutEstudioInput
    connect?: ProcedimientoWhereUniqueInput
    update?: XOR<XOR<ProcedimientoUpdateToOneWithWhereWithoutEstudioInput, ProcedimientoUpdateWithoutEstudioInput>, ProcedimientoUncheckedUpdateWithoutEstudioInput>
  }

  export type MunicipioCreateNestedManyWithoutDepartamentoInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentoInput, MunicipioUncheckedCreateWithoutDepartamentoInput> | MunicipioCreateWithoutDepartamentoInput[] | MunicipioUncheckedCreateWithoutDepartamentoInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentoInput | MunicipioCreateOrConnectWithoutDepartamentoInput[]
    createMany?: MunicipioCreateManyDepartamentoInputEnvelope
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
  }

  export type MunicipioUncheckedCreateNestedManyWithoutDepartamentoInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentoInput, MunicipioUncheckedCreateWithoutDepartamentoInput> | MunicipioCreateWithoutDepartamentoInput[] | MunicipioUncheckedCreateWithoutDepartamentoInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentoInput | MunicipioCreateOrConnectWithoutDepartamentoInput[]
    createMany?: MunicipioCreateManyDepartamentoInputEnvelope
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
  }

  export type MunicipioUpdateManyWithoutDepartamentoNestedInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentoInput, MunicipioUncheckedCreateWithoutDepartamentoInput> | MunicipioCreateWithoutDepartamentoInput[] | MunicipioUncheckedCreateWithoutDepartamentoInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentoInput | MunicipioCreateOrConnectWithoutDepartamentoInput[]
    upsert?: MunicipioUpsertWithWhereUniqueWithoutDepartamentoInput | MunicipioUpsertWithWhereUniqueWithoutDepartamentoInput[]
    createMany?: MunicipioCreateManyDepartamentoInputEnvelope
    set?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    disconnect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    delete?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    update?: MunicipioUpdateWithWhereUniqueWithoutDepartamentoInput | MunicipioUpdateWithWhereUniqueWithoutDepartamentoInput[]
    updateMany?: MunicipioUpdateManyWithWhereWithoutDepartamentoInput | MunicipioUpdateManyWithWhereWithoutDepartamentoInput[]
    deleteMany?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
  }

  export type MunicipioUncheckedUpdateManyWithoutDepartamentoNestedInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentoInput, MunicipioUncheckedCreateWithoutDepartamentoInput> | MunicipioCreateWithoutDepartamentoInput[] | MunicipioUncheckedCreateWithoutDepartamentoInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentoInput | MunicipioCreateOrConnectWithoutDepartamentoInput[]
    upsert?: MunicipioUpsertWithWhereUniqueWithoutDepartamentoInput | MunicipioUpsertWithWhereUniqueWithoutDepartamentoInput[]
    createMany?: MunicipioCreateManyDepartamentoInputEnvelope
    set?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    disconnect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    delete?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    update?: MunicipioUpdateWithWhereUniqueWithoutDepartamentoInput | MunicipioUpdateWithWhereUniqueWithoutDepartamentoInput[]
    updateMany?: MunicipioUpdateManyWithWhereWithoutDepartamentoInput | MunicipioUpdateManyWithWhereWithoutDepartamentoInput[]
    deleteMany?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
  }

  export type DepartamentoCreateNestedOneWithoutMunicipioInput = {
    create?: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    connectOrCreate?: DepartamentoCreateOrConnectWithoutMunicipioInput
    connect?: DepartamentoWhereUniqueInput
  }

  export type PacienteCreateNestedManyWithoutMunicipioInput = {
    create?: XOR<PacienteCreateWithoutMunicipioInput, PacienteUncheckedCreateWithoutMunicipioInput> | PacienteCreateWithoutMunicipioInput[] | PacienteUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutMunicipioInput | PacienteCreateOrConnectWithoutMunicipioInput[]
    createMany?: PacienteCreateManyMunicipioInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type EmpresaCreateNestedManyWithoutMunicipioInput = {
    create?: XOR<EmpresaCreateWithoutMunicipioInput, EmpresaUncheckedCreateWithoutMunicipioInput> | EmpresaCreateWithoutMunicipioInput[] | EmpresaUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMunicipioInput | EmpresaCreateOrConnectWithoutMunicipioInput[]
    createMany?: EmpresaCreateManyMunicipioInputEnvelope
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
  }

  export type PacienteUncheckedCreateNestedManyWithoutMunicipioInput = {
    create?: XOR<PacienteCreateWithoutMunicipioInput, PacienteUncheckedCreateWithoutMunicipioInput> | PacienteCreateWithoutMunicipioInput[] | PacienteUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutMunicipioInput | PacienteCreateOrConnectWithoutMunicipioInput[]
    createMany?: PacienteCreateManyMunicipioInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type EmpresaUncheckedCreateNestedManyWithoutMunicipioInput = {
    create?: XOR<EmpresaCreateWithoutMunicipioInput, EmpresaUncheckedCreateWithoutMunicipioInput> | EmpresaCreateWithoutMunicipioInput[] | EmpresaUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMunicipioInput | EmpresaCreateOrConnectWithoutMunicipioInput[]
    createMany?: EmpresaCreateManyMunicipioInputEnvelope
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
  }

  export type DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput = {
    create?: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    connectOrCreate?: DepartamentoCreateOrConnectWithoutMunicipioInput
    upsert?: DepartamentoUpsertWithoutMunicipioInput
    connect?: DepartamentoWhereUniqueInput
    update?: XOR<XOR<DepartamentoUpdateToOneWithWhereWithoutMunicipioInput, DepartamentoUpdateWithoutMunicipioInput>, DepartamentoUncheckedUpdateWithoutMunicipioInput>
  }

  export type PacienteUpdateManyWithoutMunicipioNestedInput = {
    create?: XOR<PacienteCreateWithoutMunicipioInput, PacienteUncheckedCreateWithoutMunicipioInput> | PacienteCreateWithoutMunicipioInput[] | PacienteUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutMunicipioInput | PacienteCreateOrConnectWithoutMunicipioInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutMunicipioInput | PacienteUpsertWithWhereUniqueWithoutMunicipioInput[]
    createMany?: PacienteCreateManyMunicipioInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutMunicipioInput | PacienteUpdateWithWhereUniqueWithoutMunicipioInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutMunicipioInput | PacienteUpdateManyWithWhereWithoutMunicipioInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type EmpresaUpdateManyWithoutMunicipioNestedInput = {
    create?: XOR<EmpresaCreateWithoutMunicipioInput, EmpresaUncheckedCreateWithoutMunicipioInput> | EmpresaCreateWithoutMunicipioInput[] | EmpresaUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMunicipioInput | EmpresaCreateOrConnectWithoutMunicipioInput[]
    upsert?: EmpresaUpsertWithWhereUniqueWithoutMunicipioInput | EmpresaUpsertWithWhereUniqueWithoutMunicipioInput[]
    createMany?: EmpresaCreateManyMunicipioInputEnvelope
    set?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    disconnect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    delete?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    update?: EmpresaUpdateWithWhereUniqueWithoutMunicipioInput | EmpresaUpdateWithWhereUniqueWithoutMunicipioInput[]
    updateMany?: EmpresaUpdateManyWithWhereWithoutMunicipioInput | EmpresaUpdateManyWithWhereWithoutMunicipioInput[]
    deleteMany?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
  }

  export type PacienteUncheckedUpdateManyWithoutMunicipioNestedInput = {
    create?: XOR<PacienteCreateWithoutMunicipioInput, PacienteUncheckedCreateWithoutMunicipioInput> | PacienteCreateWithoutMunicipioInput[] | PacienteUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutMunicipioInput | PacienteCreateOrConnectWithoutMunicipioInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutMunicipioInput | PacienteUpsertWithWhereUniqueWithoutMunicipioInput[]
    createMany?: PacienteCreateManyMunicipioInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutMunicipioInput | PacienteUpdateWithWhereUniqueWithoutMunicipioInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutMunicipioInput | PacienteUpdateManyWithWhereWithoutMunicipioInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type EmpresaUncheckedUpdateManyWithoutMunicipioNestedInput = {
    create?: XOR<EmpresaCreateWithoutMunicipioInput, EmpresaUncheckedCreateWithoutMunicipioInput> | EmpresaCreateWithoutMunicipioInput[] | EmpresaUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMunicipioInput | EmpresaCreateOrConnectWithoutMunicipioInput[]
    upsert?: EmpresaUpsertWithWhereUniqueWithoutMunicipioInput | EmpresaUpsertWithWhereUniqueWithoutMunicipioInput[]
    createMany?: EmpresaCreateManyMunicipioInputEnvelope
    set?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    disconnect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    delete?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    update?: EmpresaUpdateWithWhereUniqueWithoutMunicipioInput | EmpresaUpdateWithWhereUniqueWithoutMunicipioInput[]
    updateMany?: EmpresaUpdateManyWithWhereWithoutMunicipioInput | EmpresaUpdateManyWithWhereWithoutMunicipioInput[]
    deleteMany?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
  }

  export type ServicioCreateNestedManyWithoutTipo_servicioInput = {
    create?: XOR<ServicioCreateWithoutTipo_servicioInput, ServicioUncheckedCreateWithoutTipo_servicioInput> | ServicioCreateWithoutTipo_servicioInput[] | ServicioUncheckedCreateWithoutTipo_servicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTipo_servicioInput | ServicioCreateOrConnectWithoutTipo_servicioInput[]
    createMany?: ServicioCreateManyTipo_servicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ServicioUncheckedCreateNestedManyWithoutTipo_servicioInput = {
    create?: XOR<ServicioCreateWithoutTipo_servicioInput, ServicioUncheckedCreateWithoutTipo_servicioInput> | ServicioCreateWithoutTipo_servicioInput[] | ServicioUncheckedCreateWithoutTipo_servicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTipo_servicioInput | ServicioCreateOrConnectWithoutTipo_servicioInput[]
    createMany?: ServicioCreateManyTipo_servicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ServicioUpdateManyWithoutTipo_servicioNestedInput = {
    create?: XOR<ServicioCreateWithoutTipo_servicioInput, ServicioUncheckedCreateWithoutTipo_servicioInput> | ServicioCreateWithoutTipo_servicioInput[] | ServicioUncheckedCreateWithoutTipo_servicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTipo_servicioInput | ServicioCreateOrConnectWithoutTipo_servicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutTipo_servicioInput | ServicioUpsertWithWhereUniqueWithoutTipo_servicioInput[]
    createMany?: ServicioCreateManyTipo_servicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutTipo_servicioInput | ServicioUpdateWithWhereUniqueWithoutTipo_servicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutTipo_servicioInput | ServicioUpdateManyWithWhereWithoutTipo_servicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type ServicioUncheckedUpdateManyWithoutTipo_servicioNestedInput = {
    create?: XOR<ServicioCreateWithoutTipo_servicioInput, ServicioUncheckedCreateWithoutTipo_servicioInput> | ServicioCreateWithoutTipo_servicioInput[] | ServicioUncheckedCreateWithoutTipo_servicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTipo_servicioInput | ServicioCreateOrConnectWithoutTipo_servicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutTipo_servicioInput | ServicioUpsertWithWhereUniqueWithoutTipo_servicioInput[]
    createMany?: ServicioCreateManyTipo_servicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutTipo_servicioInput | ServicioUpdateWithWhereUniqueWithoutTipo_servicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutTipo_servicioInput | ServicioUpdateManyWithWhereWithoutTipo_servicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type PaqueteCreateNestedManyWithoutServicioInput = {
    create?: XOR<PaqueteCreateWithoutServicioInput, PaqueteUncheckedCreateWithoutServicioInput> | PaqueteCreateWithoutServicioInput[] | PaqueteUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: PaqueteCreateOrConnectWithoutServicioInput | PaqueteCreateOrConnectWithoutServicioInput[]
    createMany?: PaqueteCreateManyServicioInputEnvelope
    connect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
  }

  export type AcuerdoCreateNestedManyWithoutServicioInput = {
    create?: XOR<AcuerdoCreateWithoutServicioInput, AcuerdoUncheckedCreateWithoutServicioInput> | AcuerdoCreateWithoutServicioInput[] | AcuerdoUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutServicioInput | AcuerdoCreateOrConnectWithoutServicioInput[]
    createMany?: AcuerdoCreateManyServicioInputEnvelope
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
  }

  export type Tipo_ServicioCreateNestedOneWithoutServicioInput = {
    create?: XOR<Tipo_ServicioCreateWithoutServicioInput, Tipo_ServicioUncheckedCreateWithoutServicioInput>
    connectOrCreate?: Tipo_ServicioCreateOrConnectWithoutServicioInput
    connect?: Tipo_ServicioWhereUniqueInput
  }

  export type PrestadorCreateNestedOneWithoutServicioInput = {
    create?: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutServicioInput
    connect?: PrestadorWhereUniqueInput
  }

  export type PaqueteUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<PaqueteCreateWithoutServicioInput, PaqueteUncheckedCreateWithoutServicioInput> | PaqueteCreateWithoutServicioInput[] | PaqueteUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: PaqueteCreateOrConnectWithoutServicioInput | PaqueteCreateOrConnectWithoutServicioInput[]
    createMany?: PaqueteCreateManyServicioInputEnvelope
    connect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
  }

  export type AcuerdoUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<AcuerdoCreateWithoutServicioInput, AcuerdoUncheckedCreateWithoutServicioInput> | AcuerdoCreateWithoutServicioInput[] | AcuerdoUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutServicioInput | AcuerdoCreateOrConnectWithoutServicioInput[]
    createMany?: AcuerdoCreateManyServicioInputEnvelope
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PaqueteUpdateManyWithoutServicioNestedInput = {
    create?: XOR<PaqueteCreateWithoutServicioInput, PaqueteUncheckedCreateWithoutServicioInput> | PaqueteCreateWithoutServicioInput[] | PaqueteUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: PaqueteCreateOrConnectWithoutServicioInput | PaqueteCreateOrConnectWithoutServicioInput[]
    upsert?: PaqueteUpsertWithWhereUniqueWithoutServicioInput | PaqueteUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: PaqueteCreateManyServicioInputEnvelope
    set?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    disconnect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    delete?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    connect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    update?: PaqueteUpdateWithWhereUniqueWithoutServicioInput | PaqueteUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: PaqueteUpdateManyWithWhereWithoutServicioInput | PaqueteUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: PaqueteScalarWhereInput | PaqueteScalarWhereInput[]
  }

  export type AcuerdoUpdateManyWithoutServicioNestedInput = {
    create?: XOR<AcuerdoCreateWithoutServicioInput, AcuerdoUncheckedCreateWithoutServicioInput> | AcuerdoCreateWithoutServicioInput[] | AcuerdoUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutServicioInput | AcuerdoCreateOrConnectWithoutServicioInput[]
    upsert?: AcuerdoUpsertWithWhereUniqueWithoutServicioInput | AcuerdoUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: AcuerdoCreateManyServicioInputEnvelope
    set?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    disconnect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    delete?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    update?: AcuerdoUpdateWithWhereUniqueWithoutServicioInput | AcuerdoUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: AcuerdoUpdateManyWithWhereWithoutServicioInput | AcuerdoUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
  }

  export type Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput = {
    create?: XOR<Tipo_ServicioCreateWithoutServicioInput, Tipo_ServicioUncheckedCreateWithoutServicioInput>
    connectOrCreate?: Tipo_ServicioCreateOrConnectWithoutServicioInput
    upsert?: Tipo_ServicioUpsertWithoutServicioInput
    connect?: Tipo_ServicioWhereUniqueInput
    update?: XOR<XOR<Tipo_ServicioUpdateToOneWithWhereWithoutServicioInput, Tipo_ServicioUpdateWithoutServicioInput>, Tipo_ServicioUncheckedUpdateWithoutServicioInput>
  }

  export type PrestadorUpdateOneRequiredWithoutServicioNestedInput = {
    create?: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutServicioInput
    upsert?: PrestadorUpsertWithoutServicioInput
    connect?: PrestadorWhereUniqueInput
    update?: XOR<XOR<PrestadorUpdateToOneWithWhereWithoutServicioInput, PrestadorUpdateWithoutServicioInput>, PrestadorUncheckedUpdateWithoutServicioInput>
  }

  export type PaqueteUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<PaqueteCreateWithoutServicioInput, PaqueteUncheckedCreateWithoutServicioInput> | PaqueteCreateWithoutServicioInput[] | PaqueteUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: PaqueteCreateOrConnectWithoutServicioInput | PaqueteCreateOrConnectWithoutServicioInput[]
    upsert?: PaqueteUpsertWithWhereUniqueWithoutServicioInput | PaqueteUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: PaqueteCreateManyServicioInputEnvelope
    set?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    disconnect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    delete?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    connect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    update?: PaqueteUpdateWithWhereUniqueWithoutServicioInput | PaqueteUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: PaqueteUpdateManyWithWhereWithoutServicioInput | PaqueteUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: PaqueteScalarWhereInput | PaqueteScalarWhereInput[]
  }

  export type AcuerdoUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<AcuerdoCreateWithoutServicioInput, AcuerdoUncheckedCreateWithoutServicioInput> | AcuerdoCreateWithoutServicioInput[] | AcuerdoUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutServicioInput | AcuerdoCreateOrConnectWithoutServicioInput[]
    upsert?: AcuerdoUpsertWithWhereUniqueWithoutServicioInput | AcuerdoUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: AcuerdoCreateManyServicioInputEnvelope
    set?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    disconnect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    delete?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    update?: AcuerdoUpdateWithWhereUniqueWithoutServicioInput | AcuerdoUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: AcuerdoUpdateManyWithWhereWithoutServicioInput | AcuerdoUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
  }

  export type Tipo_ExamenCreateNestedOneWithoutExamenInput = {
    create?: XOR<Tipo_ExamenCreateWithoutExamenInput, Tipo_ExamenUncheckedCreateWithoutExamenInput>
    connectOrCreate?: Tipo_ExamenCreateOrConnectWithoutExamenInput
    connect?: Tipo_ExamenWhereUniqueInput
  }

  export type Tipo_ResultadoCreateNestedManyWithoutExamenInput = {
    create?: XOR<Tipo_ResultadoCreateWithoutExamenInput, Tipo_ResultadoUncheckedCreateWithoutExamenInput> | Tipo_ResultadoCreateWithoutExamenInput[] | Tipo_ResultadoUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: Tipo_ResultadoCreateOrConnectWithoutExamenInput | Tipo_ResultadoCreateOrConnectWithoutExamenInput[]
    createMany?: Tipo_ResultadoCreateManyExamenInputEnvelope
    connect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
  }

  export type PaqueteCreateNestedManyWithoutExamenInput = {
    create?: XOR<PaqueteCreateWithoutExamenInput, PaqueteUncheckedCreateWithoutExamenInput> | PaqueteCreateWithoutExamenInput[] | PaqueteUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: PaqueteCreateOrConnectWithoutExamenInput | PaqueteCreateOrConnectWithoutExamenInput[]
    createMany?: PaqueteCreateManyExamenInputEnvelope
    connect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
  }

  export type Tipo_ResultadoUncheckedCreateNestedManyWithoutExamenInput = {
    create?: XOR<Tipo_ResultadoCreateWithoutExamenInput, Tipo_ResultadoUncheckedCreateWithoutExamenInput> | Tipo_ResultadoCreateWithoutExamenInput[] | Tipo_ResultadoUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: Tipo_ResultadoCreateOrConnectWithoutExamenInput | Tipo_ResultadoCreateOrConnectWithoutExamenInput[]
    createMany?: Tipo_ResultadoCreateManyExamenInputEnvelope
    connect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
  }

  export type PaqueteUncheckedCreateNestedManyWithoutExamenInput = {
    create?: XOR<PaqueteCreateWithoutExamenInput, PaqueteUncheckedCreateWithoutExamenInput> | PaqueteCreateWithoutExamenInput[] | PaqueteUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: PaqueteCreateOrConnectWithoutExamenInput | PaqueteCreateOrConnectWithoutExamenInput[]
    createMany?: PaqueteCreateManyExamenInputEnvelope
    connect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
  }

  export type Tipo_ExamenUpdateOneRequiredWithoutExamenNestedInput = {
    create?: XOR<Tipo_ExamenCreateWithoutExamenInput, Tipo_ExamenUncheckedCreateWithoutExamenInput>
    connectOrCreate?: Tipo_ExamenCreateOrConnectWithoutExamenInput
    upsert?: Tipo_ExamenUpsertWithoutExamenInput
    connect?: Tipo_ExamenWhereUniqueInput
    update?: XOR<XOR<Tipo_ExamenUpdateToOneWithWhereWithoutExamenInput, Tipo_ExamenUpdateWithoutExamenInput>, Tipo_ExamenUncheckedUpdateWithoutExamenInput>
  }

  export type Tipo_ResultadoUpdateManyWithoutExamenNestedInput = {
    create?: XOR<Tipo_ResultadoCreateWithoutExamenInput, Tipo_ResultadoUncheckedCreateWithoutExamenInput> | Tipo_ResultadoCreateWithoutExamenInput[] | Tipo_ResultadoUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: Tipo_ResultadoCreateOrConnectWithoutExamenInput | Tipo_ResultadoCreateOrConnectWithoutExamenInput[]
    upsert?: Tipo_ResultadoUpsertWithWhereUniqueWithoutExamenInput | Tipo_ResultadoUpsertWithWhereUniqueWithoutExamenInput[]
    createMany?: Tipo_ResultadoCreateManyExamenInputEnvelope
    set?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    disconnect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    delete?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    connect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    update?: Tipo_ResultadoUpdateWithWhereUniqueWithoutExamenInput | Tipo_ResultadoUpdateWithWhereUniqueWithoutExamenInput[]
    updateMany?: Tipo_ResultadoUpdateManyWithWhereWithoutExamenInput | Tipo_ResultadoUpdateManyWithWhereWithoutExamenInput[]
    deleteMany?: Tipo_ResultadoScalarWhereInput | Tipo_ResultadoScalarWhereInput[]
  }

  export type PaqueteUpdateManyWithoutExamenNestedInput = {
    create?: XOR<PaqueteCreateWithoutExamenInput, PaqueteUncheckedCreateWithoutExamenInput> | PaqueteCreateWithoutExamenInput[] | PaqueteUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: PaqueteCreateOrConnectWithoutExamenInput | PaqueteCreateOrConnectWithoutExamenInput[]
    upsert?: PaqueteUpsertWithWhereUniqueWithoutExamenInput | PaqueteUpsertWithWhereUniqueWithoutExamenInput[]
    createMany?: PaqueteCreateManyExamenInputEnvelope
    set?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    disconnect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    delete?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    connect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    update?: PaqueteUpdateWithWhereUniqueWithoutExamenInput | PaqueteUpdateWithWhereUniqueWithoutExamenInput[]
    updateMany?: PaqueteUpdateManyWithWhereWithoutExamenInput | PaqueteUpdateManyWithWhereWithoutExamenInput[]
    deleteMany?: PaqueteScalarWhereInput | PaqueteScalarWhereInput[]
  }

  export type Tipo_ResultadoUncheckedUpdateManyWithoutExamenNestedInput = {
    create?: XOR<Tipo_ResultadoCreateWithoutExamenInput, Tipo_ResultadoUncheckedCreateWithoutExamenInput> | Tipo_ResultadoCreateWithoutExamenInput[] | Tipo_ResultadoUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: Tipo_ResultadoCreateOrConnectWithoutExamenInput | Tipo_ResultadoCreateOrConnectWithoutExamenInput[]
    upsert?: Tipo_ResultadoUpsertWithWhereUniqueWithoutExamenInput | Tipo_ResultadoUpsertWithWhereUniqueWithoutExamenInput[]
    createMany?: Tipo_ResultadoCreateManyExamenInputEnvelope
    set?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    disconnect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    delete?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    connect?: Tipo_ResultadoWhereUniqueInput | Tipo_ResultadoWhereUniqueInput[]
    update?: Tipo_ResultadoUpdateWithWhereUniqueWithoutExamenInput | Tipo_ResultadoUpdateWithWhereUniqueWithoutExamenInput[]
    updateMany?: Tipo_ResultadoUpdateManyWithWhereWithoutExamenInput | Tipo_ResultadoUpdateManyWithWhereWithoutExamenInput[]
    deleteMany?: Tipo_ResultadoScalarWhereInput | Tipo_ResultadoScalarWhereInput[]
  }

  export type PaqueteUncheckedUpdateManyWithoutExamenNestedInput = {
    create?: XOR<PaqueteCreateWithoutExamenInput, PaqueteUncheckedCreateWithoutExamenInput> | PaqueteCreateWithoutExamenInput[] | PaqueteUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: PaqueteCreateOrConnectWithoutExamenInput | PaqueteCreateOrConnectWithoutExamenInput[]
    upsert?: PaqueteUpsertWithWhereUniqueWithoutExamenInput | PaqueteUpsertWithWhereUniqueWithoutExamenInput[]
    createMany?: PaqueteCreateManyExamenInputEnvelope
    set?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    disconnect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    delete?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    connect?: PaqueteWhereUniqueInput | PaqueteWhereUniqueInput[]
    update?: PaqueteUpdateWithWhereUniqueWithoutExamenInput | PaqueteUpdateWithWhereUniqueWithoutExamenInput[]
    updateMany?: PaqueteUpdateManyWithWhereWithoutExamenInput | PaqueteUpdateManyWithWhereWithoutExamenInput[]
    deleteMany?: PaqueteScalarWhereInput | PaqueteScalarWhereInput[]
  }

  export type ExamenCreateNestedOneWithoutTipo_resultadoInput = {
    create?: XOR<ExamenCreateWithoutTipo_resultadoInput, ExamenUncheckedCreateWithoutTipo_resultadoInput>
    connectOrCreate?: ExamenCreateOrConnectWithoutTipo_resultadoInput
    connect?: ExamenWhereUniqueInput
  }

  export type ExamenUpdateOneRequiredWithoutTipo_resultadoNestedInput = {
    create?: XOR<ExamenCreateWithoutTipo_resultadoInput, ExamenUncheckedCreateWithoutTipo_resultadoInput>
    connectOrCreate?: ExamenCreateOrConnectWithoutTipo_resultadoInput
    upsert?: ExamenUpsertWithoutTipo_resultadoInput
    connect?: ExamenWhereUniqueInput
    update?: XOR<XOR<ExamenUpdateToOneWithWhereWithoutTipo_resultadoInput, ExamenUpdateWithoutTipo_resultadoInput>, ExamenUncheckedUpdateWithoutTipo_resultadoInput>
  }

  export type ExamenCreateNestedManyWithoutTipo_examenInput = {
    create?: XOR<ExamenCreateWithoutTipo_examenInput, ExamenUncheckedCreateWithoutTipo_examenInput> | ExamenCreateWithoutTipo_examenInput[] | ExamenUncheckedCreateWithoutTipo_examenInput[]
    connectOrCreate?: ExamenCreateOrConnectWithoutTipo_examenInput | ExamenCreateOrConnectWithoutTipo_examenInput[]
    createMany?: ExamenCreateManyTipo_examenInputEnvelope
    connect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
  }

  export type ExamenUncheckedCreateNestedManyWithoutTipo_examenInput = {
    create?: XOR<ExamenCreateWithoutTipo_examenInput, ExamenUncheckedCreateWithoutTipo_examenInput> | ExamenCreateWithoutTipo_examenInput[] | ExamenUncheckedCreateWithoutTipo_examenInput[]
    connectOrCreate?: ExamenCreateOrConnectWithoutTipo_examenInput | ExamenCreateOrConnectWithoutTipo_examenInput[]
    createMany?: ExamenCreateManyTipo_examenInputEnvelope
    connect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
  }

  export type ExamenUpdateManyWithoutTipo_examenNestedInput = {
    create?: XOR<ExamenCreateWithoutTipo_examenInput, ExamenUncheckedCreateWithoutTipo_examenInput> | ExamenCreateWithoutTipo_examenInput[] | ExamenUncheckedCreateWithoutTipo_examenInput[]
    connectOrCreate?: ExamenCreateOrConnectWithoutTipo_examenInput | ExamenCreateOrConnectWithoutTipo_examenInput[]
    upsert?: ExamenUpsertWithWhereUniqueWithoutTipo_examenInput | ExamenUpsertWithWhereUniqueWithoutTipo_examenInput[]
    createMany?: ExamenCreateManyTipo_examenInputEnvelope
    set?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    disconnect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    delete?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    connect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    update?: ExamenUpdateWithWhereUniqueWithoutTipo_examenInput | ExamenUpdateWithWhereUniqueWithoutTipo_examenInput[]
    updateMany?: ExamenUpdateManyWithWhereWithoutTipo_examenInput | ExamenUpdateManyWithWhereWithoutTipo_examenInput[]
    deleteMany?: ExamenScalarWhereInput | ExamenScalarWhereInput[]
  }

  export type ExamenUncheckedUpdateManyWithoutTipo_examenNestedInput = {
    create?: XOR<ExamenCreateWithoutTipo_examenInput, ExamenUncheckedCreateWithoutTipo_examenInput> | ExamenCreateWithoutTipo_examenInput[] | ExamenUncheckedCreateWithoutTipo_examenInput[]
    connectOrCreate?: ExamenCreateOrConnectWithoutTipo_examenInput | ExamenCreateOrConnectWithoutTipo_examenInput[]
    upsert?: ExamenUpsertWithWhereUniqueWithoutTipo_examenInput | ExamenUpsertWithWhereUniqueWithoutTipo_examenInput[]
    createMany?: ExamenCreateManyTipo_examenInputEnvelope
    set?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    disconnect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    delete?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    connect?: ExamenWhereUniqueInput | ExamenWhereUniqueInput[]
    update?: ExamenUpdateWithWhereUniqueWithoutTipo_examenInput | ExamenUpdateWithWhereUniqueWithoutTipo_examenInput[]
    updateMany?: ExamenUpdateManyWithWhereWithoutTipo_examenInput | ExamenUpdateManyWithWhereWithoutTipo_examenInput[]
    deleteMany?: ExamenScalarWhereInput | ExamenScalarWhereInput[]
  }

  export type ServicioCreateNestedManyWithoutPrestadorInput = {
    create?: XOR<ServicioCreateWithoutPrestadorInput, ServicioUncheckedCreateWithoutPrestadorInput> | ServicioCreateWithoutPrestadorInput[] | ServicioUncheckedCreateWithoutPrestadorInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestadorInput | ServicioCreateOrConnectWithoutPrestadorInput[]
    createMany?: ServicioCreateManyPrestadorInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type UsuarioCreateNestedManyWithoutPrestadorInput = {
    create?: XOR<UsuarioCreateWithoutPrestadorInput, UsuarioUncheckedCreateWithoutPrestadorInput> | UsuarioCreateWithoutPrestadorInput[] | UsuarioUncheckedCreateWithoutPrestadorInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutPrestadorInput | UsuarioCreateOrConnectWithoutPrestadorInput[]
    createMany?: UsuarioCreateManyPrestadorInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type ServicioUncheckedCreateNestedManyWithoutPrestadorInput = {
    create?: XOR<ServicioCreateWithoutPrestadorInput, ServicioUncheckedCreateWithoutPrestadorInput> | ServicioCreateWithoutPrestadorInput[] | ServicioUncheckedCreateWithoutPrestadorInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestadorInput | ServicioCreateOrConnectWithoutPrestadorInput[]
    createMany?: ServicioCreateManyPrestadorInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutPrestadorInput = {
    create?: XOR<UsuarioCreateWithoutPrestadorInput, UsuarioUncheckedCreateWithoutPrestadorInput> | UsuarioCreateWithoutPrestadorInput[] | UsuarioUncheckedCreateWithoutPrestadorInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutPrestadorInput | UsuarioCreateOrConnectWithoutPrestadorInput[]
    createMany?: UsuarioCreateManyPrestadorInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type ServicioUpdateManyWithoutPrestadorNestedInput = {
    create?: XOR<ServicioCreateWithoutPrestadorInput, ServicioUncheckedCreateWithoutPrestadorInput> | ServicioCreateWithoutPrestadorInput[] | ServicioUncheckedCreateWithoutPrestadorInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestadorInput | ServicioCreateOrConnectWithoutPrestadorInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutPrestadorInput | ServicioUpsertWithWhereUniqueWithoutPrestadorInput[]
    createMany?: ServicioCreateManyPrestadorInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutPrestadorInput | ServicioUpdateWithWhereUniqueWithoutPrestadorInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutPrestadorInput | ServicioUpdateManyWithWhereWithoutPrestadorInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type UsuarioUpdateManyWithoutPrestadorNestedInput = {
    create?: XOR<UsuarioCreateWithoutPrestadorInput, UsuarioUncheckedCreateWithoutPrestadorInput> | UsuarioCreateWithoutPrestadorInput[] | UsuarioUncheckedCreateWithoutPrestadorInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutPrestadorInput | UsuarioCreateOrConnectWithoutPrestadorInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutPrestadorInput | UsuarioUpsertWithWhereUniqueWithoutPrestadorInput[]
    createMany?: UsuarioCreateManyPrestadorInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutPrestadorInput | UsuarioUpdateWithWhereUniqueWithoutPrestadorInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutPrestadorInput | UsuarioUpdateManyWithWhereWithoutPrestadorInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type ServicioUncheckedUpdateManyWithoutPrestadorNestedInput = {
    create?: XOR<ServicioCreateWithoutPrestadorInput, ServicioUncheckedCreateWithoutPrestadorInput> | ServicioCreateWithoutPrestadorInput[] | ServicioUncheckedCreateWithoutPrestadorInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestadorInput | ServicioCreateOrConnectWithoutPrestadorInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutPrestadorInput | ServicioUpsertWithWhereUniqueWithoutPrestadorInput[]
    createMany?: ServicioCreateManyPrestadorInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutPrestadorInput | ServicioUpdateWithWhereUniqueWithoutPrestadorInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutPrestadorInput | ServicioUpdateManyWithWhereWithoutPrestadorInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutPrestadorNestedInput = {
    create?: XOR<UsuarioCreateWithoutPrestadorInput, UsuarioUncheckedCreateWithoutPrestadorInput> | UsuarioCreateWithoutPrestadorInput[] | UsuarioUncheckedCreateWithoutPrestadorInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutPrestadorInput | UsuarioCreateOrConnectWithoutPrestadorInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutPrestadorInput | UsuarioUpsertWithWhereUniqueWithoutPrestadorInput[]
    createMany?: UsuarioCreateManyPrestadorInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutPrestadorInput | UsuarioUpdateWithWhereUniqueWithoutPrestadorInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutPrestadorInput | UsuarioUpdateManyWithWhereWithoutPrestadorInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type PrestadorCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<PrestadorCreateWithoutUsuarioInput, PrestadorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutUsuarioInput
    connect?: PrestadorWhereUniqueInput
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type PrestadorUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<PrestadorCreateWithoutUsuarioInput, PrestadorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutUsuarioInput
    upsert?: PrestadorUpsertWithoutUsuarioInput
    connect?: PrestadorWhereUniqueInput
    update?: XOR<XOR<PrestadorUpdateToOneWithWhereWithoutUsuarioInput, PrestadorUpdateWithoutUsuarioInput>, PrestadorUncheckedUpdateWithoutUsuarioInput>
  }

  export type MunicipioCreateNestedOneWithoutEmpresaInput = {
    create?: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutEmpresaInput
    connect?: MunicipioWhereUniqueInput
  }

  export type ContratoCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<ContratoCreateWithoutEmpresaInput, ContratoUncheckedCreateWithoutEmpresaInput> | ContratoCreateWithoutEmpresaInput[] | ContratoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutEmpresaInput | ContratoCreateOrConnectWithoutEmpresaInput[]
    createMany?: ContratoCreateManyEmpresaInputEnvelope
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
  }

  export type ContratoUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<ContratoCreateWithoutEmpresaInput, ContratoUncheckedCreateWithoutEmpresaInput> | ContratoCreateWithoutEmpresaInput[] | ContratoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutEmpresaInput | ContratoCreateOrConnectWithoutEmpresaInput[]
    createMany?: ContratoCreateManyEmpresaInputEnvelope
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
  }

  export type EnumTipo_EmpresaFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Empresa
  }

  export type MunicipioUpdateOneRequiredWithoutEmpresaNestedInput = {
    create?: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutEmpresaInput
    upsert?: MunicipioUpsertWithoutEmpresaInput
    connect?: MunicipioWhereUniqueInput
    update?: XOR<XOR<MunicipioUpdateToOneWithWhereWithoutEmpresaInput, MunicipioUpdateWithoutEmpresaInput>, MunicipioUncheckedUpdateWithoutEmpresaInput>
  }

  export type ContratoUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<ContratoCreateWithoutEmpresaInput, ContratoUncheckedCreateWithoutEmpresaInput> | ContratoCreateWithoutEmpresaInput[] | ContratoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutEmpresaInput | ContratoCreateOrConnectWithoutEmpresaInput[]
    upsert?: ContratoUpsertWithWhereUniqueWithoutEmpresaInput | ContratoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: ContratoCreateManyEmpresaInputEnvelope
    set?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    disconnect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    delete?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    update?: ContratoUpdateWithWhereUniqueWithoutEmpresaInput | ContratoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: ContratoUpdateManyWithWhereWithoutEmpresaInput | ContratoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
  }

  export type ContratoUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<ContratoCreateWithoutEmpresaInput, ContratoUncheckedCreateWithoutEmpresaInput> | ContratoCreateWithoutEmpresaInput[] | ContratoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutEmpresaInput | ContratoCreateOrConnectWithoutEmpresaInput[]
    upsert?: ContratoUpsertWithWhereUniqueWithoutEmpresaInput | ContratoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: ContratoCreateManyEmpresaInputEnvelope
    set?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    disconnect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    delete?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    update?: ContratoUpdateWithWhereUniqueWithoutEmpresaInput | ContratoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: ContratoUpdateManyWithWhereWithoutEmpresaInput | ContratoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
  }

  export type EmpresaCreateNestedOneWithoutContratoInput = {
    create?: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutContratoInput
    connect?: EmpresaWhereUniqueInput
  }

  export type AcuerdoCreateNestedManyWithoutContratoInput = {
    create?: XOR<AcuerdoCreateWithoutContratoInput, AcuerdoUncheckedCreateWithoutContratoInput> | AcuerdoCreateWithoutContratoInput[] | AcuerdoUncheckedCreateWithoutContratoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutContratoInput | AcuerdoCreateOrConnectWithoutContratoInput[]
    createMany?: AcuerdoCreateManyContratoInputEnvelope
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
  }

  export type AcuerdoUncheckedCreateNestedManyWithoutContratoInput = {
    create?: XOR<AcuerdoCreateWithoutContratoInput, AcuerdoUncheckedCreateWithoutContratoInput> | AcuerdoCreateWithoutContratoInput[] | AcuerdoUncheckedCreateWithoutContratoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutContratoInput | AcuerdoCreateOrConnectWithoutContratoInput[]
    createMany?: AcuerdoCreateManyContratoInputEnvelope
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
  }

  export type EmpresaUpdateOneRequiredWithoutContratoNestedInput = {
    create?: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutContratoInput
    upsert?: EmpresaUpsertWithoutContratoInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutContratoInput, EmpresaUpdateWithoutContratoInput>, EmpresaUncheckedUpdateWithoutContratoInput>
  }

  export type AcuerdoUpdateManyWithoutContratoNestedInput = {
    create?: XOR<AcuerdoCreateWithoutContratoInput, AcuerdoUncheckedCreateWithoutContratoInput> | AcuerdoCreateWithoutContratoInput[] | AcuerdoUncheckedCreateWithoutContratoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutContratoInput | AcuerdoCreateOrConnectWithoutContratoInput[]
    upsert?: AcuerdoUpsertWithWhereUniqueWithoutContratoInput | AcuerdoUpsertWithWhereUniqueWithoutContratoInput[]
    createMany?: AcuerdoCreateManyContratoInputEnvelope
    set?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    disconnect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    delete?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    update?: AcuerdoUpdateWithWhereUniqueWithoutContratoInput | AcuerdoUpdateWithWhereUniqueWithoutContratoInput[]
    updateMany?: AcuerdoUpdateManyWithWhereWithoutContratoInput | AcuerdoUpdateManyWithWhereWithoutContratoInput[]
    deleteMany?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
  }

  export type AcuerdoUncheckedUpdateManyWithoutContratoNestedInput = {
    create?: XOR<AcuerdoCreateWithoutContratoInput, AcuerdoUncheckedCreateWithoutContratoInput> | AcuerdoCreateWithoutContratoInput[] | AcuerdoUncheckedCreateWithoutContratoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutContratoInput | AcuerdoCreateOrConnectWithoutContratoInput[]
    upsert?: AcuerdoUpsertWithWhereUniqueWithoutContratoInput | AcuerdoUpsertWithWhereUniqueWithoutContratoInput[]
    createMany?: AcuerdoCreateManyContratoInputEnvelope
    set?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    disconnect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    delete?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    update?: AcuerdoUpdateWithWhereUniqueWithoutContratoInput | AcuerdoUpdateWithWhereUniqueWithoutContratoInput[]
    updateMany?: AcuerdoUpdateManyWithWhereWithoutContratoInput | AcuerdoUpdateManyWithWhereWithoutContratoInput[]
    deleteMany?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
  }

  export type ProcedimientoCreateNestedManyWithoutAcuerdoInput = {
    create?: XOR<ProcedimientoCreateWithoutAcuerdoInput, ProcedimientoUncheckedCreateWithoutAcuerdoInput> | ProcedimientoCreateWithoutAcuerdoInput[] | ProcedimientoUncheckedCreateWithoutAcuerdoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutAcuerdoInput | ProcedimientoCreateOrConnectWithoutAcuerdoInput[]
    createMany?: ProcedimientoCreateManyAcuerdoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type ContratoCreateNestedOneWithoutAcuerdoInput = {
    create?: XOR<ContratoCreateWithoutAcuerdoInput, ContratoUncheckedCreateWithoutAcuerdoInput>
    connectOrCreate?: ContratoCreateOrConnectWithoutAcuerdoInput
    connect?: ContratoWhereUniqueInput
  }

  export type ServicioCreateNestedOneWithoutAcuerdoInput = {
    create?: XOR<ServicioCreateWithoutAcuerdoInput, ServicioUncheckedCreateWithoutAcuerdoInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutAcuerdoInput
    connect?: ServicioWhereUniqueInput
  }

  export type ProcedimientoUncheckedCreateNestedManyWithoutAcuerdoInput = {
    create?: XOR<ProcedimientoCreateWithoutAcuerdoInput, ProcedimientoUncheckedCreateWithoutAcuerdoInput> | ProcedimientoCreateWithoutAcuerdoInput[] | ProcedimientoUncheckedCreateWithoutAcuerdoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutAcuerdoInput | ProcedimientoCreateOrConnectWithoutAcuerdoInput[]
    createMany?: ProcedimientoCreateManyAcuerdoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type ProcedimientoUpdateManyWithoutAcuerdoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutAcuerdoInput, ProcedimientoUncheckedCreateWithoutAcuerdoInput> | ProcedimientoCreateWithoutAcuerdoInput[] | ProcedimientoUncheckedCreateWithoutAcuerdoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutAcuerdoInput | ProcedimientoCreateOrConnectWithoutAcuerdoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutAcuerdoInput | ProcedimientoUpsertWithWhereUniqueWithoutAcuerdoInput[]
    createMany?: ProcedimientoCreateManyAcuerdoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutAcuerdoInput | ProcedimientoUpdateWithWhereUniqueWithoutAcuerdoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutAcuerdoInput | ProcedimientoUpdateManyWithWhereWithoutAcuerdoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type ContratoUpdateOneRequiredWithoutAcuerdoNestedInput = {
    create?: XOR<ContratoCreateWithoutAcuerdoInput, ContratoUncheckedCreateWithoutAcuerdoInput>
    connectOrCreate?: ContratoCreateOrConnectWithoutAcuerdoInput
    upsert?: ContratoUpsertWithoutAcuerdoInput
    connect?: ContratoWhereUniqueInput
    update?: XOR<XOR<ContratoUpdateToOneWithWhereWithoutAcuerdoInput, ContratoUpdateWithoutAcuerdoInput>, ContratoUncheckedUpdateWithoutAcuerdoInput>
  }

  export type ServicioUpdateOneRequiredWithoutAcuerdoNestedInput = {
    create?: XOR<ServicioCreateWithoutAcuerdoInput, ServicioUncheckedCreateWithoutAcuerdoInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutAcuerdoInput
    upsert?: ServicioUpsertWithoutAcuerdoInput
    connect?: ServicioWhereUniqueInput
    update?: XOR<XOR<ServicioUpdateToOneWithWhereWithoutAcuerdoInput, ServicioUpdateWithoutAcuerdoInput>, ServicioUncheckedUpdateWithoutAcuerdoInput>
  }

  export type ProcedimientoUncheckedUpdateManyWithoutAcuerdoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutAcuerdoInput, ProcedimientoUncheckedCreateWithoutAcuerdoInput> | ProcedimientoCreateWithoutAcuerdoInput[] | ProcedimientoUncheckedCreateWithoutAcuerdoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutAcuerdoInput | ProcedimientoCreateOrConnectWithoutAcuerdoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutAcuerdoInput | ProcedimientoUpsertWithWhereUniqueWithoutAcuerdoInput[]
    createMany?: ProcedimientoCreateManyAcuerdoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutAcuerdoInput | ProcedimientoUpdateWithWhereUniqueWithoutAcuerdoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutAcuerdoInput | ProcedimientoUpdateManyWithWhereWithoutAcuerdoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type EstudioCreateNestedManyWithoutPaqueteInput = {
    create?: XOR<EstudioCreateWithoutPaqueteInput, EstudioUncheckedCreateWithoutPaqueteInput> | EstudioCreateWithoutPaqueteInput[] | EstudioUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutPaqueteInput | EstudioCreateOrConnectWithoutPaqueteInput[]
    createMany?: EstudioCreateManyPaqueteInputEnvelope
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
  }

  export type ExamenCreateNestedOneWithoutPaqueteInput = {
    create?: XOR<ExamenCreateWithoutPaqueteInput, ExamenUncheckedCreateWithoutPaqueteInput>
    connectOrCreate?: ExamenCreateOrConnectWithoutPaqueteInput
    connect?: ExamenWhereUniqueInput
  }

  export type ServicioCreateNestedOneWithoutPaqueteInput = {
    create?: XOR<ServicioCreateWithoutPaqueteInput, ServicioUncheckedCreateWithoutPaqueteInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutPaqueteInput
    connect?: ServicioWhereUniqueInput
  }

  export type EstudioUncheckedCreateNestedManyWithoutPaqueteInput = {
    create?: XOR<EstudioCreateWithoutPaqueteInput, EstudioUncheckedCreateWithoutPaqueteInput> | EstudioCreateWithoutPaqueteInput[] | EstudioUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutPaqueteInput | EstudioCreateOrConnectWithoutPaqueteInput[]
    createMany?: EstudioCreateManyPaqueteInputEnvelope
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
  }

  export type EstudioUpdateManyWithoutPaqueteNestedInput = {
    create?: XOR<EstudioCreateWithoutPaqueteInput, EstudioUncheckedCreateWithoutPaqueteInput> | EstudioCreateWithoutPaqueteInput[] | EstudioUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutPaqueteInput | EstudioCreateOrConnectWithoutPaqueteInput[]
    upsert?: EstudioUpsertWithWhereUniqueWithoutPaqueteInput | EstudioUpsertWithWhereUniqueWithoutPaqueteInput[]
    createMany?: EstudioCreateManyPaqueteInputEnvelope
    set?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    disconnect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    delete?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    update?: EstudioUpdateWithWhereUniqueWithoutPaqueteInput | EstudioUpdateWithWhereUniqueWithoutPaqueteInput[]
    updateMany?: EstudioUpdateManyWithWhereWithoutPaqueteInput | EstudioUpdateManyWithWhereWithoutPaqueteInput[]
    deleteMany?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
  }

  export type ExamenUpdateOneRequiredWithoutPaqueteNestedInput = {
    create?: XOR<ExamenCreateWithoutPaqueteInput, ExamenUncheckedCreateWithoutPaqueteInput>
    connectOrCreate?: ExamenCreateOrConnectWithoutPaqueteInput
    upsert?: ExamenUpsertWithoutPaqueteInput
    connect?: ExamenWhereUniqueInput
    update?: XOR<XOR<ExamenUpdateToOneWithWhereWithoutPaqueteInput, ExamenUpdateWithoutPaqueteInput>, ExamenUncheckedUpdateWithoutPaqueteInput>
  }

  export type ServicioUpdateOneRequiredWithoutPaqueteNestedInput = {
    create?: XOR<ServicioCreateWithoutPaqueteInput, ServicioUncheckedCreateWithoutPaqueteInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutPaqueteInput
    upsert?: ServicioUpsertWithoutPaqueteInput
    connect?: ServicioWhereUniqueInput
    update?: XOR<XOR<ServicioUpdateToOneWithWhereWithoutPaqueteInput, ServicioUpdateWithoutPaqueteInput>, ServicioUncheckedUpdateWithoutPaqueteInput>
  }

  export type EstudioUncheckedUpdateManyWithoutPaqueteNestedInput = {
    create?: XOR<EstudioCreateWithoutPaqueteInput, EstudioUncheckedCreateWithoutPaqueteInput> | EstudioCreateWithoutPaqueteInput[] | EstudioUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: EstudioCreateOrConnectWithoutPaqueteInput | EstudioCreateOrConnectWithoutPaqueteInput[]
    upsert?: EstudioUpsertWithWhereUniqueWithoutPaqueteInput | EstudioUpsertWithWhereUniqueWithoutPaqueteInput[]
    createMany?: EstudioCreateManyPaqueteInputEnvelope
    set?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    disconnect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    delete?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    connect?: EstudioWhereUniqueInput | EstudioWhereUniqueInput[]
    update?: EstudioUpdateWithWhereUniqueWithoutPaqueteInput | EstudioUpdateWithWhereUniqueWithoutPaqueteInput[]
    updateMany?: EstudioUpdateManyWithWhereWithoutPaqueteInput | EstudioUpdateManyWithWhereWithoutPaqueteInput[]
    deleteMany?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumTipo_IdentFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentFilter<$PrismaModel> | $Enums.Tipo_Ident
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSexFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexFilter<$PrismaModel> | $Enums.Sex
  }

  export type NestedEnumTipo_PacienteFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Paciente | EnumTipo_PacienteFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Paciente[]
    notIn?: $Enums.Tipo_Paciente[]
    not?: NestedEnumTipo_PacienteFilter<$PrismaModel> | $Enums.Tipo_Paciente
  }

  export type NestedEnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Ident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_IdentFilter<$PrismaModel>
    _max?: NestedEnumTipo_IdentFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexWithAggregatesFilter<$PrismaModel> | $Enums.Sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexFilter<$PrismaModel>
    _max?: NestedEnumSexFilter<$PrismaModel>
  }

  export type NestedEnumTipo_PacienteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Paciente | EnumTipo_PacienteFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Paciente[]
    notIn?: $Enums.Tipo_Paciente[]
    not?: NestedEnumTipo_PacienteWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Paciente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_PacienteFilter<$PrismaModel>
    _max?: NestedEnumTipo_PacienteFilter<$PrismaModel>
  }

  export type NestedEnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedEnumTipo_EmpresaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaFilter<$PrismaModel> | $Enums.Tipo_Empresa
  }

  export type NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Empresa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
    _max?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
  }

  export type ProcedimientoCreateWithoutPacienteInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutProcedimientoInput
    acuerdo: AcuerdoCreateNestedOneWithoutProcedimientoInput
    tipo_procedimiento: Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutPacienteInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    acuerdoId: number
    tipo_procedimientoId: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutProcedimientoInput
  }

  export type ProcedimientoCreateOrConnectWithoutPacienteInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutPacienteInput, ProcedimientoUncheckedCreateWithoutPacienteInput>
  }

  export type ProcedimientoCreateManyPacienteInputEnvelope = {
    data: ProcedimientoCreateManyPacienteInput | ProcedimientoCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioCreateWithoutPacienteInput = {
    nombre: string
    departamento: DepartamentoCreateNestedOneWithoutMunicipioInput
    empresa?: EmpresaCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateWithoutPacienteInput = {
    id_municipio?: number
    nombre: string
    departamentoId: number
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioCreateOrConnectWithoutPacienteInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutPacienteInput, MunicipioUncheckedCreateWithoutPacienteInput>
  }

  export type EpsCreateWithoutPacienteInput = {
    codigo: string
    nombre: string
    estado?: $Enums.Estado
  }

  export type EpsUncheckedCreateWithoutPacienteInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado?: $Enums.Estado
  }

  export type EpsCreateOrConnectWithoutPacienteInput = {
    where: EpsWhereUniqueInput
    create: XOR<EpsCreateWithoutPacienteInput, EpsUncheckedCreateWithoutPacienteInput>
  }

  export type ProcedimientoUpsertWithWhereUniqueWithoutPacienteInput = {
    where: ProcedimientoWhereUniqueInput
    update: XOR<ProcedimientoUpdateWithoutPacienteInput, ProcedimientoUncheckedUpdateWithoutPacienteInput>
    create: XOR<ProcedimientoCreateWithoutPacienteInput, ProcedimientoUncheckedCreateWithoutPacienteInput>
  }

  export type ProcedimientoUpdateWithWhereUniqueWithoutPacienteInput = {
    where: ProcedimientoWhereUniqueInput
    data: XOR<ProcedimientoUpdateWithoutPacienteInput, ProcedimientoUncheckedUpdateWithoutPacienteInput>
  }

  export type ProcedimientoUpdateManyWithWhereWithoutPacienteInput = {
    where: ProcedimientoScalarWhereInput
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyWithoutPacienteInput>
  }

  export type ProcedimientoScalarWhereInput = {
    AND?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
    OR?: ProcedimientoScalarWhereInput[]
    NOT?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
    id_procedimiento?: IntFilter<"Procedimiento"> | number
    factura?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    edad_persona?: StringFilter<"Procedimiento"> | string
    estado?: EnumEstadoFilter<"Procedimiento"> | $Enums.Estado
    createAt?: DateTimeFilter<"Procedimiento"> | Date | string
    updateAt?: DateTimeFilter<"Procedimiento"> | Date | string
    acuerdoId?: IntFilter<"Procedimiento"> | number
    tipo_procedimientoId?: IntFilter<"Procedimiento"> | number
    pacienteId?: IntFilter<"Procedimiento"> | number
  }

  export type MunicipioUpsertWithoutPacienteInput = {
    update: XOR<MunicipioUpdateWithoutPacienteInput, MunicipioUncheckedUpdateWithoutPacienteInput>
    create: XOR<MunicipioCreateWithoutPacienteInput, MunicipioUncheckedCreateWithoutPacienteInput>
    where?: MunicipioWhereInput
  }

  export type MunicipioUpdateToOneWithWhereWithoutPacienteInput = {
    where?: MunicipioWhereInput
    data: XOR<MunicipioUpdateWithoutPacienteInput, MunicipioUncheckedUpdateWithoutPacienteInput>
  }

  export type MunicipioUpdateWithoutPacienteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
    empresa?: EmpresaUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutPacienteInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamentoId?: IntFieldUpdateOperationsInput | number
    empresa?: EmpresaUncheckedUpdateManyWithoutMunicipioNestedInput
  }

  export type EpsUpsertWithoutPacienteInput = {
    update: XOR<EpsUpdateWithoutPacienteInput, EpsUncheckedUpdateWithoutPacienteInput>
    create: XOR<EpsCreateWithoutPacienteInput, EpsUncheckedCreateWithoutPacienteInput>
    where?: EpsWhereInput
  }

  export type EpsUpdateToOneWithWhereWithoutPacienteInput = {
    where?: EpsWhereInput
    data: XOR<EpsUpdateWithoutPacienteInput, EpsUncheckedUpdateWithoutPacienteInput>
  }

  export type EpsUpdateWithoutPacienteInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EpsUncheckedUpdateWithoutPacienteInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PacienteCreateWithoutEpsInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    procedimiento?: ProcedimientoCreateNestedManyWithoutPacienteInput
    municipio: MunicipioCreateNestedOneWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutEpsInput = {
    id_paciente?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    municipioId: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutEpsInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutEpsInput, PacienteUncheckedCreateWithoutEpsInput>
  }

  export type PacienteCreateManyEpsInputEnvelope = {
    data: PacienteCreateManyEpsInput | PacienteCreateManyEpsInput[]
    skipDuplicates?: boolean
  }

  export type PacienteUpsertWithWhereUniqueWithoutEpsInput = {
    where: PacienteWhereUniqueInput
    update: XOR<PacienteUpdateWithoutEpsInput, PacienteUncheckedUpdateWithoutEpsInput>
    create: XOR<PacienteCreateWithoutEpsInput, PacienteUncheckedCreateWithoutEpsInput>
  }

  export type PacienteUpdateWithWhereUniqueWithoutEpsInput = {
    where: PacienteWhereUniqueInput
    data: XOR<PacienteUpdateWithoutEpsInput, PacienteUncheckedUpdateWithoutEpsInput>
  }

  export type PacienteUpdateManyWithWhereWithoutEpsInput = {
    where: PacienteScalarWhereInput
    data: XOR<PacienteUpdateManyMutationInput, PacienteUncheckedUpdateManyWithoutEpsInput>
  }

  export type PacienteScalarWhereInput = {
    AND?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
    OR?: PacienteScalarWhereInput[]
    NOT?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
    id_paciente?: IntFilter<"Paciente"> | number
    tipo_identificacion?: EnumTipo_IdentFilter<"Paciente"> | $Enums.Tipo_Ident
    identificacion?: StringFilter<"Paciente"> | string
    primer_nombre?: StringFilter<"Paciente"> | string
    segundo_nombre?: StringNullableFilter<"Paciente"> | string | null
    primer_apellido?: StringFilter<"Paciente"> | string
    segundo_apellido?: StringNullableFilter<"Paciente"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Paciente"> | Date | string
    sexo?: EnumSexFilter<"Paciente"> | $Enums.Sex
    email?: StringFilter<"Paciente"> | string
    telefono?: StringNullableFilter<"Paciente"> | string | null
    direccion?: StringNullableFilter<"Paciente"> | string | null
    tipo_paciente?: EnumTipo_PacienteFilter<"Paciente"> | $Enums.Tipo_Paciente
    estado?: EnumEstadoFilter<"Paciente"> | $Enums.Estado
    municipioId?: IntFilter<"Paciente"> | number
    epsId?: IntFilter<"Paciente"> | number
  }

  export type ProcedimientoCreateWithoutTipo_procedimientoInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutProcedimientoInput
    acuerdo: AcuerdoCreateNestedOneWithoutProcedimientoInput
    paciente: PacienteCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    acuerdoId: number
    pacienteId: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutProcedimientoInput
  }

  export type ProcedimientoCreateOrConnectWithoutTipo_procedimientoInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutTipo_procedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput>
  }

  export type ProcedimientoCreateManyTipo_procedimientoInputEnvelope = {
    data: ProcedimientoCreateManyTipo_procedimientoInput | ProcedimientoCreateManyTipo_procedimientoInput[]
    skipDuplicates?: boolean
  }

  export type ProcedimientoUpsertWithWhereUniqueWithoutTipo_procedimientoInput = {
    where: ProcedimientoWhereUniqueInput
    update: XOR<ProcedimientoUpdateWithoutTipo_procedimientoInput, ProcedimientoUncheckedUpdateWithoutTipo_procedimientoInput>
    create: XOR<ProcedimientoCreateWithoutTipo_procedimientoInput, ProcedimientoUncheckedCreateWithoutTipo_procedimientoInput>
  }

  export type ProcedimientoUpdateWithWhereUniqueWithoutTipo_procedimientoInput = {
    where: ProcedimientoWhereUniqueInput
    data: XOR<ProcedimientoUpdateWithoutTipo_procedimientoInput, ProcedimientoUncheckedUpdateWithoutTipo_procedimientoInput>
  }

  export type ProcedimientoUpdateManyWithWhereWithoutTipo_procedimientoInput = {
    where: ProcedimientoScalarWhereInput
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyWithoutTipo_procedimientoInput>
  }

  export type EstudioCreateWithoutProcedimientoInput = {
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    paquete: PaqueteCreateNestedOneWithoutEstudioInput
  }

  export type EstudioUncheckedCreateWithoutProcedimientoInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    paqueteId: number
  }

  export type EstudioCreateOrConnectWithoutProcedimientoInput = {
    where: EstudioWhereUniqueInput
    create: XOR<EstudioCreateWithoutProcedimientoInput, EstudioUncheckedCreateWithoutProcedimientoInput>
  }

  export type EstudioCreateManyProcedimientoInputEnvelope = {
    data: EstudioCreateManyProcedimientoInput | EstudioCreateManyProcedimientoInput[]
    skipDuplicates?: boolean
  }

  export type AcuerdoCreateWithoutProcedimientoInput = {
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    contrato: ContratoCreateNestedOneWithoutAcuerdoInput
    servicio: ServicioCreateNestedOneWithoutAcuerdoInput
  }

  export type AcuerdoUncheckedCreateWithoutProcedimientoInput = {
    id_acuerdo?: number
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    contratoId: number
    servicioId: number
  }

  export type AcuerdoCreateOrConnectWithoutProcedimientoInput = {
    where: AcuerdoWhereUniqueInput
    create: XOR<AcuerdoCreateWithoutProcedimientoInput, AcuerdoUncheckedCreateWithoutProcedimientoInput>
  }

  export type Tipo_ProcedimientoCreateWithoutProcedimientoInput = {
    nombre: string
  }

  export type Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput = {
    id_tipo_procedimiento?: number
    nombre: string
  }

  export type Tipo_ProcedimientoCreateOrConnectWithoutProcedimientoInput = {
    where: Tipo_ProcedimientoWhereUniqueInput
    create: XOR<Tipo_ProcedimientoCreateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput>
  }

  export type PacienteCreateWithoutProcedimientoInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    municipio: MunicipioCreateNestedOneWithoutPacienteInput
    eps: EpsCreateNestedOneWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutProcedimientoInput = {
    id_paciente?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    municipioId: number
    epsId: number
  }

  export type PacienteCreateOrConnectWithoutProcedimientoInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutProcedimientoInput, PacienteUncheckedCreateWithoutProcedimientoInput>
  }

  export type EstudioUpsertWithWhereUniqueWithoutProcedimientoInput = {
    where: EstudioWhereUniqueInput
    update: XOR<EstudioUpdateWithoutProcedimientoInput, EstudioUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<EstudioCreateWithoutProcedimientoInput, EstudioUncheckedCreateWithoutProcedimientoInput>
  }

  export type EstudioUpdateWithWhereUniqueWithoutProcedimientoInput = {
    where: EstudioWhereUniqueInput
    data: XOR<EstudioUpdateWithoutProcedimientoInput, EstudioUncheckedUpdateWithoutProcedimientoInput>
  }

  export type EstudioUpdateManyWithWhereWithoutProcedimientoInput = {
    where: EstudioScalarWhereInput
    data: XOR<EstudioUpdateManyMutationInput, EstudioUncheckedUpdateManyWithoutProcedimientoInput>
  }

  export type EstudioScalarWhereInput = {
    AND?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
    OR?: EstudioScalarWhereInput[]
    NOT?: EstudioScalarWhereInput | EstudioScalarWhereInput[]
    id_estudio?: IntFilter<"Estudio"> | number
    consecutivo?: IntFilter<"Estudio"> | number
    cantidad?: IntFilter<"Estudio"> | number
    fecha_muestra?: DateTimeFilter<"Estudio"> | Date | string
    fecha_resultado?: DateTimeFilter<"Estudio"> | Date | string
    resultado?: StringFilter<"Estudio"> | string
    observacion?: StringFilter<"Estudio"> | string
    profesional?: IntFilter<"Estudio"> | number
    paqueteId?: IntFilter<"Estudio"> | number
    procedimientoId?: IntFilter<"Estudio"> | number
  }

  export type AcuerdoUpsertWithoutProcedimientoInput = {
    update: XOR<AcuerdoUpdateWithoutProcedimientoInput, AcuerdoUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<AcuerdoCreateWithoutProcedimientoInput, AcuerdoUncheckedCreateWithoutProcedimientoInput>
    where?: AcuerdoWhereInput
  }

  export type AcuerdoUpdateToOneWithWhereWithoutProcedimientoInput = {
    where?: AcuerdoWhereInput
    data: XOR<AcuerdoUpdateWithoutProcedimientoInput, AcuerdoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type AcuerdoUpdateWithoutProcedimientoInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contrato?: ContratoUpdateOneRequiredWithoutAcuerdoNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateWithoutProcedimientoInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contratoId?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ProcedimientoUpsertWithoutProcedimientoInput = {
    update: XOR<Tipo_ProcedimientoUpdateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<Tipo_ProcedimientoCreateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedCreateWithoutProcedimientoInput>
    where?: Tipo_ProcedimientoWhereInput
  }

  export type Tipo_ProcedimientoUpdateToOneWithWhereWithoutProcedimientoInput = {
    where?: Tipo_ProcedimientoWhereInput
    data: XOR<Tipo_ProcedimientoUpdateWithoutProcedimientoInput, Tipo_ProcedimientoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type Tipo_ProcedimientoUpdateWithoutProcedimientoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type Tipo_ProcedimientoUncheckedUpdateWithoutProcedimientoInput = {
    id_tipo_procedimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type PacienteUpsertWithoutProcedimientoInput = {
    update: XOR<PacienteUpdateWithoutProcedimientoInput, PacienteUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<PacienteCreateWithoutProcedimientoInput, PacienteUncheckedCreateWithoutProcedimientoInput>
    where?: PacienteWhereInput
  }

  export type PacienteUpdateToOneWithWhereWithoutProcedimientoInput = {
    where?: PacienteWhereInput
    data: XOR<PacienteUpdateWithoutProcedimientoInput, PacienteUncheckedUpdateWithoutProcedimientoInput>
  }

  export type PacienteUpdateWithoutProcedimientoInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: MunicipioUpdateOneRequiredWithoutPacienteNestedInput
    eps?: EpsUpdateOneRequiredWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutProcedimientoInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipioId?: IntFieldUpdateOperationsInput | number
    epsId?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteCreateWithoutEstudioInput = {
    estado?: $Enums.Estado
    examen: ExamenCreateNestedOneWithoutPaqueteInput
    servicio: ServicioCreateNestedOneWithoutPaqueteInput
  }

  export type PaqueteUncheckedCreateWithoutEstudioInput = {
    id_paquete?: number
    estado?: $Enums.Estado
    examenId: number
    servicioId: number
  }

  export type PaqueteCreateOrConnectWithoutEstudioInput = {
    where: PaqueteWhereUniqueInput
    create: XOR<PaqueteCreateWithoutEstudioInput, PaqueteUncheckedCreateWithoutEstudioInput>
  }

  export type ProcedimientoCreateWithoutEstudioInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    acuerdo: AcuerdoCreateNestedOneWithoutProcedimientoInput
    tipo_procedimiento: Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput
    paciente: PacienteCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutEstudioInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    acuerdoId: number
    tipo_procedimientoId: number
    pacienteId: number
  }

  export type ProcedimientoCreateOrConnectWithoutEstudioInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutEstudioInput, ProcedimientoUncheckedCreateWithoutEstudioInput>
  }

  export type PaqueteUpsertWithoutEstudioInput = {
    update: XOR<PaqueteUpdateWithoutEstudioInput, PaqueteUncheckedUpdateWithoutEstudioInput>
    create: XOR<PaqueteCreateWithoutEstudioInput, PaqueteUncheckedCreateWithoutEstudioInput>
    where?: PaqueteWhereInput
  }

  export type PaqueteUpdateToOneWithWhereWithoutEstudioInput = {
    where?: PaqueteWhereInput
    data: XOR<PaqueteUpdateWithoutEstudioInput, PaqueteUncheckedUpdateWithoutEstudioInput>
  }

  export type PaqueteUpdateWithoutEstudioInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examen?: ExamenUpdateOneRequiredWithoutPaqueteNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutPaqueteNestedInput
  }

  export type PaqueteUncheckedUpdateWithoutEstudioInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examenId?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoUpsertWithoutEstudioInput = {
    update: XOR<ProcedimientoUpdateWithoutEstudioInput, ProcedimientoUncheckedUpdateWithoutEstudioInput>
    create: XOR<ProcedimientoCreateWithoutEstudioInput, ProcedimientoUncheckedCreateWithoutEstudioInput>
    where?: ProcedimientoWhereInput
  }

  export type ProcedimientoUpdateToOneWithWhereWithoutEstudioInput = {
    where?: ProcedimientoWhereInput
    data: XOR<ProcedimientoUpdateWithoutEstudioInput, ProcedimientoUncheckedUpdateWithoutEstudioInput>
  }

  export type ProcedimientoUpdateWithoutEstudioInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acuerdo?: AcuerdoUpdateOneRequiredWithoutProcedimientoNestedInput
    tipo_procedimiento?: Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutEstudioInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acuerdoId?: IntFieldUpdateOperationsInput | number
    tipo_procedimientoId?: IntFieldUpdateOperationsInput | number
    pacienteId?: IntFieldUpdateOperationsInput | number
  }

  export type MunicipioCreateWithoutDepartamentoInput = {
    nombre: string
    paciente?: PacienteCreateNestedManyWithoutMunicipioInput
    empresa?: EmpresaCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateWithoutDepartamentoInput = {
    id_municipio?: number
    nombre: string
    paciente?: PacienteUncheckedCreateNestedManyWithoutMunicipioInput
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioCreateOrConnectWithoutDepartamentoInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutDepartamentoInput, MunicipioUncheckedCreateWithoutDepartamentoInput>
  }

  export type MunicipioCreateManyDepartamentoInputEnvelope = {
    data: MunicipioCreateManyDepartamentoInput | MunicipioCreateManyDepartamentoInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioUpsertWithWhereUniqueWithoutDepartamentoInput = {
    where: MunicipioWhereUniqueInput
    update: XOR<MunicipioUpdateWithoutDepartamentoInput, MunicipioUncheckedUpdateWithoutDepartamentoInput>
    create: XOR<MunicipioCreateWithoutDepartamentoInput, MunicipioUncheckedCreateWithoutDepartamentoInput>
  }

  export type MunicipioUpdateWithWhereUniqueWithoutDepartamentoInput = {
    where: MunicipioWhereUniqueInput
    data: XOR<MunicipioUpdateWithoutDepartamentoInput, MunicipioUncheckedUpdateWithoutDepartamentoInput>
  }

  export type MunicipioUpdateManyWithWhereWithoutDepartamentoInput = {
    where: MunicipioScalarWhereInput
    data: XOR<MunicipioUpdateManyMutationInput, MunicipioUncheckedUpdateManyWithoutDepartamentoInput>
  }

  export type MunicipioScalarWhereInput = {
    AND?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
    OR?: MunicipioScalarWhereInput[]
    NOT?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
    id_municipio?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
    departamentoId?: IntFilter<"Municipio"> | number
  }

  export type DepartamentoCreateWithoutMunicipioInput = {
    nombre: string
  }

  export type DepartamentoUncheckedCreateWithoutMunicipioInput = {
    id_departamento?: number
    nombre: string
  }

  export type DepartamentoCreateOrConnectWithoutMunicipioInput = {
    where: DepartamentoWhereUniqueInput
    create: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
  }

  export type PacienteCreateWithoutMunicipioInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    procedimiento?: ProcedimientoCreateNestedManyWithoutPacienteInput
    eps: EpsCreateNestedOneWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutMunicipioInput = {
    id_paciente?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    epsId: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutMunicipioInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutMunicipioInput, PacienteUncheckedCreateWithoutMunicipioInput>
  }

  export type PacienteCreateManyMunicipioInputEnvelope = {
    data: PacienteCreateManyMunicipioInput | PacienteCreateManyMunicipioInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaCreateWithoutMunicipioInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado?: $Enums.Estado
    contrato?: ContratoCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutMunicipioInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado?: $Enums.Estado
    contrato?: ContratoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutMunicipioInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutMunicipioInput, EmpresaUncheckedCreateWithoutMunicipioInput>
  }

  export type EmpresaCreateManyMunicipioInputEnvelope = {
    data: EmpresaCreateManyMunicipioInput | EmpresaCreateManyMunicipioInput[]
    skipDuplicates?: boolean
  }

  export type DepartamentoUpsertWithoutMunicipioInput = {
    update: XOR<DepartamentoUpdateWithoutMunicipioInput, DepartamentoUncheckedUpdateWithoutMunicipioInput>
    create: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    where?: DepartamentoWhereInput
  }

  export type DepartamentoUpdateToOneWithWhereWithoutMunicipioInput = {
    where?: DepartamentoWhereInput
    data: XOR<DepartamentoUpdateWithoutMunicipioInput, DepartamentoUncheckedUpdateWithoutMunicipioInput>
  }

  export type DepartamentoUpdateWithoutMunicipioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentoUncheckedUpdateWithoutMunicipioInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type PacienteUpsertWithWhereUniqueWithoutMunicipioInput = {
    where: PacienteWhereUniqueInput
    update: XOR<PacienteUpdateWithoutMunicipioInput, PacienteUncheckedUpdateWithoutMunicipioInput>
    create: XOR<PacienteCreateWithoutMunicipioInput, PacienteUncheckedCreateWithoutMunicipioInput>
  }

  export type PacienteUpdateWithWhereUniqueWithoutMunicipioInput = {
    where: PacienteWhereUniqueInput
    data: XOR<PacienteUpdateWithoutMunicipioInput, PacienteUncheckedUpdateWithoutMunicipioInput>
  }

  export type PacienteUpdateManyWithWhereWithoutMunicipioInput = {
    where: PacienteScalarWhereInput
    data: XOR<PacienteUpdateManyMutationInput, PacienteUncheckedUpdateManyWithoutMunicipioInput>
  }

  export type EmpresaUpsertWithWhereUniqueWithoutMunicipioInput = {
    where: EmpresaWhereUniqueInput
    update: XOR<EmpresaUpdateWithoutMunicipioInput, EmpresaUncheckedUpdateWithoutMunicipioInput>
    create: XOR<EmpresaCreateWithoutMunicipioInput, EmpresaUncheckedCreateWithoutMunicipioInput>
  }

  export type EmpresaUpdateWithWhereUniqueWithoutMunicipioInput = {
    where: EmpresaWhereUniqueInput
    data: XOR<EmpresaUpdateWithoutMunicipioInput, EmpresaUncheckedUpdateWithoutMunicipioInput>
  }

  export type EmpresaUpdateManyWithWhereWithoutMunicipioInput = {
    where: EmpresaScalarWhereInput
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyWithoutMunicipioInput>
  }

  export type EmpresaScalarWhereInput = {
    AND?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
    OR?: EmpresaScalarWhereInput[]
    NOT?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
    id_empresa?: IntFilter<"Empresa"> | number
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipioId?: IntFilter<"Empresa"> | number
  }

  export type ServicioCreateWithoutTipo_servicioInput = {
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    paquete?: PaqueteCreateNestedManyWithoutServicioInput
    acuerdo?: AcuerdoCreateNestedManyWithoutServicioInput
    prestador: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutTipo_servicioInput = {
    id_servicio?: number
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    prestadorId: number
    paquete?: PaqueteUncheckedCreateNestedManyWithoutServicioInput
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutTipo_servicioInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutTipo_servicioInput, ServicioUncheckedCreateWithoutTipo_servicioInput>
  }

  export type ServicioCreateManyTipo_servicioInputEnvelope = {
    data: ServicioCreateManyTipo_servicioInput | ServicioCreateManyTipo_servicioInput[]
    skipDuplicates?: boolean
  }

  export type ServicioUpsertWithWhereUniqueWithoutTipo_servicioInput = {
    where: ServicioWhereUniqueInput
    update: XOR<ServicioUpdateWithoutTipo_servicioInput, ServicioUncheckedUpdateWithoutTipo_servicioInput>
    create: XOR<ServicioCreateWithoutTipo_servicioInput, ServicioUncheckedCreateWithoutTipo_servicioInput>
  }

  export type ServicioUpdateWithWhereUniqueWithoutTipo_servicioInput = {
    where: ServicioWhereUniqueInput
    data: XOR<ServicioUpdateWithoutTipo_servicioInput, ServicioUncheckedUpdateWithoutTipo_servicioInput>
  }

  export type ServicioUpdateManyWithWhereWithoutTipo_servicioInput = {
    where: ServicioScalarWhereInput
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyWithoutTipo_servicioInput>
  }

  export type ServicioScalarWhereInput = {
    AND?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
    OR?: ServicioScalarWhereInput[]
    NOT?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
    id_servicio?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    nivel?: IntFilter<"Servicio"> | number
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Servicio"> | $Enums.Estado
    tipo_servicioId?: IntFilter<"Servicio"> | number
    prestadorId?: IntFilter<"Servicio"> | number
  }

  export type PaqueteCreateWithoutServicioInput = {
    estado?: $Enums.Estado
    estudio?: EstudioCreateNestedManyWithoutPaqueteInput
    examen: ExamenCreateNestedOneWithoutPaqueteInput
  }

  export type PaqueteUncheckedCreateWithoutServicioInput = {
    id_paquete?: number
    estado?: $Enums.Estado
    examenId: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutPaqueteInput
  }

  export type PaqueteCreateOrConnectWithoutServicioInput = {
    where: PaqueteWhereUniqueInput
    create: XOR<PaqueteCreateWithoutServicioInput, PaqueteUncheckedCreateWithoutServicioInput>
  }

  export type PaqueteCreateManyServicioInputEnvelope = {
    data: PaqueteCreateManyServicioInput | PaqueteCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type AcuerdoCreateWithoutServicioInput = {
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutAcuerdoInput
    contrato: ContratoCreateNestedOneWithoutAcuerdoInput
  }

  export type AcuerdoUncheckedCreateWithoutServicioInput = {
    id_acuerdo?: number
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    contratoId: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutAcuerdoInput
  }

  export type AcuerdoCreateOrConnectWithoutServicioInput = {
    where: AcuerdoWhereUniqueInput
    create: XOR<AcuerdoCreateWithoutServicioInput, AcuerdoUncheckedCreateWithoutServicioInput>
  }

  export type AcuerdoCreateManyServicioInputEnvelope = {
    data: AcuerdoCreateManyServicioInput | AcuerdoCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type Tipo_ServicioCreateWithoutServicioInput = {
    nombre: string
    estado?: $Enums.Estado
  }

  export type Tipo_ServicioUncheckedCreateWithoutServicioInput = {
    id_tipo_servicio?: number
    nombre: string
    estado?: $Enums.Estado
  }

  export type Tipo_ServicioCreateOrConnectWithoutServicioInput = {
    where: Tipo_ServicioWhereUniqueInput
    create: XOR<Tipo_ServicioCreateWithoutServicioInput, Tipo_ServicioUncheckedCreateWithoutServicioInput>
  }

  export type PrestadorCreateWithoutServicioInput = {
    codigo: string
    nit: string
    razon_social: string
    usuario?: UsuarioCreateNestedManyWithoutPrestadorInput
  }

  export type PrestadorUncheckedCreateWithoutServicioInput = {
    id_prestador?: number
    codigo: string
    nit: string
    razon_social: string
    usuario?: UsuarioUncheckedCreateNestedManyWithoutPrestadorInput
  }

  export type PrestadorCreateOrConnectWithoutServicioInput = {
    where: PrestadorWhereUniqueInput
    create: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
  }

  export type PaqueteUpsertWithWhereUniqueWithoutServicioInput = {
    where: PaqueteWhereUniqueInput
    update: XOR<PaqueteUpdateWithoutServicioInput, PaqueteUncheckedUpdateWithoutServicioInput>
    create: XOR<PaqueteCreateWithoutServicioInput, PaqueteUncheckedCreateWithoutServicioInput>
  }

  export type PaqueteUpdateWithWhereUniqueWithoutServicioInput = {
    where: PaqueteWhereUniqueInput
    data: XOR<PaqueteUpdateWithoutServicioInput, PaqueteUncheckedUpdateWithoutServicioInput>
  }

  export type PaqueteUpdateManyWithWhereWithoutServicioInput = {
    where: PaqueteScalarWhereInput
    data: XOR<PaqueteUpdateManyMutationInput, PaqueteUncheckedUpdateManyWithoutServicioInput>
  }

  export type PaqueteScalarWhereInput = {
    AND?: PaqueteScalarWhereInput | PaqueteScalarWhereInput[]
    OR?: PaqueteScalarWhereInput[]
    NOT?: PaqueteScalarWhereInput | PaqueteScalarWhereInput[]
    id_paquete?: IntFilter<"Paquete"> | number
    estado?: EnumEstadoFilter<"Paquete"> | $Enums.Estado
    examenId?: IntFilter<"Paquete"> | number
    servicioId?: IntFilter<"Paquete"> | number
  }

  export type AcuerdoUpsertWithWhereUniqueWithoutServicioInput = {
    where: AcuerdoWhereUniqueInput
    update: XOR<AcuerdoUpdateWithoutServicioInput, AcuerdoUncheckedUpdateWithoutServicioInput>
    create: XOR<AcuerdoCreateWithoutServicioInput, AcuerdoUncheckedCreateWithoutServicioInput>
  }

  export type AcuerdoUpdateWithWhereUniqueWithoutServicioInput = {
    where: AcuerdoWhereUniqueInput
    data: XOR<AcuerdoUpdateWithoutServicioInput, AcuerdoUncheckedUpdateWithoutServicioInput>
  }

  export type AcuerdoUpdateManyWithWhereWithoutServicioInput = {
    where: AcuerdoScalarWhereInput
    data: XOR<AcuerdoUpdateManyMutationInput, AcuerdoUncheckedUpdateManyWithoutServicioInput>
  }

  export type AcuerdoScalarWhereInput = {
    AND?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
    OR?: AcuerdoScalarWhereInput[]
    NOT?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
    id_acuerdo?: IntFilter<"Acuerdo"> | number
    estado?: EnumEstadoFilter<"Acuerdo"> | $Enums.Estado
    precio?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFilter<"Acuerdo"> | Date | string
    updateAt?: DateTimeFilter<"Acuerdo"> | Date | string
    contratoId?: IntFilter<"Acuerdo"> | number
    servicioId?: IntFilter<"Acuerdo"> | number
  }

  export type Tipo_ServicioUpsertWithoutServicioInput = {
    update: XOR<Tipo_ServicioUpdateWithoutServicioInput, Tipo_ServicioUncheckedUpdateWithoutServicioInput>
    create: XOR<Tipo_ServicioCreateWithoutServicioInput, Tipo_ServicioUncheckedCreateWithoutServicioInput>
    where?: Tipo_ServicioWhereInput
  }

  export type Tipo_ServicioUpdateToOneWithWhereWithoutServicioInput = {
    where?: Tipo_ServicioWhereInput
    data: XOR<Tipo_ServicioUpdateWithoutServicioInput, Tipo_ServicioUncheckedUpdateWithoutServicioInput>
  }

  export type Tipo_ServicioUpdateWithoutServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ServicioUncheckedUpdateWithoutServicioInput = {
    id_tipo_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PrestadorUpsertWithoutServicioInput = {
    update: XOR<PrestadorUpdateWithoutServicioInput, PrestadorUncheckedUpdateWithoutServicioInput>
    create: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    where?: PrestadorWhereInput
  }

  export type PrestadorUpdateToOneWithWhereWithoutServicioInput = {
    where?: PrestadorWhereInput
    data: XOR<PrestadorUpdateWithoutServicioInput, PrestadorUncheckedUpdateWithoutServicioInput>
  }

  export type PrestadorUpdateWithoutServicioInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateManyWithoutPrestadorNestedInput
  }

  export type PrestadorUncheckedUpdateWithoutServicioInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUncheckedUpdateManyWithoutPrestadorNestedInput
  }

  export type Tipo_ExamenCreateWithoutExamenInput = {
    nombre: string
    estado?: $Enums.Estado
  }

  export type Tipo_ExamenUncheckedCreateWithoutExamenInput = {
    id_tipo_examen?: number
    nombre: string
    estado?: $Enums.Estado
  }

  export type Tipo_ExamenCreateOrConnectWithoutExamenInput = {
    where: Tipo_ExamenWhereUniqueInput
    create: XOR<Tipo_ExamenCreateWithoutExamenInput, Tipo_ExamenUncheckedCreateWithoutExamenInput>
  }

  export type Tipo_ResultadoCreateWithoutExamenInput = {
    nombre: string
    estado?: $Enums.Estado
  }

  export type Tipo_ResultadoUncheckedCreateWithoutExamenInput = {
    id_tipo_resultado?: number
    nombre: string
    estado?: $Enums.Estado
  }

  export type Tipo_ResultadoCreateOrConnectWithoutExamenInput = {
    where: Tipo_ResultadoWhereUniqueInput
    create: XOR<Tipo_ResultadoCreateWithoutExamenInput, Tipo_ResultadoUncheckedCreateWithoutExamenInput>
  }

  export type Tipo_ResultadoCreateManyExamenInputEnvelope = {
    data: Tipo_ResultadoCreateManyExamenInput | Tipo_ResultadoCreateManyExamenInput[]
    skipDuplicates?: boolean
  }

  export type PaqueteCreateWithoutExamenInput = {
    estado?: $Enums.Estado
    estudio?: EstudioCreateNestedManyWithoutPaqueteInput
    servicio: ServicioCreateNestedOneWithoutPaqueteInput
  }

  export type PaqueteUncheckedCreateWithoutExamenInput = {
    id_paquete?: number
    estado?: $Enums.Estado
    servicioId: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutPaqueteInput
  }

  export type PaqueteCreateOrConnectWithoutExamenInput = {
    where: PaqueteWhereUniqueInput
    create: XOR<PaqueteCreateWithoutExamenInput, PaqueteUncheckedCreateWithoutExamenInput>
  }

  export type PaqueteCreateManyExamenInputEnvelope = {
    data: PaqueteCreateManyExamenInput | PaqueteCreateManyExamenInput[]
    skipDuplicates?: boolean
  }

  export type Tipo_ExamenUpsertWithoutExamenInput = {
    update: XOR<Tipo_ExamenUpdateWithoutExamenInput, Tipo_ExamenUncheckedUpdateWithoutExamenInput>
    create: XOR<Tipo_ExamenCreateWithoutExamenInput, Tipo_ExamenUncheckedCreateWithoutExamenInput>
    where?: Tipo_ExamenWhereInput
  }

  export type Tipo_ExamenUpdateToOneWithWhereWithoutExamenInput = {
    where?: Tipo_ExamenWhereInput
    data: XOR<Tipo_ExamenUpdateWithoutExamenInput, Tipo_ExamenUncheckedUpdateWithoutExamenInput>
  }

  export type Tipo_ExamenUpdateWithoutExamenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ExamenUncheckedUpdateWithoutExamenInput = {
    id_tipo_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ResultadoUpsertWithWhereUniqueWithoutExamenInput = {
    where: Tipo_ResultadoWhereUniqueInput
    update: XOR<Tipo_ResultadoUpdateWithoutExamenInput, Tipo_ResultadoUncheckedUpdateWithoutExamenInput>
    create: XOR<Tipo_ResultadoCreateWithoutExamenInput, Tipo_ResultadoUncheckedCreateWithoutExamenInput>
  }

  export type Tipo_ResultadoUpdateWithWhereUniqueWithoutExamenInput = {
    where: Tipo_ResultadoWhereUniqueInput
    data: XOR<Tipo_ResultadoUpdateWithoutExamenInput, Tipo_ResultadoUncheckedUpdateWithoutExamenInput>
  }

  export type Tipo_ResultadoUpdateManyWithWhereWithoutExamenInput = {
    where: Tipo_ResultadoScalarWhereInput
    data: XOR<Tipo_ResultadoUpdateManyMutationInput, Tipo_ResultadoUncheckedUpdateManyWithoutExamenInput>
  }

  export type Tipo_ResultadoScalarWhereInput = {
    AND?: Tipo_ResultadoScalarWhereInput | Tipo_ResultadoScalarWhereInput[]
    OR?: Tipo_ResultadoScalarWhereInput[]
    NOT?: Tipo_ResultadoScalarWhereInput | Tipo_ResultadoScalarWhereInput[]
    id_tipo_resultado?: IntFilter<"Tipo_Resultado"> | number
    nombre?: StringFilter<"Tipo_Resultado"> | string
    estado?: EnumEstadoFilter<"Tipo_Resultado"> | $Enums.Estado
    examenId?: IntFilter<"Tipo_Resultado"> | number
  }

  export type PaqueteUpsertWithWhereUniqueWithoutExamenInput = {
    where: PaqueteWhereUniqueInput
    update: XOR<PaqueteUpdateWithoutExamenInput, PaqueteUncheckedUpdateWithoutExamenInput>
    create: XOR<PaqueteCreateWithoutExamenInput, PaqueteUncheckedCreateWithoutExamenInput>
  }

  export type PaqueteUpdateWithWhereUniqueWithoutExamenInput = {
    where: PaqueteWhereUniqueInput
    data: XOR<PaqueteUpdateWithoutExamenInput, PaqueteUncheckedUpdateWithoutExamenInput>
  }

  export type PaqueteUpdateManyWithWhereWithoutExamenInput = {
    where: PaqueteScalarWhereInput
    data: XOR<PaqueteUpdateManyMutationInput, PaqueteUncheckedUpdateManyWithoutExamenInput>
  }

  export type ExamenCreateWithoutTipo_resultadoInput = {
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_examen: Tipo_ExamenCreateNestedOneWithoutExamenInput
    paquete?: PaqueteCreateNestedManyWithoutExamenInput
  }

  export type ExamenUncheckedCreateWithoutTipo_resultadoInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_examenId: number
    paquete?: PaqueteUncheckedCreateNestedManyWithoutExamenInput
  }

  export type ExamenCreateOrConnectWithoutTipo_resultadoInput = {
    where: ExamenWhereUniqueInput
    create: XOR<ExamenCreateWithoutTipo_resultadoInput, ExamenUncheckedCreateWithoutTipo_resultadoInput>
  }

  export type ExamenUpsertWithoutTipo_resultadoInput = {
    update: XOR<ExamenUpdateWithoutTipo_resultadoInput, ExamenUncheckedUpdateWithoutTipo_resultadoInput>
    create: XOR<ExamenCreateWithoutTipo_resultadoInput, ExamenUncheckedCreateWithoutTipo_resultadoInput>
    where?: ExamenWhereInput
  }

  export type ExamenUpdateToOneWithWhereWithoutTipo_resultadoInput = {
    where?: ExamenWhereInput
    data: XOR<ExamenUpdateWithoutTipo_resultadoInput, ExamenUncheckedUpdateWithoutTipo_resultadoInput>
  }

  export type ExamenUpdateWithoutTipo_resultadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examen?: Tipo_ExamenUpdateOneRequiredWithoutExamenNestedInput
    paquete?: PaqueteUpdateManyWithoutExamenNestedInput
  }

  export type ExamenUncheckedUpdateWithoutTipo_resultadoInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examenId?: IntFieldUpdateOperationsInput | number
    paquete?: PaqueteUncheckedUpdateManyWithoutExamenNestedInput
  }

  export type ExamenCreateWithoutTipo_examenInput = {
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_resultado?: Tipo_ResultadoCreateNestedManyWithoutExamenInput
    paquete?: PaqueteCreateNestedManyWithoutExamenInput
  }

  export type ExamenUncheckedCreateWithoutTipo_examenInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_resultado?: Tipo_ResultadoUncheckedCreateNestedManyWithoutExamenInput
    paquete?: PaqueteUncheckedCreateNestedManyWithoutExamenInput
  }

  export type ExamenCreateOrConnectWithoutTipo_examenInput = {
    where: ExamenWhereUniqueInput
    create: XOR<ExamenCreateWithoutTipo_examenInput, ExamenUncheckedCreateWithoutTipo_examenInput>
  }

  export type ExamenCreateManyTipo_examenInputEnvelope = {
    data: ExamenCreateManyTipo_examenInput | ExamenCreateManyTipo_examenInput[]
    skipDuplicates?: boolean
  }

  export type ExamenUpsertWithWhereUniqueWithoutTipo_examenInput = {
    where: ExamenWhereUniqueInput
    update: XOR<ExamenUpdateWithoutTipo_examenInput, ExamenUncheckedUpdateWithoutTipo_examenInput>
    create: XOR<ExamenCreateWithoutTipo_examenInput, ExamenUncheckedCreateWithoutTipo_examenInput>
  }

  export type ExamenUpdateWithWhereUniqueWithoutTipo_examenInput = {
    where: ExamenWhereUniqueInput
    data: XOR<ExamenUpdateWithoutTipo_examenInput, ExamenUncheckedUpdateWithoutTipo_examenInput>
  }

  export type ExamenUpdateManyWithWhereWithoutTipo_examenInput = {
    where: ExamenScalarWhereInput
    data: XOR<ExamenUpdateManyMutationInput, ExamenUncheckedUpdateManyWithoutTipo_examenInput>
  }

  export type ExamenScalarWhereInput = {
    AND?: ExamenScalarWhereInput | ExamenScalarWhereInput[]
    OR?: ExamenScalarWhereInput[]
    NOT?: ExamenScalarWhereInput | ExamenScalarWhereInput[]
    id_examen?: IntFilter<"Examen"> | number
    nombre?: StringFilter<"Examen"> | string
    unidades?: StringFilter<"Examen"> | string
    rango_biologico?: StringFilter<"Examen"> | string
    metodo?: StringFilter<"Examen"> | string
    precio?: DecimalFilter<"Examen"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Examen"> | $Enums.Estado
    tipo_examenId?: IntFilter<"Examen"> | number
  }

  export type ServicioCreateWithoutPrestadorInput = {
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    paquete?: PaqueteCreateNestedManyWithoutServicioInput
    acuerdo?: AcuerdoCreateNestedManyWithoutServicioInput
    tipo_servicio: Tipo_ServicioCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutPrestadorInput = {
    id_servicio?: number
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_servicioId: number
    paquete?: PaqueteUncheckedCreateNestedManyWithoutServicioInput
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutPrestadorInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutPrestadorInput, ServicioUncheckedCreateWithoutPrestadorInput>
  }

  export type ServicioCreateManyPrestadorInputEnvelope = {
    data: ServicioCreateManyPrestadorInput | ServicioCreateManyPrestadorInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutPrestadorInput = {
    identificacion: string
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado?: $Enums.Estado
  }

  export type UsuarioUncheckedCreateWithoutPrestadorInput = {
    id_usuario?: number
    identificacion: string
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado?: $Enums.Estado
  }

  export type UsuarioCreateOrConnectWithoutPrestadorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPrestadorInput, UsuarioUncheckedCreateWithoutPrestadorInput>
  }

  export type UsuarioCreateManyPrestadorInputEnvelope = {
    data: UsuarioCreateManyPrestadorInput | UsuarioCreateManyPrestadorInput[]
    skipDuplicates?: boolean
  }

  export type ServicioUpsertWithWhereUniqueWithoutPrestadorInput = {
    where: ServicioWhereUniqueInput
    update: XOR<ServicioUpdateWithoutPrestadorInput, ServicioUncheckedUpdateWithoutPrestadorInput>
    create: XOR<ServicioCreateWithoutPrestadorInput, ServicioUncheckedCreateWithoutPrestadorInput>
  }

  export type ServicioUpdateWithWhereUniqueWithoutPrestadorInput = {
    where: ServicioWhereUniqueInput
    data: XOR<ServicioUpdateWithoutPrestadorInput, ServicioUncheckedUpdateWithoutPrestadorInput>
  }

  export type ServicioUpdateManyWithWhereWithoutPrestadorInput = {
    where: ServicioScalarWhereInput
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyWithoutPrestadorInput>
  }

  export type UsuarioUpsertWithWhereUniqueWithoutPrestadorInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutPrestadorInput, UsuarioUncheckedUpdateWithoutPrestadorInput>
    create: XOR<UsuarioCreateWithoutPrestadorInput, UsuarioUncheckedCreateWithoutPrestadorInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutPrestadorInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutPrestadorInput, UsuarioUncheckedUpdateWithoutPrestadorInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutPrestadorInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutPrestadorInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id_usuario?: IntFilter<"Usuario"> | number
    identificacion?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    cargo?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    email?: StringFilter<"Usuario"> | string
    password?: StringFilter<"Usuario"> | string
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    prestadorId?: IntFilter<"Usuario"> | number
  }

  export type PrestadorCreateWithoutUsuarioInput = {
    codigo: string
    nit: string
    razon_social: string
    servicio?: ServicioCreateNestedManyWithoutPrestadorInput
  }

  export type PrestadorUncheckedCreateWithoutUsuarioInput = {
    id_prestador?: number
    codigo: string
    nit: string
    razon_social: string
    servicio?: ServicioUncheckedCreateNestedManyWithoutPrestadorInput
  }

  export type PrestadorCreateOrConnectWithoutUsuarioInput = {
    where: PrestadorWhereUniqueInput
    create: XOR<PrestadorCreateWithoutUsuarioInput, PrestadorUncheckedCreateWithoutUsuarioInput>
  }

  export type PrestadorUpsertWithoutUsuarioInput = {
    update: XOR<PrestadorUpdateWithoutUsuarioInput, PrestadorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PrestadorCreateWithoutUsuarioInput, PrestadorUncheckedCreateWithoutUsuarioInput>
    where?: PrestadorWhereInput
  }

  export type PrestadorUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: PrestadorWhereInput
    data: XOR<PrestadorUpdateWithoutUsuarioInput, PrestadorUncheckedUpdateWithoutUsuarioInput>
  }

  export type PrestadorUpdateWithoutUsuarioInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    servicio?: ServicioUpdateManyWithoutPrestadorNestedInput
  }

  export type PrestadorUncheckedUpdateWithoutUsuarioInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nit?: StringFieldUpdateOperationsInput | string
    razon_social?: StringFieldUpdateOperationsInput | string
    servicio?: ServicioUncheckedUpdateManyWithoutPrestadorNestedInput
  }

  export type MunicipioCreateWithoutEmpresaInput = {
    nombre: string
    departamento: DepartamentoCreateNestedOneWithoutMunicipioInput
    paciente?: PacienteCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateWithoutEmpresaInput = {
    id_municipio?: number
    nombre: string
    departamentoId: number
    paciente?: PacienteUncheckedCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioCreateOrConnectWithoutEmpresaInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
  }

  export type ContratoCreateWithoutEmpresaInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado?: $Enums.Estado
    acuerdo?: AcuerdoCreateNestedManyWithoutContratoInput
  }

  export type ContratoUncheckedCreateWithoutEmpresaInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado?: $Enums.Estado
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutContratoInput
  }

  export type ContratoCreateOrConnectWithoutEmpresaInput = {
    where: ContratoWhereUniqueInput
    create: XOR<ContratoCreateWithoutEmpresaInput, ContratoUncheckedCreateWithoutEmpresaInput>
  }

  export type ContratoCreateManyEmpresaInputEnvelope = {
    data: ContratoCreateManyEmpresaInput | ContratoCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioUpsertWithoutEmpresaInput = {
    update: XOR<MunicipioUpdateWithoutEmpresaInput, MunicipioUncheckedUpdateWithoutEmpresaInput>
    create: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    where?: MunicipioWhereInput
  }

  export type MunicipioUpdateToOneWithWhereWithoutEmpresaInput = {
    where?: MunicipioWhereInput
    data: XOR<MunicipioUpdateWithoutEmpresaInput, MunicipioUncheckedUpdateWithoutEmpresaInput>
  }

  export type MunicipioUpdateWithoutEmpresaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
    paciente?: PacienteUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutEmpresaInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamentoId?: IntFieldUpdateOperationsInput | number
    paciente?: PacienteUncheckedUpdateManyWithoutMunicipioNestedInput
  }

  export type ContratoUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: ContratoWhereUniqueInput
    update: XOR<ContratoUpdateWithoutEmpresaInput, ContratoUncheckedUpdateWithoutEmpresaInput>
    create: XOR<ContratoCreateWithoutEmpresaInput, ContratoUncheckedCreateWithoutEmpresaInput>
  }

  export type ContratoUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: ContratoWhereUniqueInput
    data: XOR<ContratoUpdateWithoutEmpresaInput, ContratoUncheckedUpdateWithoutEmpresaInput>
  }

  export type ContratoUpdateManyWithWhereWithoutEmpresaInput = {
    where: ContratoScalarWhereInput
    data: XOR<ContratoUpdateManyMutationInput, ContratoUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type ContratoScalarWhereInput = {
    AND?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
    OR?: ContratoScalarWhereInput[]
    NOT?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
    id_contrato?: IntFilter<"Contrato"> | number
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresaId?: IntFilter<"Contrato"> | number
  }

  export type EmpresaCreateWithoutContratoInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado?: $Enums.Estado
    municipio: MunicipioCreateNestedOneWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutContratoInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado?: $Enums.Estado
    municipioId: number
  }

  export type EmpresaCreateOrConnectWithoutContratoInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
  }

  export type AcuerdoCreateWithoutContratoInput = {
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutAcuerdoInput
    servicio: ServicioCreateNestedOneWithoutAcuerdoInput
  }

  export type AcuerdoUncheckedCreateWithoutContratoInput = {
    id_acuerdo?: number
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    servicioId: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutAcuerdoInput
  }

  export type AcuerdoCreateOrConnectWithoutContratoInput = {
    where: AcuerdoWhereUniqueInput
    create: XOR<AcuerdoCreateWithoutContratoInput, AcuerdoUncheckedCreateWithoutContratoInput>
  }

  export type AcuerdoCreateManyContratoInputEnvelope = {
    data: AcuerdoCreateManyContratoInput | AcuerdoCreateManyContratoInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaUpsertWithoutContratoInput = {
    update: XOR<EmpresaUpdateWithoutContratoInput, EmpresaUncheckedUpdateWithoutContratoInput>
    create: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutContratoInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutContratoInput, EmpresaUncheckedUpdateWithoutContratoInput>
  }

  export type EmpresaUpdateWithoutContratoInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: MunicipioUpdateOneRequiredWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutContratoInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipioId?: IntFieldUpdateOperationsInput | number
  }

  export type AcuerdoUpsertWithWhereUniqueWithoutContratoInput = {
    where: AcuerdoWhereUniqueInput
    update: XOR<AcuerdoUpdateWithoutContratoInput, AcuerdoUncheckedUpdateWithoutContratoInput>
    create: XOR<AcuerdoCreateWithoutContratoInput, AcuerdoUncheckedCreateWithoutContratoInput>
  }

  export type AcuerdoUpdateWithWhereUniqueWithoutContratoInput = {
    where: AcuerdoWhereUniqueInput
    data: XOR<AcuerdoUpdateWithoutContratoInput, AcuerdoUncheckedUpdateWithoutContratoInput>
  }

  export type AcuerdoUpdateManyWithWhereWithoutContratoInput = {
    where: AcuerdoScalarWhereInput
    data: XOR<AcuerdoUpdateManyMutationInput, AcuerdoUncheckedUpdateManyWithoutContratoInput>
  }

  export type ProcedimientoCreateWithoutAcuerdoInput = {
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    estudio?: EstudioCreateNestedManyWithoutProcedimientoInput
    tipo_procedimiento: Tipo_ProcedimientoCreateNestedOneWithoutProcedimientoInput
    paciente: PacienteCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutAcuerdoInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    tipo_procedimientoId: number
    pacienteId: number
    estudio?: EstudioUncheckedCreateNestedManyWithoutProcedimientoInput
  }

  export type ProcedimientoCreateOrConnectWithoutAcuerdoInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutAcuerdoInput, ProcedimientoUncheckedCreateWithoutAcuerdoInput>
  }

  export type ProcedimientoCreateManyAcuerdoInputEnvelope = {
    data: ProcedimientoCreateManyAcuerdoInput | ProcedimientoCreateManyAcuerdoInput[]
    skipDuplicates?: boolean
  }

  export type ContratoCreateWithoutAcuerdoInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado?: $Enums.Estado
    empresa: EmpresaCreateNestedOneWithoutContratoInput
  }

  export type ContratoUncheckedCreateWithoutAcuerdoInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado?: $Enums.Estado
    empresaId: number
  }

  export type ContratoCreateOrConnectWithoutAcuerdoInput = {
    where: ContratoWhereUniqueInput
    create: XOR<ContratoCreateWithoutAcuerdoInput, ContratoUncheckedCreateWithoutAcuerdoInput>
  }

  export type ServicioCreateWithoutAcuerdoInput = {
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    paquete?: PaqueteCreateNestedManyWithoutServicioInput
    tipo_servicio: Tipo_ServicioCreateNestedOneWithoutServicioInput
    prestador: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutAcuerdoInput = {
    id_servicio?: number
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_servicioId: number
    prestadorId: number
    paquete?: PaqueteUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutAcuerdoInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutAcuerdoInput, ServicioUncheckedCreateWithoutAcuerdoInput>
  }

  export type ProcedimientoUpsertWithWhereUniqueWithoutAcuerdoInput = {
    where: ProcedimientoWhereUniqueInput
    update: XOR<ProcedimientoUpdateWithoutAcuerdoInput, ProcedimientoUncheckedUpdateWithoutAcuerdoInput>
    create: XOR<ProcedimientoCreateWithoutAcuerdoInput, ProcedimientoUncheckedCreateWithoutAcuerdoInput>
  }

  export type ProcedimientoUpdateWithWhereUniqueWithoutAcuerdoInput = {
    where: ProcedimientoWhereUniqueInput
    data: XOR<ProcedimientoUpdateWithoutAcuerdoInput, ProcedimientoUncheckedUpdateWithoutAcuerdoInput>
  }

  export type ProcedimientoUpdateManyWithWhereWithoutAcuerdoInput = {
    where: ProcedimientoScalarWhereInput
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyWithoutAcuerdoInput>
  }

  export type ContratoUpsertWithoutAcuerdoInput = {
    update: XOR<ContratoUpdateWithoutAcuerdoInput, ContratoUncheckedUpdateWithoutAcuerdoInput>
    create: XOR<ContratoCreateWithoutAcuerdoInput, ContratoUncheckedCreateWithoutAcuerdoInput>
    where?: ContratoWhereInput
  }

  export type ContratoUpdateToOneWithWhereWithoutAcuerdoInput = {
    where?: ContratoWhereInput
    data: XOR<ContratoUpdateWithoutAcuerdoInput, ContratoUncheckedUpdateWithoutAcuerdoInput>
  }

  export type ContratoUpdateWithoutAcuerdoInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: EmpresaUpdateOneRequiredWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateWithoutAcuerdoInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresaId?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioUpsertWithoutAcuerdoInput = {
    update: XOR<ServicioUpdateWithoutAcuerdoInput, ServicioUncheckedUpdateWithoutAcuerdoInput>
    create: XOR<ServicioCreateWithoutAcuerdoInput, ServicioUncheckedCreateWithoutAcuerdoInput>
    where?: ServicioWhereInput
  }

  export type ServicioUpdateToOneWithWhereWithoutAcuerdoInput = {
    where?: ServicioWhereInput
    data: XOR<ServicioUpdateWithoutAcuerdoInput, ServicioUncheckedUpdateWithoutAcuerdoInput>
  }

  export type ServicioUpdateWithoutAcuerdoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    paquete?: PaqueteUpdateManyWithoutServicioNestedInput
    tipo_servicio?: Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput
    prestador?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutAcuerdoInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_servicioId?: IntFieldUpdateOperationsInput | number
    prestadorId?: IntFieldUpdateOperationsInput | number
    paquete?: PaqueteUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type EstudioCreateWithoutPaqueteInput = {
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    procedimiento: ProcedimientoCreateNestedOneWithoutEstudioInput
  }

  export type EstudioUncheckedCreateWithoutPaqueteInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    procedimientoId: number
  }

  export type EstudioCreateOrConnectWithoutPaqueteInput = {
    where: EstudioWhereUniqueInput
    create: XOR<EstudioCreateWithoutPaqueteInput, EstudioUncheckedCreateWithoutPaqueteInput>
  }

  export type EstudioCreateManyPaqueteInputEnvelope = {
    data: EstudioCreateManyPaqueteInput | EstudioCreateManyPaqueteInput[]
    skipDuplicates?: boolean
  }

  export type ExamenCreateWithoutPaqueteInput = {
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_examen: Tipo_ExamenCreateNestedOneWithoutExamenInput
    tipo_resultado?: Tipo_ResultadoCreateNestedManyWithoutExamenInput
  }

  export type ExamenUncheckedCreateWithoutPaqueteInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_examenId: number
    tipo_resultado?: Tipo_ResultadoUncheckedCreateNestedManyWithoutExamenInput
  }

  export type ExamenCreateOrConnectWithoutPaqueteInput = {
    where: ExamenWhereUniqueInput
    create: XOR<ExamenCreateWithoutPaqueteInput, ExamenUncheckedCreateWithoutPaqueteInput>
  }

  export type ServicioCreateWithoutPaqueteInput = {
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    acuerdo?: AcuerdoCreateNestedManyWithoutServicioInput
    tipo_servicio: Tipo_ServicioCreateNestedOneWithoutServicioInput
    prestador: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutPaqueteInput = {
    id_servicio?: number
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_servicioId: number
    prestadorId: number
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutPaqueteInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutPaqueteInput, ServicioUncheckedCreateWithoutPaqueteInput>
  }

  export type EstudioUpsertWithWhereUniqueWithoutPaqueteInput = {
    where: EstudioWhereUniqueInput
    update: XOR<EstudioUpdateWithoutPaqueteInput, EstudioUncheckedUpdateWithoutPaqueteInput>
    create: XOR<EstudioCreateWithoutPaqueteInput, EstudioUncheckedCreateWithoutPaqueteInput>
  }

  export type EstudioUpdateWithWhereUniqueWithoutPaqueteInput = {
    where: EstudioWhereUniqueInput
    data: XOR<EstudioUpdateWithoutPaqueteInput, EstudioUncheckedUpdateWithoutPaqueteInput>
  }

  export type EstudioUpdateManyWithWhereWithoutPaqueteInput = {
    where: EstudioScalarWhereInput
    data: XOR<EstudioUpdateManyMutationInput, EstudioUncheckedUpdateManyWithoutPaqueteInput>
  }

  export type ExamenUpsertWithoutPaqueteInput = {
    update: XOR<ExamenUpdateWithoutPaqueteInput, ExamenUncheckedUpdateWithoutPaqueteInput>
    create: XOR<ExamenCreateWithoutPaqueteInput, ExamenUncheckedCreateWithoutPaqueteInput>
    where?: ExamenWhereInput
  }

  export type ExamenUpdateToOneWithWhereWithoutPaqueteInput = {
    where?: ExamenWhereInput
    data: XOR<ExamenUpdateWithoutPaqueteInput, ExamenUncheckedUpdateWithoutPaqueteInput>
  }

  export type ExamenUpdateWithoutPaqueteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examen?: Tipo_ExamenUpdateOneRequiredWithoutExamenNestedInput
    tipo_resultado?: Tipo_ResultadoUpdateManyWithoutExamenNestedInput
  }

  export type ExamenUncheckedUpdateWithoutPaqueteInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_examenId?: IntFieldUpdateOperationsInput | number
    tipo_resultado?: Tipo_ResultadoUncheckedUpdateManyWithoutExamenNestedInput
  }

  export type ServicioUpsertWithoutPaqueteInput = {
    update: XOR<ServicioUpdateWithoutPaqueteInput, ServicioUncheckedUpdateWithoutPaqueteInput>
    create: XOR<ServicioCreateWithoutPaqueteInput, ServicioUncheckedCreateWithoutPaqueteInput>
    where?: ServicioWhereInput
  }

  export type ServicioUpdateToOneWithWhereWithoutPaqueteInput = {
    where?: ServicioWhereInput
    data: XOR<ServicioUpdateWithoutPaqueteInput, ServicioUncheckedUpdateWithoutPaqueteInput>
  }

  export type ServicioUpdateWithoutPaqueteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    acuerdo?: AcuerdoUpdateManyWithoutServicioNestedInput
    tipo_servicio?: Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput
    prestador?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutPaqueteInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_servicioId?: IntFieldUpdateOperationsInput | number
    prestadorId?: IntFieldUpdateOperationsInput | number
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ProcedimientoCreateManyPacienteInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    acuerdoId: number
    tipo_procedimientoId: number
  }

  export type ProcedimientoUpdateWithoutPacienteInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutProcedimientoNestedInput
    acuerdo?: AcuerdoUpdateOneRequiredWithoutProcedimientoNestedInput
    tipo_procedimiento?: Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutPacienteInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acuerdoId?: IntFieldUpdateOperationsInput | number
    tipo_procedimientoId?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateManyWithoutPacienteInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acuerdoId?: IntFieldUpdateOperationsInput | number
    tipo_procedimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type PacienteCreateManyEpsInput = {
    id_paciente?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    municipioId: number
  }

  export type PacienteUpdateWithoutEpsInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    procedimiento?: ProcedimientoUpdateManyWithoutPacienteNestedInput
    municipio?: MunicipioUpdateOneRequiredWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutEpsInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipioId?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateManyWithoutEpsInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipioId?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoCreateManyTipo_procedimientoInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    acuerdoId: number
    pacienteId: number
  }

  export type ProcedimientoUpdateWithoutTipo_procedimientoInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutProcedimientoNestedInput
    acuerdo?: AcuerdoUpdateOneRequiredWithoutProcedimientoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutTipo_procedimientoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acuerdoId?: IntFieldUpdateOperationsInput | number
    pacienteId?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateManyWithoutTipo_procedimientoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acuerdoId?: IntFieldUpdateOperationsInput | number
    pacienteId?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateManyProcedimientoInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    paqueteId: number
  }

  export type EstudioUpdateWithoutProcedimientoInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    paquete?: PaqueteUpdateOneRequiredWithoutEstudioNestedInput
  }

  export type EstudioUncheckedUpdateWithoutProcedimientoInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    paqueteId?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioUncheckedUpdateManyWithoutProcedimientoInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    paqueteId?: IntFieldUpdateOperationsInput | number
  }

  export type MunicipioCreateManyDepartamentoInput = {
    id_municipio?: number
    nombre: string
  }

  export type MunicipioUpdateWithoutDepartamentoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    paciente?: PacienteUpdateManyWithoutMunicipioNestedInput
    empresa?: EmpresaUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutDepartamentoInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    paciente?: PacienteUncheckedUpdateManyWithoutMunicipioNestedInput
    empresa?: EmpresaUncheckedUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateManyWithoutDepartamentoInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type PacienteCreateManyMunicipioInput = {
    id_paciente?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    direccion?: string | null
    tipo_paciente: $Enums.Tipo_Paciente
    estado?: $Enums.Estado
    epsId: number
  }

  export type EmpresaCreateManyMunicipioInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado?: $Enums.Estado
  }

  export type PacienteUpdateWithoutMunicipioInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    procedimiento?: ProcedimientoUpdateManyWithoutPacienteNestedInput
    eps?: EpsUpdateOneRequiredWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutMunicipioInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    epsId?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateManyWithoutMunicipioInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_paciente?: EnumTipo_PacienteFieldUpdateOperationsInput | $Enums.Tipo_Paciente
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    epsId?: IntFieldUpdateOperationsInput | number
  }

  export type EmpresaUpdateWithoutMunicipioInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: ContratoUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutMunicipioInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: ContratoUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateManyWithoutMunicipioInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ServicioCreateManyTipo_servicioInput = {
    id_servicio?: number
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    prestadorId: number
  }

  export type ServicioUpdateWithoutTipo_servicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    paquete?: PaqueteUpdateManyWithoutServicioNestedInput
    acuerdo?: AcuerdoUpdateManyWithoutServicioNestedInput
    prestador?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutTipo_servicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    prestadorId?: IntFieldUpdateOperationsInput | number
    paquete?: PaqueteUncheckedUpdateManyWithoutServicioNestedInput
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateManyWithoutTipo_servicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    prestadorId?: IntFieldUpdateOperationsInput | number
  }

  export type PaqueteCreateManyServicioInput = {
    id_paquete?: number
    estado?: $Enums.Estado
    examenId: number
  }

  export type AcuerdoCreateManyServicioInput = {
    id_acuerdo?: number
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    contratoId: number
  }

  export type PaqueteUpdateWithoutServicioInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    estudio?: EstudioUpdateManyWithoutPaqueteNestedInput
    examen?: ExamenUpdateOneRequiredWithoutPaqueteNestedInput
  }

  export type PaqueteUncheckedUpdateWithoutServicioInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examenId?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutPaqueteNestedInput
  }

  export type PaqueteUncheckedUpdateManyWithoutServicioInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    examenId?: IntFieldUpdateOperationsInput | number
  }

  export type AcuerdoUpdateWithoutServicioInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutAcuerdoNestedInput
    contrato?: ContratoUpdateOneRequiredWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateWithoutServicioInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contratoId?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateManyWithoutServicioInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contratoId?: IntFieldUpdateOperationsInput | number
  }

  export type Tipo_ResultadoCreateManyExamenInput = {
    id_tipo_resultado?: number
    nombre: string
    estado?: $Enums.Estado
  }

  export type PaqueteCreateManyExamenInput = {
    id_paquete?: number
    estado?: $Enums.Estado
    servicioId: number
  }

  export type Tipo_ResultadoUpdateWithoutExamenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ResultadoUncheckedUpdateWithoutExamenInput = {
    id_tipo_resultado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type Tipo_ResultadoUncheckedUpdateManyWithoutExamenInput = {
    id_tipo_resultado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PaqueteUpdateWithoutExamenInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    estudio?: EstudioUpdateManyWithoutPaqueteNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutPaqueteNestedInput
  }

  export type PaqueteUncheckedUpdateWithoutExamenInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicioId?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutPaqueteNestedInput
  }

  export type PaqueteUncheckedUpdateManyWithoutExamenInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicioId?: IntFieldUpdateOperationsInput | number
  }

  export type ExamenCreateManyTipo_examenInput = {
    id_examen?: number
    nombre: string
    unidades: string
    rango_biologico: string
    metodo: string
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
  }

  export type ExamenUpdateWithoutTipo_examenInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_resultado?: Tipo_ResultadoUpdateManyWithoutExamenNestedInput
    paquete?: PaqueteUpdateManyWithoutExamenNestedInput
  }

  export type ExamenUncheckedUpdateWithoutTipo_examenInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_resultado?: Tipo_ResultadoUncheckedUpdateManyWithoutExamenNestedInput
    paquete?: PaqueteUncheckedUpdateManyWithoutExamenNestedInput
  }

  export type ExamenUncheckedUpdateManyWithoutTipo_examenInput = {
    id_examen?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidades?: StringFieldUpdateOperationsInput | string
    rango_biologico?: StringFieldUpdateOperationsInput | string
    metodo?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ServicioCreateManyPrestadorInput = {
    id_servicio?: number
    nombre: string
    nivel: number
    precio: Decimal | DecimalJsLike | number | string
    estado?: $Enums.Estado
    tipo_servicioId: number
  }

  export type UsuarioCreateManyPrestadorInput = {
    id_usuario?: number
    identificacion: string
    nombre: string
    cargo: string
    rol: $Enums.Rol
    email: string
    password: string
    estado?: $Enums.Estado
  }

  export type ServicioUpdateWithoutPrestadorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    paquete?: PaqueteUpdateManyWithoutServicioNestedInput
    acuerdo?: AcuerdoUpdateManyWithoutServicioNestedInput
    tipo_servicio?: Tipo_ServicioUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutPrestadorInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_servicioId?: IntFieldUpdateOperationsInput | number
    paquete?: PaqueteUncheckedUpdateManyWithoutServicioNestedInput
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateManyWithoutPrestadorInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    tipo_servicioId?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpdateWithoutPrestadorInput = {
    identificacion?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type UsuarioUncheckedUpdateWithoutPrestadorInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    identificacion?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type UsuarioUncheckedUpdateManyWithoutPrestadorInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    identificacion?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ContratoCreateManyEmpresaInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado?: $Enums.Estado
  }

  export type ContratoUpdateWithoutEmpresaInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    acuerdo?: AcuerdoUpdateManyWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateWithoutEmpresaInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateManyWithoutEmpresaInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type AcuerdoCreateManyContratoInput = {
    id_acuerdo?: number
    estado?: $Enums.Estado
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    servicioId: number
  }

  export type AcuerdoUpdateWithoutContratoInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutAcuerdoNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateWithoutContratoInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicioId?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateManyWithoutContratoInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicioId?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoCreateManyAcuerdoInput = {
    id_procedimiento?: number
    factura: number
    fecha: Date | string
    edad_persona: string
    estado?: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    tipo_procedimientoId: number
    pacienteId: number
  }

  export type ProcedimientoUpdateWithoutAcuerdoInput = {
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudio?: EstudioUpdateManyWithoutProcedimientoNestedInput
    tipo_procedimiento?: Tipo_ProcedimientoUpdateOneRequiredWithoutProcedimientoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutAcuerdoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_procedimientoId?: IntFieldUpdateOperationsInput | number
    pacienteId?: IntFieldUpdateOperationsInput | number
    estudio?: EstudioUncheckedUpdateManyWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateManyWithoutAcuerdoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    factura?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    edad_persona?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_procedimientoId?: IntFieldUpdateOperationsInput | number
    pacienteId?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioCreateManyPaqueteInput = {
    id_estudio?: number
    consecutivo: number
    cantidad: number
    fecha_muestra: Date | string
    fecha_resultado: Date | string
    resultado: string
    observacion: string
    profesional: number
    procedimientoId: number
  }

  export type EstudioUpdateWithoutPaqueteInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUpdateOneRequiredWithoutEstudioNestedInput
  }

  export type EstudioUncheckedUpdateWithoutPaqueteInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    procedimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type EstudioUncheckedUpdateManyWithoutPaqueteInput = {
    id_estudio?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    fecha_muestra?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resultado?: DateTimeFieldUpdateOperationsInput | Date | string
    resultado?: StringFieldUpdateOperationsInput | string
    observacion?: StringFieldUpdateOperationsInput | string
    profesional?: IntFieldUpdateOperationsInput | number
    procedimientoId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PacienteCountOutputTypeDefaultArgs instead
     */
    export type PacienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PacienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EpsCountOutputTypeDefaultArgs instead
     */
    export type EpsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EpsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ProcedimientoCountOutputTypeDefaultArgs instead
     */
    export type Tipo_ProcedimientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedimientoCountOutputTypeDefaultArgs instead
     */
    export type ProcedimientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedimientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartamentoCountOutputTypeDefaultArgs instead
     */
    export type DepartamentoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioCountOutputTypeDefaultArgs instead
     */
    export type MunicipioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ServicioCountOutputTypeDefaultArgs instead
     */
    export type Tipo_ServicioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ServicioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicioCountOutputTypeDefaultArgs instead
     */
    export type ServicioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamenCountOutputTypeDefaultArgs instead
     */
    export type ExamenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ExamenCountOutputTypeDefaultArgs instead
     */
    export type Tipo_ExamenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ExamenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrestadorCountOutputTypeDefaultArgs instead
     */
    export type PrestadorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrestadorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaCountOutputTypeDefaultArgs instead
     */
    export type EmpresaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContratoCountOutputTypeDefaultArgs instead
     */
    export type ContratoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContratoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcuerdoCountOutputTypeDefaultArgs instead
     */
    export type AcuerdoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcuerdoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaqueteCountOutputTypeDefaultArgs instead
     */
    export type PaqueteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaqueteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PacienteDefaultArgs instead
     */
    export type PacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PacienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EpsDefaultArgs instead
     */
    export type EpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EpsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ProcedimientoDefaultArgs instead
     */
    export type Tipo_ProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ProcedimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedimientoDefaultArgs instead
     */
    export type ProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstudioDefaultArgs instead
     */
    export type EstudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstudioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartamentoDefaultArgs instead
     */
    export type DepartamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioDefaultArgs instead
     */
    export type MunicipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ServicioDefaultArgs instead
     */
    export type Tipo_ServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ServicioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicioDefaultArgs instead
     */
    export type ServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamenDefaultArgs instead
     */
    export type ExamenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ResultadoDefaultArgs instead
     */
    export type Tipo_ResultadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ResultadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tipo_ExamenDefaultArgs instead
     */
    export type Tipo_ExamenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tipo_ExamenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrestadorDefaultArgs instead
     */
    export type PrestadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrestadorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaDefaultArgs instead
     */
    export type EmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContratoDefaultArgs instead
     */
    export type ContratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContratoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcuerdoDefaultArgs instead
     */
    export type AcuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcuerdoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaqueteDefaultArgs instead
     */
    export type PaqueteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaqueteDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}