
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Eps
 * 
 */
export type Eps = $Result.DefaultSelection<Prisma.$EpsPayload>
/**
 * Model Procedimiento
 * 
 */
export type Procedimiento = $Result.DefaultSelection<Prisma.$ProcedimientoPayload>
/**
 * Model Departamento
 * 
 */
export type Departamento = $Result.DefaultSelection<Prisma.$DepartamentoPayload>
/**
 * Model Municipio
 * 
 */
export type Municipio = $Result.DefaultSelection<Prisma.$MunicipioPayload>
/**
 * Model Servicio
 * 
 */
export type Servicio = $Result.DefaultSelection<Prisma.$ServicioPayload>
/**
 * Model Prestador
 * 
 */
export type Prestador = $Result.DefaultSelection<Prisma.$PrestadorPayload>
/**
 * Model Empleado
 * 
 */
export type Empleado = $Result.DefaultSelection<Prisma.$EmpleadoPayload>
/**
 * Model Tarifa
 * 
 */
export type Tarifa = $Result.DefaultSelection<Prisma.$TarifaPayload>
/**
 * Model Protocolo
 * 
 */
export type Protocolo = $Result.DefaultSelection<Prisma.$ProtocoloPayload>
/**
 * Model Empresa
 * 
 */
export type Empresa = $Result.DefaultSelection<Prisma.$EmpresaPayload>
/**
 * Model Contrato
 * 
 */
export type Contrato = $Result.DefaultSelection<Prisma.$ContratoPayload>
/**
 * Model Acuerdo
 * 
 */
export type Acuerdo = $Result.DefaultSelection<Prisma.$AcuerdoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Tipo_Ident: {
  AS: 'AS',
  CC: 'CC',
  CE: 'CE',
  MV: 'MV',
  RC: 'RC',
  TI: 'TI'
};

export type Tipo_Ident = (typeof Tipo_Ident)[keyof typeof Tipo_Ident]


export const Sex: {
  Femenino: 'Femenino',
  Masculino: 'Masculino',
  Indetermidado: 'Indetermidado'
};

export type Sex = (typeof Sex)[keyof typeof Sex]


export const Tipo_Usuario: {
  Contributivo: 'Contributivo',
  Subsidiado: 'Subsidiado',
  Vinculado: 'Vinculado',
  Particular: 'Particular',
  Otro: 'Otro'
};

export type Tipo_Usuario = (typeof Tipo_Usuario)[keyof typeof Tipo_Usuario]


export const Estado: {
  Activo: 'Activo',
  Inactivo: 'Inactivo'
};

export type Estado = (typeof Estado)[keyof typeof Estado]


export const Rol: {
  Administrador: 'Administrador',
  Facturacion: 'Facturacion',
  Bacteriologo: 'Bacteriologo'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const Tipo_Empresa: {
  Particular: 'Particular',
  Empresa: 'Empresa',
  Eps: 'Eps',
  Esess: 'Esess'
};

export type Tipo_Empresa = (typeof Tipo_Empresa)[keyof typeof Tipo_Empresa]

}

export type Tipo_Ident = $Enums.Tipo_Ident

export const Tipo_Ident: typeof $Enums.Tipo_Ident

export type Sex = $Enums.Sex

export const Sex: typeof $Enums.Sex

export type Tipo_Usuario = $Enums.Tipo_Usuario

export const Tipo_Usuario: typeof $Enums.Tipo_Usuario

export type Estado = $Enums.Estado

export const Estado: typeof $Enums.Estado

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type Tipo_Empresa = $Enums.Tipo_Empresa

export const Tipo_Empresa: typeof $Enums.Tipo_Empresa

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.eps`: Exposes CRUD operations for the **Eps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eps
    * const eps = await prisma.eps.findMany()
    * ```
    */
  get eps(): Prisma.EpsDelegate<ExtArgs>;

  /**
   * `prisma.procedimiento`: Exposes CRUD operations for the **Procedimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedimientos
    * const procedimientos = await prisma.procedimiento.findMany()
    * ```
    */
  get procedimiento(): Prisma.ProcedimientoDelegate<ExtArgs>;

  /**
   * `prisma.departamento`: Exposes CRUD operations for the **Departamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departamentos
    * const departamentos = await prisma.departamento.findMany()
    * ```
    */
  get departamento(): Prisma.DepartamentoDelegate<ExtArgs>;

  /**
   * `prisma.municipio`: Exposes CRUD operations for the **Municipio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipios
    * const municipios = await prisma.municipio.findMany()
    * ```
    */
  get municipio(): Prisma.MunicipioDelegate<ExtArgs>;

  /**
   * `prisma.servicio`: Exposes CRUD operations for the **Servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicio.findMany()
    * ```
    */
  get servicio(): Prisma.ServicioDelegate<ExtArgs>;

  /**
   * `prisma.prestador`: Exposes CRUD operations for the **Prestador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prestadors
    * const prestadors = await prisma.prestador.findMany()
    * ```
    */
  get prestador(): Prisma.PrestadorDelegate<ExtArgs>;

  /**
   * `prisma.empleado`: Exposes CRUD operations for the **Empleado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleados
    * const empleados = await prisma.empleado.findMany()
    * ```
    */
  get empleado(): Prisma.EmpleadoDelegate<ExtArgs>;

  /**
   * `prisma.tarifa`: Exposes CRUD operations for the **Tarifa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tarifas
    * const tarifas = await prisma.tarifa.findMany()
    * ```
    */
  get tarifa(): Prisma.TarifaDelegate<ExtArgs>;

  /**
   * `prisma.protocolo`: Exposes CRUD operations for the **Protocolo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Protocolos
    * const protocolos = await prisma.protocolo.findMany()
    * ```
    */
  get protocolo(): Prisma.ProtocoloDelegate<ExtArgs>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **Empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.EmpresaDelegate<ExtArgs>;

  /**
   * `prisma.contrato`: Exposes CRUD operations for the **Contrato** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contratoes
    * const contratoes = await prisma.contrato.findMany()
    * ```
    */
  get contrato(): Prisma.ContratoDelegate<ExtArgs>;

  /**
   * `prisma.acuerdo`: Exposes CRUD operations for the **Acuerdo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Acuerdos
    * const acuerdos = await prisma.acuerdo.findMany()
    * ```
    */
  get acuerdo(): Prisma.AcuerdoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Eps: 'Eps',
    Procedimiento: 'Procedimiento',
    Departamento: 'Departamento',
    Municipio: 'Municipio',
    Servicio: 'Servicio',
    Prestador: 'Prestador',
    Empleado: 'Empleado',
    Tarifa: 'Tarifa',
    Protocolo: 'Protocolo',
    Empresa: 'Empresa',
    Contrato: 'Contrato',
    Acuerdo: 'Acuerdo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "eps" | "procedimiento" | "departamento" | "municipio" | "servicio" | "prestador" | "empleado" | "tarifa" | "protocolo" | "empresa" | "contrato" | "acuerdo"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Eps: {
        payload: Prisma.$EpsPayload<ExtArgs>
        fields: Prisma.EpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EpsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EpsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          findFirst: {
            args: Prisma.EpsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EpsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          findMany: {
            args: Prisma.EpsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>[]
          }
          create: {
            args: Prisma.EpsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          createMany: {
            args: Prisma.EpsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EpsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          update: {
            args: Prisma.EpsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          deleteMany: {
            args: Prisma.EpsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EpsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EpsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpsPayload>
          }
          aggregate: {
            args: Prisma.EpsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEps>
          }
          groupBy: {
            args: Prisma.EpsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EpsCountArgs<ExtArgs>
            result: $Utils.Optional<EpsCountAggregateOutputType> | number
          }
        }
      }
      Procedimiento: {
        payload: Prisma.$ProcedimientoPayload<ExtArgs>
        fields: Prisma.ProcedimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          findFirst: {
            args: Prisma.ProcedimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          findMany: {
            args: Prisma.ProcedimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>[]
          }
          create: {
            args: Prisma.ProcedimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          createMany: {
            args: Prisma.ProcedimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcedimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          update: {
            args: Prisma.ProcedimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          deleteMany: {
            args: Prisma.ProcedimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcedimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedimientoPayload>
          }
          aggregate: {
            args: Prisma.ProcedimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedimiento>
          }
          groupBy: {
            args: Prisma.ProcedimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedimientoCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedimientoCountAggregateOutputType> | number
          }
        }
      }
      Departamento: {
        payload: Prisma.$DepartamentoPayload<ExtArgs>
        fields: Prisma.DepartamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          findFirst: {
            args: Prisma.DepartamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          findMany: {
            args: Prisma.DepartamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>[]
          }
          create: {
            args: Prisma.DepartamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          createMany: {
            args: Prisma.DepartamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          update: {
            args: Prisma.DepartamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          deleteMany: {
            args: Prisma.DepartamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          aggregate: {
            args: Prisma.DepartamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartamento>
          }
          groupBy: {
            args: Prisma.DepartamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartamentoCountArgs<ExtArgs>
            result: $Utils.Optional<DepartamentoCountAggregateOutputType> | number
          }
        }
      }
      Municipio: {
        payload: Prisma.$MunicipioPayload<ExtArgs>
        fields: Prisma.MunicipioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          findFirst: {
            args: Prisma.MunicipioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          findMany: {
            args: Prisma.MunicipioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>[]
          }
          create: {
            args: Prisma.MunicipioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          createMany: {
            args: Prisma.MunicipioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MunicipioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          update: {
            args: Prisma.MunicipioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          deleteMany: {
            args: Prisma.MunicipioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MunicipioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          aggregate: {
            args: Prisma.MunicipioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipio>
          }
          groupBy: {
            args: Prisma.MunicipioGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipioGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipioCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipioCountAggregateOutputType> | number
          }
        }
      }
      Servicio: {
        payload: Prisma.$ServicioPayload<ExtArgs>
        fields: Prisma.ServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          findFirst: {
            args: Prisma.ServicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          findMany: {
            args: Prisma.ServicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>[]
          }
          create: {
            args: Prisma.ServicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          createMany: {
            args: Prisma.ServicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          update: {
            args: Prisma.ServicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          deleteMany: {
            args: Prisma.ServicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          aggregate: {
            args: Prisma.ServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicio>
          }
          groupBy: {
            args: Prisma.ServicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicioCountArgs<ExtArgs>
            result: $Utils.Optional<ServicioCountAggregateOutputType> | number
          }
        }
      }
      Prestador: {
        payload: Prisma.$PrestadorPayload<ExtArgs>
        fields: Prisma.PrestadorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrestadorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrestadorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          findFirst: {
            args: Prisma.PrestadorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrestadorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          findMany: {
            args: Prisma.PrestadorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>[]
          }
          create: {
            args: Prisma.PrestadorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          createMany: {
            args: Prisma.PrestadorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrestadorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          update: {
            args: Prisma.PrestadorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          deleteMany: {
            args: Prisma.PrestadorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrestadorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrestadorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorPayload>
          }
          aggregate: {
            args: Prisma.PrestadorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrestador>
          }
          groupBy: {
            args: Prisma.PrestadorGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrestadorGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrestadorCountArgs<ExtArgs>
            result: $Utils.Optional<PrestadorCountAggregateOutputType> | number
          }
        }
      }
      Empleado: {
        payload: Prisma.$EmpleadoPayload<ExtArgs>
        fields: Prisma.EmpleadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpleadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpleadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          findFirst: {
            args: Prisma.EmpleadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpleadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          findMany: {
            args: Prisma.EmpleadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>[]
          }
          create: {
            args: Prisma.EmpleadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          createMany: {
            args: Prisma.EmpleadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmpleadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          update: {
            args: Prisma.EmpleadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          deleteMany: {
            args: Prisma.EmpleadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpleadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpleadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          aggregate: {
            args: Prisma.EmpleadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpleado>
          }
          groupBy: {
            args: Prisma.EmpleadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpleadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpleadoCountArgs<ExtArgs>
            result: $Utils.Optional<EmpleadoCountAggregateOutputType> | number
          }
        }
      }
      Tarifa: {
        payload: Prisma.$TarifaPayload<ExtArgs>
        fields: Prisma.TarifaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TarifaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TarifaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          findFirst: {
            args: Prisma.TarifaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TarifaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          findMany: {
            args: Prisma.TarifaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>[]
          }
          create: {
            args: Prisma.TarifaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          createMany: {
            args: Prisma.TarifaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TarifaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          update: {
            args: Prisma.TarifaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          deleteMany: {
            args: Prisma.TarifaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TarifaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TarifaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TarifaPayload>
          }
          aggregate: {
            args: Prisma.TarifaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTarifa>
          }
          groupBy: {
            args: Prisma.TarifaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TarifaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TarifaCountArgs<ExtArgs>
            result: $Utils.Optional<TarifaCountAggregateOutputType> | number
          }
        }
      }
      Protocolo: {
        payload: Prisma.$ProtocoloPayload<ExtArgs>
        fields: Prisma.ProtocoloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProtocoloFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProtocoloFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload>
          }
          findFirst: {
            args: Prisma.ProtocoloFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProtocoloFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload>
          }
          findMany: {
            args: Prisma.ProtocoloFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload>[]
          }
          create: {
            args: Prisma.ProtocoloCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload>
          }
          createMany: {
            args: Prisma.ProtocoloCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProtocoloDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload>
          }
          update: {
            args: Prisma.ProtocoloUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload>
          }
          deleteMany: {
            args: Prisma.ProtocoloDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProtocoloUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProtocoloUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProtocoloPayload>
          }
          aggregate: {
            args: Prisma.ProtocoloAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProtocolo>
          }
          groupBy: {
            args: Prisma.ProtocoloGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProtocoloGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProtocoloCountArgs<ExtArgs>
            result: $Utils.Optional<ProtocoloCountAggregateOutputType> | number
          }
        }
      }
      Empresa: {
        payload: Prisma.$EmpresaPayload<ExtArgs>
        fields: Prisma.EmpresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findFirst: {
            args: Prisma.EmpresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findMany: {
            args: Prisma.EmpresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          create: {
            args: Prisma.EmpresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          createMany: {
            args: Prisma.EmpresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmpresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          update: {
            args: Prisma.EmpresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.EmpresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      Contrato: {
        payload: Prisma.$ContratoPayload<ExtArgs>
        fields: Prisma.ContratoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContratoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContratoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          findFirst: {
            args: Prisma.ContratoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContratoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          findMany: {
            args: Prisma.ContratoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>[]
          }
          create: {
            args: Prisma.ContratoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          createMany: {
            args: Prisma.ContratoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContratoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          update: {
            args: Prisma.ContratoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          deleteMany: {
            args: Prisma.ContratoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContratoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContratoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratoPayload>
          }
          aggregate: {
            args: Prisma.ContratoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContrato>
          }
          groupBy: {
            args: Prisma.ContratoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContratoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContratoCountArgs<ExtArgs>
            result: $Utils.Optional<ContratoCountAggregateOutputType> | number
          }
        }
      }
      Acuerdo: {
        payload: Prisma.$AcuerdoPayload<ExtArgs>
        fields: Prisma.AcuerdoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcuerdoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcuerdoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          findFirst: {
            args: Prisma.AcuerdoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcuerdoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          findMany: {
            args: Prisma.AcuerdoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>[]
          }
          create: {
            args: Prisma.AcuerdoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          createMany: {
            args: Prisma.AcuerdoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcuerdoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          update: {
            args: Prisma.AcuerdoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          deleteMany: {
            args: Prisma.AcuerdoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcuerdoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcuerdoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcuerdoPayload>
          }
          aggregate: {
            args: Prisma.AcuerdoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcuerdo>
          }
          groupBy: {
            args: Prisma.AcuerdoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcuerdoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcuerdoCountArgs<ExtArgs>
            result: $Utils.Optional<AcuerdoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    procedimiento: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | UsuarioCountOutputTypeCountProcedimientoArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
  }


  /**
   * Count Type EpsCountOutputType
   */

  export type EpsCountOutputType = {
    usuario: number
  }

  export type EpsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | EpsCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes
  /**
   * EpsCountOutputType without action
   */
  export type EpsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EpsCountOutputType
     */
    select?: EpsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EpsCountOutputType without action
   */
  export type EpsCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * Count Type DepartamentoCountOutputType
   */

  export type DepartamentoCountOutputType = {
    municipio: number
  }

  export type DepartamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | DepartamentoCountOutputTypeCountMunicipioArgs
  }

  // Custom InputTypes
  /**
   * DepartamentoCountOutputType without action
   */
  export type DepartamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartamentoCountOutputType
     */
    select?: DepartamentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartamentoCountOutputType without action
   */
  export type DepartamentoCountOutputTypeCountMunicipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipioWhereInput
  }


  /**
   * Count Type MunicipioCountOutputType
   */

  export type MunicipioCountOutputType = {
    suario: number
    empresa: number
  }

  export type MunicipioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suario?: boolean | MunicipioCountOutputTypeCountSuarioArgs
    empresa?: boolean | MunicipioCountOutputTypeCountEmpresaArgs
  }

  // Custom InputTypes
  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipioCountOutputType
     */
    select?: MunicipioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeCountSuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }

  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeCountEmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
  }


  /**
   * Count Type PrestadorCountOutputType
   */

  export type PrestadorCountOutputType = {
    servicio: number
    empleado: number
  }

  export type PrestadorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | PrestadorCountOutputTypeCountServicioArgs
    empleado?: boolean | PrestadorCountOutputTypeCountEmpleadoArgs
  }

  // Custom InputTypes
  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorCountOutputType
     */
    select?: PrestadorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeCountServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
  }

  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeCountEmpleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpleadoWhereInput
  }


  /**
   * Count Type TarifaCountOutputType
   */

  export type TarifaCountOutputType = {
    servicio: number
    acuerdo: number
  }

  export type TarifaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | TarifaCountOutputTypeCountServicioArgs
    acuerdo?: boolean | TarifaCountOutputTypeCountAcuerdoArgs
  }

  // Custom InputTypes
  /**
   * TarifaCountOutputType without action
   */
  export type TarifaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TarifaCountOutputType
     */
    select?: TarifaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TarifaCountOutputType without action
   */
  export type TarifaCountOutputTypeCountServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
  }

  /**
   * TarifaCountOutputType without action
   */
  export type TarifaCountOutputTypeCountAcuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcuerdoWhereInput
  }


  /**
   * Count Type ProtocoloCountOutputType
   */

  export type ProtocoloCountOutputType = {
    servicio: number
  }

  export type ProtocoloCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | ProtocoloCountOutputTypeCountServicioArgs
  }

  // Custom InputTypes
  /**
   * ProtocoloCountOutputType without action
   */
  export type ProtocoloCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProtocoloCountOutputType
     */
    select?: ProtocoloCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProtocoloCountOutputType without action
   */
  export type ProtocoloCountOutputTypeCountServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
  }


  /**
   * Count Type EmpresaCountOutputType
   */

  export type EmpresaCountOutputType = {
    contrato: number
  }

  export type EmpresaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contrato?: boolean | EmpresaCountOutputTypeCountContratoArgs
  }

  // Custom InputTypes
  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaCountOutputType
     */
    select?: EmpresaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountContratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratoWhereInput
  }


  /**
   * Count Type ContratoCountOutputType
   */

  export type ContratoCountOutputType = {
    acuerdo: number
  }

  export type ContratoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acuerdo?: boolean | ContratoCountOutputTypeCountAcuerdoArgs
  }

  // Custom InputTypes
  /**
   * ContratoCountOutputType without action
   */
  export type ContratoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratoCountOutputType
     */
    select?: ContratoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContratoCountOutputType without action
   */
  export type ContratoCountOutputTypeCountAcuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcuerdoWhereInput
  }


  /**
   * Count Type AcuerdoCountOutputType
   */

  export type AcuerdoCountOutputType = {
    procedimiento: number
  }

  export type AcuerdoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | AcuerdoCountOutputTypeCountProcedimientoArgs
  }

  // Custom InputTypes
  /**
   * AcuerdoCountOutputType without action
   */
  export type AcuerdoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcuerdoCountOutputType
     */
    select?: AcuerdoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcuerdoCountOutputType without action
   */
  export type AcuerdoCountOutputTypeCountProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id_usuario: number | null
    municipio: number | null
    eps: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id_usuario: number | null
    municipio: number | null
    eps: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id_usuario: number | null
    tipo_identificacion: $Enums.Tipo_Ident | null
    identificacion: string | null
    primer_nombre: string | null
    segundo_nombre: string | null
    primer_apellido: string | null
    segundo_apellido: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sex | null
    email: string | null
    telefono: string | null
    tipo_usuario: $Enums.Tipo_Usuario | null
    municipio: number | null
    estado: $Enums.Estado | null
    createAt: Date | null
    updateAt: Date | null
    eps: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id_usuario: number | null
    tipo_identificacion: $Enums.Tipo_Ident | null
    identificacion: string | null
    primer_nombre: string | null
    segundo_nombre: string | null
    primer_apellido: string | null
    segundo_apellido: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sex | null
    email: string | null
    telefono: string | null
    tipo_usuario: $Enums.Tipo_Usuario | null
    municipio: number | null
    estado: $Enums.Estado | null
    createAt: Date | null
    updateAt: Date | null
    eps: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id_usuario: number
    tipo_identificacion: number
    identificacion: number
    primer_nombre: number
    segundo_nombre: number
    primer_apellido: number
    segundo_apellido: number
    fecha_nacimiento: number
    sexo: number
    email: number
    telefono: number
    tipo_usuario: number
    municipio: number
    estado: number
    createAt: number
    updateAt: number
    eps: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id_usuario?: true
    municipio?: true
    eps?: true
  }

  export type UsuarioSumAggregateInputType = {
    id_usuario?: true
    municipio?: true
    eps?: true
  }

  export type UsuarioMinAggregateInputType = {
    id_usuario?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    tipo_usuario?: true
    municipio?: true
    estado?: true
    createAt?: true
    updateAt?: true
    eps?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id_usuario?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    tipo_usuario?: true
    municipio?: true
    estado?: true
    createAt?: true
    updateAt?: true
    eps?: true
  }

  export type UsuarioCountAggregateInputType = {
    id_usuario?: true
    tipo_identificacion?: true
    identificacion?: true
    primer_nombre?: true
    segundo_nombre?: true
    primer_apellido?: true
    segundo_apellido?: true
    fecha_nacimiento?: true
    sexo?: true
    email?: true
    telefono?: true
    tipo_usuario?: true
    municipio?: true
    estado?: true
    createAt?: true
    updateAt?: true
    eps?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id_usuario: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre: string | null
    primer_apellido: string
    segundo_apellido: string | null
    fecha_nacimiento: Date
    sexo: $Enums.Sex
    email: string
    telefono: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt: Date
    updateAt: Date
    eps: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    tipo_identificacion?: boolean
    identificacion?: boolean
    primer_nombre?: boolean
    segundo_nombre?: boolean
    primer_apellido?: boolean
    segundo_apellido?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    email?: boolean
    telefono?: boolean
    tipo_usuario?: boolean
    municipio?: boolean
    estado?: boolean
    createAt?: boolean
    updateAt?: boolean
    eps?: boolean
    procedimiento?: boolean | Usuario$procedimientoArgs<ExtArgs>
    Municipio_Usuario?: boolean | MunicipioDefaultArgs<ExtArgs>
    Eps_usuario?: boolean | EpsDefaultArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type UsuarioSelectScalar = {
    id_usuario?: boolean
    tipo_identificacion?: boolean
    identificacion?: boolean
    primer_nombre?: boolean
    segundo_nombre?: boolean
    primer_apellido?: boolean
    segundo_apellido?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    email?: boolean
    telefono?: boolean
    tipo_usuario?: boolean
    municipio?: boolean
    estado?: boolean
    createAt?: boolean
    updateAt?: boolean
    eps?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Usuario$procedimientoArgs<ExtArgs>
    Municipio_Usuario?: boolean | MunicipioDefaultArgs<ExtArgs>
    Eps_usuario?: boolean | EpsDefaultArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>[]
      Municipio_Usuario: Prisma.$MunicipioPayload<ExtArgs>
      Eps_usuario: Prisma.$EpsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      tipo_identificacion: $Enums.Tipo_Ident
      identificacion: string
      primer_nombre: string
      segundo_nombre: string | null
      primer_apellido: string
      segundo_apellido: string | null
      fecha_nacimiento: Date
      sexo: $Enums.Sex
      email: string
      telefono: string | null
      tipo_usuario: $Enums.Tipo_Usuario
      municipio: number
      estado: $Enums.Estado
      createAt: Date
      updateAt: Date
      eps: number
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedimiento<T extends Usuario$procedimientoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$procedimientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany"> | Null>
    Municipio_Usuario<T extends MunicipioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipioDefaultArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Eps_usuario<T extends EpsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EpsDefaultArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id_usuario: FieldRef<"Usuario", 'Int'>
    readonly tipo_identificacion: FieldRef<"Usuario", 'Tipo_Ident'>
    readonly identificacion: FieldRef<"Usuario", 'String'>
    readonly primer_nombre: FieldRef<"Usuario", 'String'>
    readonly segundo_nombre: FieldRef<"Usuario", 'String'>
    readonly primer_apellido: FieldRef<"Usuario", 'String'>
    readonly segundo_apellido: FieldRef<"Usuario", 'String'>
    readonly fecha_nacimiento: FieldRef<"Usuario", 'DateTime'>
    readonly sexo: FieldRef<"Usuario", 'Sex'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly telefono: FieldRef<"Usuario", 'String'>
    readonly tipo_usuario: FieldRef<"Usuario", 'Tipo_Usuario'>
    readonly municipio: FieldRef<"Usuario", 'Int'>
    readonly estado: FieldRef<"Usuario", 'Estado'>
    readonly createAt: FieldRef<"Usuario", 'DateTime'>
    readonly updateAt: FieldRef<"Usuario", 'DateTime'>
    readonly eps: FieldRef<"Usuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.procedimiento
   */
  export type Usuario$procedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    cursor?: ProcedimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Eps
   */

  export type AggregateEps = {
    _count: EpsCountAggregateOutputType | null
    _avg: EpsAvgAggregateOutputType | null
    _sum: EpsSumAggregateOutputType | null
    _min: EpsMinAggregateOutputType | null
    _max: EpsMaxAggregateOutputType | null
  }

  export type EpsAvgAggregateOutputType = {
    id_eps: number | null
  }

  export type EpsSumAggregateOutputType = {
    id_eps: number | null
  }

  export type EpsMinAggregateOutputType = {
    id_eps: number | null
    codigo: string | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type EpsMaxAggregateOutputType = {
    id_eps: number | null
    codigo: string | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type EpsCountAggregateOutputType = {
    id_eps: number
    codigo: number
    nombre: number
    estado: number
    _all: number
  }


  export type EpsAvgAggregateInputType = {
    id_eps?: true
  }

  export type EpsSumAggregateInputType = {
    id_eps?: true
  }

  export type EpsMinAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
  }

  export type EpsMaxAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
  }

  export type EpsCountAggregateInputType = {
    id_eps?: true
    codigo?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type EpsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eps to aggregate.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eps
    **/
    _count?: true | EpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpsMaxAggregateInputType
  }

  export type GetEpsAggregateType<T extends EpsAggregateArgs> = {
        [P in keyof T & keyof AggregateEps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEps[P]>
      : GetScalarType<T[P], AggregateEps[P]>
  }




  export type EpsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpsWhereInput
    orderBy?: EpsOrderByWithAggregationInput | EpsOrderByWithAggregationInput[]
    by: EpsScalarFieldEnum[] | EpsScalarFieldEnum
    having?: EpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpsCountAggregateInputType | true
    _avg?: EpsAvgAggregateInputType
    _sum?: EpsSumAggregateInputType
    _min?: EpsMinAggregateInputType
    _max?: EpsMaxAggregateInputType
  }

  export type EpsGroupByOutputType = {
    id_eps: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
    _count: EpsCountAggregateOutputType | null
    _avg: EpsAvgAggregateOutputType | null
    _sum: EpsSumAggregateOutputType | null
    _min: EpsMinAggregateOutputType | null
    _max: EpsMaxAggregateOutputType | null
  }

  type GetEpsGroupByPayload<T extends EpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpsGroupByOutputType[P]>
            : GetScalarType<T[P], EpsGroupByOutputType[P]>
        }
      >
    >


  export type EpsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_eps?: boolean
    codigo?: boolean
    nombre?: boolean
    estado?: boolean
    usuario?: boolean | Eps$usuarioArgs<ExtArgs>
    _count?: boolean | EpsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eps"]>


  export type EpsSelectScalar = {
    id_eps?: boolean
    codigo?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type EpsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | Eps$usuarioArgs<ExtArgs>
    _count?: boolean | EpsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EpsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Eps"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_eps: number
      codigo: string
      nombre: string
      estado: $Enums.Estado
    }, ExtArgs["result"]["eps"]>
    composites: {}
  }

  type EpsGetPayload<S extends boolean | null | undefined | EpsDefaultArgs> = $Result.GetResult<Prisma.$EpsPayload, S>

  type EpsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EpsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EpsCountAggregateInputType | true
    }

  export interface EpsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Eps'], meta: { name: 'Eps' } }
    /**
     * Find zero or one Eps that matches the filter.
     * @param {EpsFindUniqueArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EpsFindUniqueArgs>(args: SelectSubset<T, EpsFindUniqueArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Eps that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EpsFindUniqueOrThrowArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EpsFindUniqueOrThrowArgs>(args: SelectSubset<T, EpsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Eps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindFirstArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EpsFindFirstArgs>(args?: SelectSubset<T, EpsFindFirstArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Eps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindFirstOrThrowArgs} args - Arguments to find a Eps
     * @example
     * // Get one Eps
     * const eps = await prisma.eps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EpsFindFirstOrThrowArgs>(args?: SelectSubset<T, EpsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eps
     * const eps = await prisma.eps.findMany()
     * 
     * // Get first 10 Eps
     * const eps = await prisma.eps.findMany({ take: 10 })
     * 
     * // Only select the `id_eps`
     * const epsWithId_epsOnly = await prisma.eps.findMany({ select: { id_eps: true } })
     * 
     */
    findMany<T extends EpsFindManyArgs>(args?: SelectSubset<T, EpsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Eps.
     * @param {EpsCreateArgs} args - Arguments to create a Eps.
     * @example
     * // Create one Eps
     * const Eps = await prisma.eps.create({
     *   data: {
     *     // ... data to create a Eps
     *   }
     * })
     * 
     */
    create<T extends EpsCreateArgs>(args: SelectSubset<T, EpsCreateArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eps.
     * @param {EpsCreateManyArgs} args - Arguments to create many Eps.
     * @example
     * // Create many Eps
     * const eps = await prisma.eps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EpsCreateManyArgs>(args?: SelectSubset<T, EpsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Eps.
     * @param {EpsDeleteArgs} args - Arguments to delete one Eps.
     * @example
     * // Delete one Eps
     * const Eps = await prisma.eps.delete({
     *   where: {
     *     // ... filter to delete one Eps
     *   }
     * })
     * 
     */
    delete<T extends EpsDeleteArgs>(args: SelectSubset<T, EpsDeleteArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Eps.
     * @param {EpsUpdateArgs} args - Arguments to update one Eps.
     * @example
     * // Update one Eps
     * const eps = await prisma.eps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EpsUpdateArgs>(args: SelectSubset<T, EpsUpdateArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eps.
     * @param {EpsDeleteManyArgs} args - Arguments to filter Eps to delete.
     * @example
     * // Delete a few Eps
     * const { count } = await prisma.eps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EpsDeleteManyArgs>(args?: SelectSubset<T, EpsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eps
     * const eps = await prisma.eps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EpsUpdateManyArgs>(args: SelectSubset<T, EpsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eps.
     * @param {EpsUpsertArgs} args - Arguments to update or create a Eps.
     * @example
     * // Update or create a Eps
     * const eps = await prisma.eps.upsert({
     *   create: {
     *     // ... data to create a Eps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eps we want to update
     *   }
     * })
     */
    upsert<T extends EpsUpsertArgs>(args: SelectSubset<T, EpsUpsertArgs<ExtArgs>>): Prisma__EpsClient<$Result.GetResult<Prisma.$EpsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsCountArgs} args - Arguments to filter Eps to count.
     * @example
     * // Count the number of Eps
     * const count = await prisma.eps.count({
     *   where: {
     *     // ... the filter for the Eps we want to count
     *   }
     * })
    **/
    count<T extends EpsCountArgs>(
      args?: Subset<T, EpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpsAggregateArgs>(args: Subset<T, EpsAggregateArgs>): Prisma.PrismaPromise<GetEpsAggregateType<T>>

    /**
     * Group by Eps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EpsGroupByArgs['orderBy'] }
        : { orderBy?: EpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Eps model
   */
  readonly fields: EpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Eps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EpsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends Eps$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Eps$usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Eps model
   */ 
  interface EpsFieldRefs {
    readonly id_eps: FieldRef<"Eps", 'Int'>
    readonly codigo: FieldRef<"Eps", 'String'>
    readonly nombre: FieldRef<"Eps", 'String'>
    readonly estado: FieldRef<"Eps", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Eps findUnique
   */
  export type EpsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps findUniqueOrThrow
   */
  export type EpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps findFirst
   */
  export type EpsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eps.
     */
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps findFirstOrThrow
   */
  export type EpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eps.
     */
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps findMany
   */
  export type EpsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter, which Eps to fetch.
     */
    where?: EpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eps to fetch.
     */
    orderBy?: EpsOrderByWithRelationInput | EpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eps.
     */
    cursor?: EpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eps.
     */
    skip?: number
    distinct?: EpsScalarFieldEnum | EpsScalarFieldEnum[]
  }

  /**
   * Eps create
   */
  export type EpsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The data needed to create a Eps.
     */
    data: XOR<EpsCreateInput, EpsUncheckedCreateInput>
  }

  /**
   * Eps createMany
   */
  export type EpsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eps.
     */
    data: EpsCreateManyInput | EpsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Eps update
   */
  export type EpsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The data needed to update a Eps.
     */
    data: XOR<EpsUpdateInput, EpsUncheckedUpdateInput>
    /**
     * Choose, which Eps to update.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps updateMany
   */
  export type EpsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eps.
     */
    data: XOR<EpsUpdateManyMutationInput, EpsUncheckedUpdateManyInput>
    /**
     * Filter which Eps to update
     */
    where?: EpsWhereInput
  }

  /**
   * Eps upsert
   */
  export type EpsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * The filter to search for the Eps to update in case it exists.
     */
    where: EpsWhereUniqueInput
    /**
     * In case the Eps found by the `where` argument doesn't exist, create a new Eps with this data.
     */
    create: XOR<EpsCreateInput, EpsUncheckedCreateInput>
    /**
     * In case the Eps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EpsUpdateInput, EpsUncheckedUpdateInput>
  }

  /**
   * Eps delete
   */
  export type EpsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
    /**
     * Filter which Eps to delete.
     */
    where: EpsWhereUniqueInput
  }

  /**
   * Eps deleteMany
   */
  export type EpsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eps to delete
     */
    where?: EpsWhereInput
  }

  /**
   * Eps.usuario
   */
  export type Eps$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Eps without action
   */
  export type EpsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eps
     */
    select?: EpsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpsInclude<ExtArgs> | null
  }


  /**
   * Model Procedimiento
   */

  export type AggregateProcedimiento = {
    _count: ProcedimientoCountAggregateOutputType | null
    _avg: ProcedimientoAvgAggregateOutputType | null
    _sum: ProcedimientoSumAggregateOutputType | null
    _min: ProcedimientoMinAggregateOutputType | null
    _max: ProcedimientoMaxAggregateOutputType | null
  }

  export type ProcedimientoAvgAggregateOutputType = {
    id_procedimiento: number | null
    consecutivo: number | null
    factura: number | null
    usuario: number | null
    acuerdo: number | null
  }

  export type ProcedimientoSumAggregateOutputType = {
    id_procedimiento: number | null
    consecutivo: number | null
    factura: number | null
    usuario: number | null
    acuerdo: number | null
  }

  export type ProcedimientoMinAggregateOutputType = {
    id_procedimiento: number | null
    consecutivo: number | null
    fecha: Date | null
    factura: number | null
    usuario: number | null
    acuerdo: number | null
  }

  export type ProcedimientoMaxAggregateOutputType = {
    id_procedimiento: number | null
    consecutivo: number | null
    fecha: Date | null
    factura: number | null
    usuario: number | null
    acuerdo: number | null
  }

  export type ProcedimientoCountAggregateOutputType = {
    id_procedimiento: number
    consecutivo: number
    fecha: number
    factura: number
    usuario: number
    acuerdo: number
    _all: number
  }


  export type ProcedimientoAvgAggregateInputType = {
    id_procedimiento?: true
    consecutivo?: true
    factura?: true
    usuario?: true
    acuerdo?: true
  }

  export type ProcedimientoSumAggregateInputType = {
    id_procedimiento?: true
    consecutivo?: true
    factura?: true
    usuario?: true
    acuerdo?: true
  }

  export type ProcedimientoMinAggregateInputType = {
    id_procedimiento?: true
    consecutivo?: true
    fecha?: true
    factura?: true
    usuario?: true
    acuerdo?: true
  }

  export type ProcedimientoMaxAggregateInputType = {
    id_procedimiento?: true
    consecutivo?: true
    fecha?: true
    factura?: true
    usuario?: true
    acuerdo?: true
  }

  export type ProcedimientoCountAggregateInputType = {
    id_procedimiento?: true
    consecutivo?: true
    fecha?: true
    factura?: true
    usuario?: true
    acuerdo?: true
    _all?: true
  }

  export type ProcedimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedimiento to aggregate.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procedimientos
    **/
    _count?: true | ProcedimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcedimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcedimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedimientoMaxAggregateInputType
  }

  export type GetProcedimientoAggregateType<T extends ProcedimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedimiento[P]>
      : GetScalarType<T[P], AggregateProcedimiento[P]>
  }




  export type ProcedimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithAggregationInput | ProcedimientoOrderByWithAggregationInput[]
    by: ProcedimientoScalarFieldEnum[] | ProcedimientoScalarFieldEnum
    having?: ProcedimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedimientoCountAggregateInputType | true
    _avg?: ProcedimientoAvgAggregateInputType
    _sum?: ProcedimientoSumAggregateInputType
    _min?: ProcedimientoMinAggregateInputType
    _max?: ProcedimientoMaxAggregateInputType
  }

  export type ProcedimientoGroupByOutputType = {
    id_procedimiento: number
    consecutivo: number
    fecha: Date
    factura: number
    usuario: number
    acuerdo: number
    _count: ProcedimientoCountAggregateOutputType | null
    _avg: ProcedimientoAvgAggregateOutputType | null
    _sum: ProcedimientoSumAggregateOutputType | null
    _min: ProcedimientoMinAggregateOutputType | null
    _max: ProcedimientoMaxAggregateOutputType | null
  }

  type GetProcedimientoGroupByPayload<T extends ProcedimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedimientoGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedimientoGroupByOutputType[P]>
        }
      >
    >


  export type ProcedimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_procedimiento?: boolean
    consecutivo?: boolean
    fecha?: boolean
    factura?: boolean
    usuario?: boolean
    acuerdo?: boolean
    Procedimiento_Acuerdo?: boolean | AcuerdoDefaultArgs<ExtArgs>
    Procedimiento_Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedimiento"]>


  export type ProcedimientoSelectScalar = {
    id_procedimiento?: boolean
    consecutivo?: boolean
    fecha?: boolean
    factura?: boolean
    usuario?: boolean
    acuerdo?: boolean
  }

  export type ProcedimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Procedimiento_Acuerdo?: boolean | AcuerdoDefaultArgs<ExtArgs>
    Procedimiento_Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ProcedimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Procedimiento"
    objects: {
      Procedimiento_Acuerdo: Prisma.$AcuerdoPayload<ExtArgs>
      Procedimiento_Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_procedimiento: number
      consecutivo: number
      fecha: Date
      factura: number
      usuario: number
      acuerdo: number
    }, ExtArgs["result"]["procedimiento"]>
    composites: {}
  }

  type ProcedimientoGetPayload<S extends boolean | null | undefined | ProcedimientoDefaultArgs> = $Result.GetResult<Prisma.$ProcedimientoPayload, S>

  type ProcedimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcedimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcedimientoCountAggregateInputType | true
    }

  export interface ProcedimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Procedimiento'], meta: { name: 'Procedimiento' } }
    /**
     * Find zero or one Procedimiento that matches the filter.
     * @param {ProcedimientoFindUniqueArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedimientoFindUniqueArgs>(args: SelectSubset<T, ProcedimientoFindUniqueArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Procedimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcedimientoFindUniqueOrThrowArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Procedimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindFirstArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedimientoFindFirstArgs>(args?: SelectSubset<T, ProcedimientoFindFirstArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Procedimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindFirstOrThrowArgs} args - Arguments to find a Procedimiento
     * @example
     * // Get one Procedimiento
     * const procedimiento = await prisma.procedimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procedimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedimientos
     * const procedimientos = await prisma.procedimiento.findMany()
     * 
     * // Get first 10 Procedimientos
     * const procedimientos = await prisma.procedimiento.findMany({ take: 10 })
     * 
     * // Only select the `id_procedimiento`
     * const procedimientoWithId_procedimientoOnly = await prisma.procedimiento.findMany({ select: { id_procedimiento: true } })
     * 
     */
    findMany<T extends ProcedimientoFindManyArgs>(args?: SelectSubset<T, ProcedimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Procedimiento.
     * @param {ProcedimientoCreateArgs} args - Arguments to create a Procedimiento.
     * @example
     * // Create one Procedimiento
     * const Procedimiento = await prisma.procedimiento.create({
     *   data: {
     *     // ... data to create a Procedimiento
     *   }
     * })
     * 
     */
    create<T extends ProcedimientoCreateArgs>(args: SelectSubset<T, ProcedimientoCreateArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procedimientos.
     * @param {ProcedimientoCreateManyArgs} args - Arguments to create many Procedimientos.
     * @example
     * // Create many Procedimientos
     * const procedimiento = await prisma.procedimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedimientoCreateManyArgs>(args?: SelectSubset<T, ProcedimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Procedimiento.
     * @param {ProcedimientoDeleteArgs} args - Arguments to delete one Procedimiento.
     * @example
     * // Delete one Procedimiento
     * const Procedimiento = await prisma.procedimiento.delete({
     *   where: {
     *     // ... filter to delete one Procedimiento
     *   }
     * })
     * 
     */
    delete<T extends ProcedimientoDeleteArgs>(args: SelectSubset<T, ProcedimientoDeleteArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Procedimiento.
     * @param {ProcedimientoUpdateArgs} args - Arguments to update one Procedimiento.
     * @example
     * // Update one Procedimiento
     * const procedimiento = await prisma.procedimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedimientoUpdateArgs>(args: SelectSubset<T, ProcedimientoUpdateArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procedimientos.
     * @param {ProcedimientoDeleteManyArgs} args - Arguments to filter Procedimientos to delete.
     * @example
     * // Delete a few Procedimientos
     * const { count } = await prisma.procedimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedimientoDeleteManyArgs>(args?: SelectSubset<T, ProcedimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedimientos
     * const procedimiento = await prisma.procedimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedimientoUpdateManyArgs>(args: SelectSubset<T, ProcedimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Procedimiento.
     * @param {ProcedimientoUpsertArgs} args - Arguments to update or create a Procedimiento.
     * @example
     * // Update or create a Procedimiento
     * const procedimiento = await prisma.procedimiento.upsert({
     *   create: {
     *     // ... data to create a Procedimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedimiento we want to update
     *   }
     * })
     */
    upsert<T extends ProcedimientoUpsertArgs>(args: SelectSubset<T, ProcedimientoUpsertArgs<ExtArgs>>): Prisma__ProcedimientoClient<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procedimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoCountArgs} args - Arguments to filter Procedimientos to count.
     * @example
     * // Count the number of Procedimientos
     * const count = await prisma.procedimiento.count({
     *   where: {
     *     // ... the filter for the Procedimientos we want to count
     *   }
     * })
    **/
    count<T extends ProcedimientoCountArgs>(
      args?: Subset<T, ProcedimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedimientoAggregateArgs>(args: Subset<T, ProcedimientoAggregateArgs>): Prisma.PrismaPromise<GetProcedimientoAggregateType<T>>

    /**
     * Group by Procedimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedimientoGroupByArgs['orderBy'] }
        : { orderBy?: ProcedimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Procedimiento model
   */
  readonly fields: ProcedimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Procedimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Procedimiento_Acuerdo<T extends AcuerdoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcuerdoDefaultArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Procedimiento_Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Procedimiento model
   */ 
  interface ProcedimientoFieldRefs {
    readonly id_procedimiento: FieldRef<"Procedimiento", 'Int'>
    readonly consecutivo: FieldRef<"Procedimiento", 'Int'>
    readonly fecha: FieldRef<"Procedimiento", 'DateTime'>
    readonly factura: FieldRef<"Procedimiento", 'Int'>
    readonly usuario: FieldRef<"Procedimiento", 'Int'>
    readonly acuerdo: FieldRef<"Procedimiento", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Procedimiento findUnique
   */
  export type ProcedimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento findUniqueOrThrow
   */
  export type ProcedimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento findFirst
   */
  export type ProcedimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedimientos.
     */
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento findFirstOrThrow
   */
  export type ProcedimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimiento to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedimientos.
     */
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento findMany
   */
  export type ProcedimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter, which Procedimientos to fetch.
     */
    where?: ProcedimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedimientos to fetch.
     */
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procedimientos.
     */
    cursor?: ProcedimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedimientos.
     */
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Procedimiento create
   */
  export type ProcedimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Procedimiento.
     */
    data: XOR<ProcedimientoCreateInput, ProcedimientoUncheckedCreateInput>
  }

  /**
   * Procedimiento createMany
   */
  export type ProcedimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procedimientos.
     */
    data: ProcedimientoCreateManyInput | ProcedimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedimiento update
   */
  export type ProcedimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Procedimiento.
     */
    data: XOR<ProcedimientoUpdateInput, ProcedimientoUncheckedUpdateInput>
    /**
     * Choose, which Procedimiento to update.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento updateMany
   */
  export type ProcedimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procedimientos.
     */
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyInput>
    /**
     * Filter which Procedimientos to update
     */
    where?: ProcedimientoWhereInput
  }

  /**
   * Procedimiento upsert
   */
  export type ProcedimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Procedimiento to update in case it exists.
     */
    where: ProcedimientoWhereUniqueInput
    /**
     * In case the Procedimiento found by the `where` argument doesn't exist, create a new Procedimiento with this data.
     */
    create: XOR<ProcedimientoCreateInput, ProcedimientoUncheckedCreateInput>
    /**
     * In case the Procedimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedimientoUpdateInput, ProcedimientoUncheckedUpdateInput>
  }

  /**
   * Procedimiento delete
   */
  export type ProcedimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    /**
     * Filter which Procedimiento to delete.
     */
    where: ProcedimientoWhereUniqueInput
  }

  /**
   * Procedimiento deleteMany
   */
  export type ProcedimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedimientos to delete
     */
    where?: ProcedimientoWhereInput
  }

  /**
   * Procedimiento without action
   */
  export type ProcedimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
  }


  /**
   * Model Departamento
   */

  export type AggregateDepartamento = {
    _count: DepartamentoCountAggregateOutputType | null
    _avg: DepartamentoAvgAggregateOutputType | null
    _sum: DepartamentoSumAggregateOutputType | null
    _min: DepartamentoMinAggregateOutputType | null
    _max: DepartamentoMaxAggregateOutputType | null
  }

  export type DepartamentoAvgAggregateOutputType = {
    id_departamento: number | null
  }

  export type DepartamentoSumAggregateOutputType = {
    id_departamento: number | null
  }

  export type DepartamentoMinAggregateOutputType = {
    id_departamento: number | null
    nombre: string | null
  }

  export type DepartamentoMaxAggregateOutputType = {
    id_departamento: number | null
    nombre: string | null
  }

  export type DepartamentoCountAggregateOutputType = {
    id_departamento: number
    nombre: number
    _all: number
  }


  export type DepartamentoAvgAggregateInputType = {
    id_departamento?: true
  }

  export type DepartamentoSumAggregateInputType = {
    id_departamento?: true
  }

  export type DepartamentoMinAggregateInputType = {
    id_departamento?: true
    nombre?: true
  }

  export type DepartamentoMaxAggregateInputType = {
    id_departamento?: true
    nombre?: true
  }

  export type DepartamentoCountAggregateInputType = {
    id_departamento?: true
    nombre?: true
    _all?: true
  }

  export type DepartamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departamento to aggregate.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departamentos
    **/
    _count?: true | DepartamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartamentoMaxAggregateInputType
  }

  export type GetDepartamentoAggregateType<T extends DepartamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartamento[P]>
      : GetScalarType<T[P], AggregateDepartamento[P]>
  }




  export type DepartamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartamentoWhereInput
    orderBy?: DepartamentoOrderByWithAggregationInput | DepartamentoOrderByWithAggregationInput[]
    by: DepartamentoScalarFieldEnum[] | DepartamentoScalarFieldEnum
    having?: DepartamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartamentoCountAggregateInputType | true
    _avg?: DepartamentoAvgAggregateInputType
    _sum?: DepartamentoSumAggregateInputType
    _min?: DepartamentoMinAggregateInputType
    _max?: DepartamentoMaxAggregateInputType
  }

  export type DepartamentoGroupByOutputType = {
    id_departamento: number
    nombre: string
    _count: DepartamentoCountAggregateOutputType | null
    _avg: DepartamentoAvgAggregateOutputType | null
    _sum: DepartamentoSumAggregateOutputType | null
    _min: DepartamentoMinAggregateOutputType | null
    _max: DepartamentoMaxAggregateOutputType | null
  }

  type GetDepartamentoGroupByPayload<T extends DepartamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartamentoGroupByOutputType[P]>
            : GetScalarType<T[P], DepartamentoGroupByOutputType[P]>
        }
      >
    >


  export type DepartamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_departamento?: boolean
    nombre?: boolean
    municipio?: boolean | Departamento$municipioArgs<ExtArgs>
    _count?: boolean | DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departamento"]>


  export type DepartamentoSelectScalar = {
    id_departamento?: boolean
    nombre?: boolean
  }

  export type DepartamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | Departamento$municipioArgs<ExtArgs>
    _count?: boolean | DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Departamento"
    objects: {
      municipio: Prisma.$MunicipioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_departamento: number
      nombre: string
    }, ExtArgs["result"]["departamento"]>
    composites: {}
  }

  type DepartamentoGetPayload<S extends boolean | null | undefined | DepartamentoDefaultArgs> = $Result.GetResult<Prisma.$DepartamentoPayload, S>

  type DepartamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartamentoCountAggregateInputType | true
    }

  export interface DepartamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Departamento'], meta: { name: 'Departamento' } }
    /**
     * Find zero or one Departamento that matches the filter.
     * @param {DepartamentoFindUniqueArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartamentoFindUniqueArgs>(args: SelectSubset<T, DepartamentoFindUniqueArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Departamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartamentoFindUniqueOrThrowArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Departamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindFirstArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartamentoFindFirstArgs>(args?: SelectSubset<T, DepartamentoFindFirstArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Departamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindFirstOrThrowArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departamentos
     * const departamentos = await prisma.departamento.findMany()
     * 
     * // Get first 10 Departamentos
     * const departamentos = await prisma.departamento.findMany({ take: 10 })
     * 
     * // Only select the `id_departamento`
     * const departamentoWithId_departamentoOnly = await prisma.departamento.findMany({ select: { id_departamento: true } })
     * 
     */
    findMany<T extends DepartamentoFindManyArgs>(args?: SelectSubset<T, DepartamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Departamento.
     * @param {DepartamentoCreateArgs} args - Arguments to create a Departamento.
     * @example
     * // Create one Departamento
     * const Departamento = await prisma.departamento.create({
     *   data: {
     *     // ... data to create a Departamento
     *   }
     * })
     * 
     */
    create<T extends DepartamentoCreateArgs>(args: SelectSubset<T, DepartamentoCreateArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departamentos.
     * @param {DepartamentoCreateManyArgs} args - Arguments to create many Departamentos.
     * @example
     * // Create many Departamentos
     * const departamento = await prisma.departamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartamentoCreateManyArgs>(args?: SelectSubset<T, DepartamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Departamento.
     * @param {DepartamentoDeleteArgs} args - Arguments to delete one Departamento.
     * @example
     * // Delete one Departamento
     * const Departamento = await prisma.departamento.delete({
     *   where: {
     *     // ... filter to delete one Departamento
     *   }
     * })
     * 
     */
    delete<T extends DepartamentoDeleteArgs>(args: SelectSubset<T, DepartamentoDeleteArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Departamento.
     * @param {DepartamentoUpdateArgs} args - Arguments to update one Departamento.
     * @example
     * // Update one Departamento
     * const departamento = await prisma.departamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartamentoUpdateArgs>(args: SelectSubset<T, DepartamentoUpdateArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departamentos.
     * @param {DepartamentoDeleteManyArgs} args - Arguments to filter Departamentos to delete.
     * @example
     * // Delete a few Departamentos
     * const { count } = await prisma.departamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartamentoDeleteManyArgs>(args?: SelectSubset<T, DepartamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departamentos
     * const departamento = await prisma.departamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartamentoUpdateManyArgs>(args: SelectSubset<T, DepartamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Departamento.
     * @param {DepartamentoUpsertArgs} args - Arguments to update or create a Departamento.
     * @example
     * // Update or create a Departamento
     * const departamento = await prisma.departamento.upsert({
     *   create: {
     *     // ... data to create a Departamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departamento we want to update
     *   }
     * })
     */
    upsert<T extends DepartamentoUpsertArgs>(args: SelectSubset<T, DepartamentoUpsertArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoCountArgs} args - Arguments to filter Departamentos to count.
     * @example
     * // Count the number of Departamentos
     * const count = await prisma.departamento.count({
     *   where: {
     *     // ... the filter for the Departamentos we want to count
     *   }
     * })
    **/
    count<T extends DepartamentoCountArgs>(
      args?: Subset<T, DepartamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartamentoAggregateArgs>(args: Subset<T, DepartamentoAggregateArgs>): Prisma.PrismaPromise<GetDepartamentoAggregateType<T>>

    /**
     * Group by Departamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartamentoGroupByArgs['orderBy'] }
        : { orderBy?: DepartamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Departamento model
   */
  readonly fields: DepartamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Departamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipio<T extends Departamento$municipioArgs<ExtArgs> = {}>(args?: Subset<T, Departamento$municipioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Departamento model
   */ 
  interface DepartamentoFieldRefs {
    readonly id_departamento: FieldRef<"Departamento", 'Int'>
    readonly nombre: FieldRef<"Departamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Departamento findUnique
   */
  export type DepartamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento findUniqueOrThrow
   */
  export type DepartamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento findFirst
   */
  export type DepartamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     */
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento findFirstOrThrow
   */
  export type DepartamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     */
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento findMany
   */
  export type DepartamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamentos to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento create
   */
  export type DepartamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Departamento.
     */
    data: XOR<DepartamentoCreateInput, DepartamentoUncheckedCreateInput>
  }

  /**
   * Departamento createMany
   */
  export type DepartamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departamentos.
     */
    data: DepartamentoCreateManyInput | DepartamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Departamento update
   */
  export type DepartamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Departamento.
     */
    data: XOR<DepartamentoUpdateInput, DepartamentoUncheckedUpdateInput>
    /**
     * Choose, which Departamento to update.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento updateMany
   */
  export type DepartamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departamentos.
     */
    data: XOR<DepartamentoUpdateManyMutationInput, DepartamentoUncheckedUpdateManyInput>
    /**
     * Filter which Departamentos to update
     */
    where?: DepartamentoWhereInput
  }

  /**
   * Departamento upsert
   */
  export type DepartamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Departamento to update in case it exists.
     */
    where: DepartamentoWhereUniqueInput
    /**
     * In case the Departamento found by the `where` argument doesn't exist, create a new Departamento with this data.
     */
    create: XOR<DepartamentoCreateInput, DepartamentoUncheckedCreateInput>
    /**
     * In case the Departamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartamentoUpdateInput, DepartamentoUncheckedUpdateInput>
  }

  /**
   * Departamento delete
   */
  export type DepartamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter which Departamento to delete.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento deleteMany
   */
  export type DepartamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departamentos to delete
     */
    where?: DepartamentoWhereInput
  }

  /**
   * Departamento.municipio
   */
  export type Departamento$municipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    where?: MunicipioWhereInput
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    cursor?: MunicipioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Departamento without action
   */
  export type DepartamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
  }


  /**
   * Model Municipio
   */

  export type AggregateMunicipio = {
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  export type MunicipioAvgAggregateOutputType = {
    id_municipio: number | null
    departamento: number | null
  }

  export type MunicipioSumAggregateOutputType = {
    id_municipio: number | null
    departamento: number | null
  }

  export type MunicipioMinAggregateOutputType = {
    id_municipio: number | null
    nombre: string | null
    departamento: number | null
  }

  export type MunicipioMaxAggregateOutputType = {
    id_municipio: number | null
    nombre: string | null
    departamento: number | null
  }

  export type MunicipioCountAggregateOutputType = {
    id_municipio: number
    nombre: number
    departamento: number
    _all: number
  }


  export type MunicipioAvgAggregateInputType = {
    id_municipio?: true
    departamento?: true
  }

  export type MunicipioSumAggregateInputType = {
    id_municipio?: true
    departamento?: true
  }

  export type MunicipioMinAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamento?: true
  }

  export type MunicipioMaxAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamento?: true
  }

  export type MunicipioCountAggregateInputType = {
    id_municipio?: true
    nombre?: true
    departamento?: true
    _all?: true
  }

  export type MunicipioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipio to aggregate.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipios
    **/
    _count?: true | MunicipioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MunicipioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MunicipioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipioMaxAggregateInputType
  }

  export type GetMunicipioAggregateType<T extends MunicipioAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipio[P]>
      : GetScalarType<T[P], AggregateMunicipio[P]>
  }




  export type MunicipioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipioWhereInput
    orderBy?: MunicipioOrderByWithAggregationInput | MunicipioOrderByWithAggregationInput[]
    by: MunicipioScalarFieldEnum[] | MunicipioScalarFieldEnum
    having?: MunicipioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipioCountAggregateInputType | true
    _avg?: MunicipioAvgAggregateInputType
    _sum?: MunicipioSumAggregateInputType
    _min?: MunicipioMinAggregateInputType
    _max?: MunicipioMaxAggregateInputType
  }

  export type MunicipioGroupByOutputType = {
    id_municipio: number
    nombre: string
    departamento: number
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  type GetMunicipioGroupByPayload<T extends MunicipioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
        }
      >
    >


  export type MunicipioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_municipio?: boolean
    nombre?: boolean
    departamento?: boolean
    suario?: boolean | Municipio$suarioArgs<ExtArgs>
    empresa?: boolean | Municipio$empresaArgs<ExtArgs>
    Departamentos_Municipio?: boolean | DepartamentoDefaultArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipio"]>


  export type MunicipioSelectScalar = {
    id_municipio?: boolean
    nombre?: boolean
    departamento?: boolean
  }

  export type MunicipioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suario?: boolean | Municipio$suarioArgs<ExtArgs>
    empresa?: boolean | Municipio$empresaArgs<ExtArgs>
    Departamentos_Municipio?: boolean | DepartamentoDefaultArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MunicipioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipio"
    objects: {
      suario: Prisma.$UsuarioPayload<ExtArgs>[]
      empresa: Prisma.$EmpresaPayload<ExtArgs>[]
      Departamentos_Municipio: Prisma.$DepartamentoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_municipio: number
      nombre: string
      departamento: number
    }, ExtArgs["result"]["municipio"]>
    composites: {}
  }

  type MunicipioGetPayload<S extends boolean | null | undefined | MunicipioDefaultArgs> = $Result.GetResult<Prisma.$MunicipioPayload, S>

  type MunicipioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MunicipioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MunicipioCountAggregateInputType | true
    }

  export interface MunicipioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipio'], meta: { name: 'Municipio' } }
    /**
     * Find zero or one Municipio that matches the filter.
     * @param {MunicipioFindUniqueArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipioFindUniqueArgs>(args: SelectSubset<T, MunicipioFindUniqueArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Municipio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MunicipioFindUniqueOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipioFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Municipio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindFirstArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipioFindFirstArgs>(args?: SelectSubset<T, MunicipioFindFirstArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Municipio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindFirstOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipioFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipioFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Municipios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipios
     * const municipios = await prisma.municipio.findMany()
     * 
     * // Get first 10 Municipios
     * const municipios = await prisma.municipio.findMany({ take: 10 })
     * 
     * // Only select the `id_municipio`
     * const municipioWithId_municipioOnly = await prisma.municipio.findMany({ select: { id_municipio: true } })
     * 
     */
    findMany<T extends MunicipioFindManyArgs>(args?: SelectSubset<T, MunicipioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Municipio.
     * @param {MunicipioCreateArgs} args - Arguments to create a Municipio.
     * @example
     * // Create one Municipio
     * const Municipio = await prisma.municipio.create({
     *   data: {
     *     // ... data to create a Municipio
     *   }
     * })
     * 
     */
    create<T extends MunicipioCreateArgs>(args: SelectSubset<T, MunicipioCreateArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Municipios.
     * @param {MunicipioCreateManyArgs} args - Arguments to create many Municipios.
     * @example
     * // Create many Municipios
     * const municipio = await prisma.municipio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipioCreateManyArgs>(args?: SelectSubset<T, MunicipioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Municipio.
     * @param {MunicipioDeleteArgs} args - Arguments to delete one Municipio.
     * @example
     * // Delete one Municipio
     * const Municipio = await prisma.municipio.delete({
     *   where: {
     *     // ... filter to delete one Municipio
     *   }
     * })
     * 
     */
    delete<T extends MunicipioDeleteArgs>(args: SelectSubset<T, MunicipioDeleteArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Municipio.
     * @param {MunicipioUpdateArgs} args - Arguments to update one Municipio.
     * @example
     * // Update one Municipio
     * const municipio = await prisma.municipio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipioUpdateArgs>(args: SelectSubset<T, MunicipioUpdateArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Municipios.
     * @param {MunicipioDeleteManyArgs} args - Arguments to filter Municipios to delete.
     * @example
     * // Delete a few Municipios
     * const { count } = await prisma.municipio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipioDeleteManyArgs>(args?: SelectSubset<T, MunicipioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipios
     * const municipio = await prisma.municipio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipioUpdateManyArgs>(args: SelectSubset<T, MunicipioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Municipio.
     * @param {MunicipioUpsertArgs} args - Arguments to update or create a Municipio.
     * @example
     * // Update or create a Municipio
     * const municipio = await prisma.municipio.upsert({
     *   create: {
     *     // ... data to create a Municipio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipio we want to update
     *   }
     * })
     */
    upsert<T extends MunicipioUpsertArgs>(args: SelectSubset<T, MunicipioUpsertArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioCountArgs} args - Arguments to filter Municipios to count.
     * @example
     * // Count the number of Municipios
     * const count = await prisma.municipio.count({
     *   where: {
     *     // ... the filter for the Municipios we want to count
     *   }
     * })
    **/
    count<T extends MunicipioCountArgs>(
      args?: Subset<T, MunicipioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipioAggregateArgs>(args: Subset<T, MunicipioAggregateArgs>): Prisma.PrismaPromise<GetMunicipioAggregateType<T>>

    /**
     * Group by Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipioGroupByArgs['orderBy'] }
        : { orderBy?: MunicipioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipio model
   */
  readonly fields: MunicipioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    suario<T extends Municipio$suarioArgs<ExtArgs> = {}>(args?: Subset<T, Municipio$suarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    empresa<T extends Municipio$empresaArgs<ExtArgs> = {}>(args?: Subset<T, Municipio$empresaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany"> | Null>
    Departamentos_Municipio<T extends DepartamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartamentoDefaultArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipio model
   */ 
  interface MunicipioFieldRefs {
    readonly id_municipio: FieldRef<"Municipio", 'Int'>
    readonly nombre: FieldRef<"Municipio", 'String'>
    readonly departamento: FieldRef<"Municipio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Municipio findUnique
   */
  export type MunicipioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio findUniqueOrThrow
   */
  export type MunicipioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio findFirst
   */
  export type MunicipioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio findFirstOrThrow
   */
  export type MunicipioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio findMany
   */
  export type MunicipioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipios to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio create
   */
  export type MunicipioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipio.
     */
    data: XOR<MunicipioCreateInput, MunicipioUncheckedCreateInput>
  }

  /**
   * Municipio createMany
   */
  export type MunicipioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipios.
     */
    data: MunicipioCreateManyInput | MunicipioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Municipio update
   */
  export type MunicipioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipio.
     */
    data: XOR<MunicipioUpdateInput, MunicipioUncheckedUpdateInput>
    /**
     * Choose, which Municipio to update.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio updateMany
   */
  export type MunicipioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipios.
     */
    data: XOR<MunicipioUpdateManyMutationInput, MunicipioUncheckedUpdateManyInput>
    /**
     * Filter which Municipios to update
     */
    where?: MunicipioWhereInput
  }

  /**
   * Municipio upsert
   */
  export type MunicipioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipio to update in case it exists.
     */
    where: MunicipioWhereUniqueInput
    /**
     * In case the Municipio found by the `where` argument doesn't exist, create a new Municipio with this data.
     */
    create: XOR<MunicipioCreateInput, MunicipioUncheckedCreateInput>
    /**
     * In case the Municipio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipioUpdateInput, MunicipioUncheckedUpdateInput>
  }

  /**
   * Municipio delete
   */
  export type MunicipioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter which Municipio to delete.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio deleteMany
   */
  export type MunicipioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipios to delete
     */
    where?: MunicipioWhereInput
  }

  /**
   * Municipio.suario
   */
  export type Municipio$suarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Municipio.empresa
   */
  export type Municipio$empresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    cursor?: EmpresaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Municipio without action
   */
  export type MunicipioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
  }


  /**
   * Model Servicio
   */

  export type AggregateServicio = {
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  export type ServicioAvgAggregateOutputType = {
    id_servicio: number | null
    precio: Decimal | null
    iva: Decimal | null
    nivel: number | null
    tarifa: number | null
    protocolo: number | null
    prestador: number | null
  }

  export type ServicioSumAggregateOutputType = {
    id_servicio: number | null
    precio: Decimal | null
    iva: Decimal | null
    nivel: number | null
    tarifa: number | null
    protocolo: number | null
    prestador: number | null
  }

  export type ServicioMinAggregateOutputType = {
    id_servicio: number | null
    nombre: string | null
    precio: Decimal | null
    iva: Decimal | null
    nivel: number | null
    tarifa: number | null
    protocolo: number | null
    prestador: number | null
  }

  export type ServicioMaxAggregateOutputType = {
    id_servicio: number | null
    nombre: string | null
    precio: Decimal | null
    iva: Decimal | null
    nivel: number | null
    tarifa: number | null
    protocolo: number | null
    prestador: number | null
  }

  export type ServicioCountAggregateOutputType = {
    id_servicio: number
    nombre: number
    precio: number
    iva: number
    nivel: number
    tarifa: number
    protocolo: number
    prestador: number
    _all: number
  }


  export type ServicioAvgAggregateInputType = {
    id_servicio?: true
    precio?: true
    iva?: true
    nivel?: true
    tarifa?: true
    protocolo?: true
    prestador?: true
  }

  export type ServicioSumAggregateInputType = {
    id_servicio?: true
    precio?: true
    iva?: true
    nivel?: true
    tarifa?: true
    protocolo?: true
    prestador?: true
  }

  export type ServicioMinAggregateInputType = {
    id_servicio?: true
    nombre?: true
    precio?: true
    iva?: true
    nivel?: true
    tarifa?: true
    protocolo?: true
    prestador?: true
  }

  export type ServicioMaxAggregateInputType = {
    id_servicio?: true
    nombre?: true
    precio?: true
    iva?: true
    nivel?: true
    tarifa?: true
    protocolo?: true
    prestador?: true
  }

  export type ServicioCountAggregateInputType = {
    id_servicio?: true
    nombre?: true
    precio?: true
    iva?: true
    nivel?: true
    tarifa?: true
    protocolo?: true
    prestador?: true
    _all?: true
  }

  export type ServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicio to aggregate.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicios
    **/
    _count?: true | ServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioMaxAggregateInputType
  }

  export type GetServicioAggregateType<T extends ServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio[P]>
      : GetScalarType<T[P], AggregateServicio[P]>
  }




  export type ServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithAggregationInput | ServicioOrderByWithAggregationInput[]
    by: ServicioScalarFieldEnum[] | ServicioScalarFieldEnum
    having?: ServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioCountAggregateInputType | true
    _avg?: ServicioAvgAggregateInputType
    _sum?: ServicioSumAggregateInputType
    _min?: ServicioMinAggregateInputType
    _max?: ServicioMaxAggregateInputType
  }

  export type ServicioGroupByOutputType = {
    id_servicio: number
    nombre: string
    precio: Decimal
    iva: Decimal
    nivel: number
    tarifa: number
    protocolo: number
    prestador: number
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  type GetServicioGroupByPayload<T extends ServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicioGroupByOutputType[P]>
            : GetScalarType<T[P], ServicioGroupByOutputType[P]>
        }
      >
    >


  export type ServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_servicio?: boolean
    nombre?: boolean
    precio?: boolean
    iva?: boolean
    nivel?: boolean
    tarifa?: boolean
    protocolo?: boolean
    prestador?: boolean
    Tarifa_Servicio?: boolean | TarifaDefaultArgs<ExtArgs>
    Tarifa_Protocolo?: boolean | ProtocoloDefaultArgs<ExtArgs>
    Prestador_Servicio?: boolean | PrestadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>


  export type ServicioSelectScalar = {
    id_servicio?: boolean
    nombre?: boolean
    precio?: boolean
    iva?: boolean
    nivel?: boolean
    tarifa?: boolean
    protocolo?: boolean
    prestador?: boolean
  }

  export type ServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tarifa_Servicio?: boolean | TarifaDefaultArgs<ExtArgs>
    Tarifa_Protocolo?: boolean | ProtocoloDefaultArgs<ExtArgs>
    Prestador_Servicio?: boolean | PrestadorDefaultArgs<ExtArgs>
  }

  export type $ServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Servicio"
    objects: {
      Tarifa_Servicio: Prisma.$TarifaPayload<ExtArgs>
      Tarifa_Protocolo: Prisma.$ProtocoloPayload<ExtArgs>
      Prestador_Servicio: Prisma.$PrestadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_servicio: number
      nombre: string
      precio: Prisma.Decimal
      iva: Prisma.Decimal
      nivel: number
      tarifa: number
      protocolo: number
      prestador: number
    }, ExtArgs["result"]["servicio"]>
    composites: {}
  }

  type ServicioGetPayload<S extends boolean | null | undefined | ServicioDefaultArgs> = $Result.GetResult<Prisma.$ServicioPayload, S>

  type ServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServicioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicioCountAggregateInputType | true
    }

  export interface ServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Servicio'], meta: { name: 'Servicio' } }
    /**
     * Find zero or one Servicio that matches the filter.
     * @param {ServicioFindUniqueArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicioFindUniqueArgs>(args: SelectSubset<T, ServicioFindUniqueArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServicioFindUniqueOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicioFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicioFindFirstArgs>(args?: SelectSubset<T, ServicioFindFirstArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicioFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicio.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicio.findMany({ take: 10 })
     * 
     * // Only select the `id_servicio`
     * const servicioWithId_servicioOnly = await prisma.servicio.findMany({ select: { id_servicio: true } })
     * 
     */
    findMany<T extends ServicioFindManyArgs>(args?: SelectSubset<T, ServicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicio.
     * @param {ServicioCreateArgs} args - Arguments to create a Servicio.
     * @example
     * // Create one Servicio
     * const Servicio = await prisma.servicio.create({
     *   data: {
     *     // ... data to create a Servicio
     *   }
     * })
     * 
     */
    create<T extends ServicioCreateArgs>(args: SelectSubset<T, ServicioCreateArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicios.
     * @param {ServicioCreateManyArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicio = await prisma.servicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicioCreateManyArgs>(args?: SelectSubset<T, ServicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio.
     * @param {ServicioDeleteArgs} args - Arguments to delete one Servicio.
     * @example
     * // Delete one Servicio
     * const Servicio = await prisma.servicio.delete({
     *   where: {
     *     // ... filter to delete one Servicio
     *   }
     * })
     * 
     */
    delete<T extends ServicioDeleteArgs>(args: SelectSubset<T, ServicioDeleteArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicio.
     * @param {ServicioUpdateArgs} args - Arguments to update one Servicio.
     * @example
     * // Update one Servicio
     * const servicio = await prisma.servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicioUpdateArgs>(args: SelectSubset<T, ServicioUpdateArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {ServicioDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicioDeleteManyArgs>(args?: SelectSubset<T, ServicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicio = await prisma.servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicioUpdateManyArgs>(args: SelectSubset<T, ServicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio.
     * @param {ServicioUpsertArgs} args - Arguments to update or create a Servicio.
     * @example
     * // Update or create a Servicio
     * const servicio = await prisma.servicio.upsert({
     *   create: {
     *     // ... data to create a Servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio we want to update
     *   }
     * })
     */
    upsert<T extends ServicioUpsertArgs>(args: SelectSubset<T, ServicioUpsertArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicio.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends ServicioCountArgs>(
      args?: Subset<T, ServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioAggregateArgs>(args: Subset<T, ServicioAggregateArgs>): Prisma.PrismaPromise<GetServicioAggregateType<T>>

    /**
     * Group by Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicioGroupByArgs['orderBy'] }
        : { orderBy?: ServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Servicio model
   */
  readonly fields: ServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Tarifa_Servicio<T extends TarifaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TarifaDefaultArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tarifa_Protocolo<T extends ProtocoloDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProtocoloDefaultArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Prestador_Servicio<T extends PrestadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrestadorDefaultArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Servicio model
   */ 
  interface ServicioFieldRefs {
    readonly id_servicio: FieldRef<"Servicio", 'Int'>
    readonly nombre: FieldRef<"Servicio", 'String'>
    readonly precio: FieldRef<"Servicio", 'Decimal'>
    readonly iva: FieldRef<"Servicio", 'Decimal'>
    readonly nivel: FieldRef<"Servicio", 'Int'>
    readonly tarifa: FieldRef<"Servicio", 'Int'>
    readonly protocolo: FieldRef<"Servicio", 'Int'>
    readonly prestador: FieldRef<"Servicio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Servicio findUnique
   */
  export type ServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findUniqueOrThrow
   */
  export type ServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findFirst
   */
  export type ServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio findFirstOrThrow
   */
  export type ServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio findMany
   */
  export type ServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio create
   */
  export type ServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a Servicio.
     */
    data: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
  }

  /**
   * Servicio createMany
   */
  export type ServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servicios.
     */
    data: ServicioCreateManyInput | ServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Servicio update
   */
  export type ServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a Servicio.
     */
    data: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
    /**
     * Choose, which Servicio to update.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio updateMany
   */
  export type ServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servicios.
     */
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyInput>
    /**
     * Filter which Servicios to update
     */
    where?: ServicioWhereInput
  }

  /**
   * Servicio upsert
   */
  export type ServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the Servicio to update in case it exists.
     */
    where: ServicioWhereUniqueInput
    /**
     * In case the Servicio found by the `where` argument doesn't exist, create a new Servicio with this data.
     */
    create: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
    /**
     * In case the Servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
  }

  /**
   * Servicio delete
   */
  export type ServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter which Servicio to delete.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio deleteMany
   */
  export type ServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to delete
     */
    where?: ServicioWhereInput
  }

  /**
   * Servicio without action
   */
  export type ServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
  }


  /**
   * Model Prestador
   */

  export type AggregatePrestador = {
    _count: PrestadorCountAggregateOutputType | null
    _avg: PrestadorAvgAggregateOutputType | null
    _sum: PrestadorSumAggregateOutputType | null
    _min: PrestadorMinAggregateOutputType | null
    _max: PrestadorMaxAggregateOutputType | null
  }

  export type PrestadorAvgAggregateOutputType = {
    id_prestador: number | null
    codigo: number | null
    consecutivo: number | null
  }

  export type PrestadorSumAggregateOutputType = {
    id_prestador: number | null
    codigo: bigint | null
    consecutivo: number | null
  }

  export type PrestadorMinAggregateOutputType = {
    id_prestador: number | null
    codigo: bigint | null
    razon_social: string | null
    consecutivo: number | null
  }

  export type PrestadorMaxAggregateOutputType = {
    id_prestador: number | null
    codigo: bigint | null
    razon_social: string | null
    consecutivo: number | null
  }

  export type PrestadorCountAggregateOutputType = {
    id_prestador: number
    codigo: number
    razon_social: number
    consecutivo: number
    _all: number
  }


  export type PrestadorAvgAggregateInputType = {
    id_prestador?: true
    codigo?: true
    consecutivo?: true
  }

  export type PrestadorSumAggregateInputType = {
    id_prestador?: true
    codigo?: true
    consecutivo?: true
  }

  export type PrestadorMinAggregateInputType = {
    id_prestador?: true
    codigo?: true
    razon_social?: true
    consecutivo?: true
  }

  export type PrestadorMaxAggregateInputType = {
    id_prestador?: true
    codigo?: true
    razon_social?: true
    consecutivo?: true
  }

  export type PrestadorCountAggregateInputType = {
    id_prestador?: true
    codigo?: true
    razon_social?: true
    consecutivo?: true
    _all?: true
  }

  export type PrestadorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prestador to aggregate.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prestadors
    **/
    _count?: true | PrestadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrestadorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrestadorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrestadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrestadorMaxAggregateInputType
  }

  export type GetPrestadorAggregateType<T extends PrestadorAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestador[P]>
      : GetScalarType<T[P], AggregatePrestador[P]>
  }




  export type PrestadorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrestadorWhereInput
    orderBy?: PrestadorOrderByWithAggregationInput | PrestadorOrderByWithAggregationInput[]
    by: PrestadorScalarFieldEnum[] | PrestadorScalarFieldEnum
    having?: PrestadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrestadorCountAggregateInputType | true
    _avg?: PrestadorAvgAggregateInputType
    _sum?: PrestadorSumAggregateInputType
    _min?: PrestadorMinAggregateInputType
    _max?: PrestadorMaxAggregateInputType
  }

  export type PrestadorGroupByOutputType = {
    id_prestador: number
    codigo: bigint
    razon_social: string
    consecutivo: number
    _count: PrestadorCountAggregateOutputType | null
    _avg: PrestadorAvgAggregateOutputType | null
    _sum: PrestadorSumAggregateOutputType | null
    _min: PrestadorMinAggregateOutputType | null
    _max: PrestadorMaxAggregateOutputType | null
  }

  type GetPrestadorGroupByPayload<T extends PrestadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrestadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrestadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrestadorGroupByOutputType[P]>
            : GetScalarType<T[P], PrestadorGroupByOutputType[P]>
        }
      >
    >


  export type PrestadorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_prestador?: boolean
    codigo?: boolean
    razon_social?: boolean
    consecutivo?: boolean
    servicio?: boolean | Prestador$servicioArgs<ExtArgs>
    empleado?: boolean | Prestador$empleadoArgs<ExtArgs>
    _count?: boolean | PrestadorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prestador"]>


  export type PrestadorSelectScalar = {
    id_prestador?: boolean
    codigo?: boolean
    razon_social?: boolean
    consecutivo?: boolean
  }

  export type PrestadorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Prestador$servicioArgs<ExtArgs>
    empleado?: boolean | Prestador$empleadoArgs<ExtArgs>
    _count?: boolean | PrestadorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PrestadorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prestador"
    objects: {
      servicio: Prisma.$ServicioPayload<ExtArgs>[]
      empleado: Prisma.$EmpleadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_prestador: number
      codigo: bigint
      razon_social: string
      consecutivo: number
    }, ExtArgs["result"]["prestador"]>
    composites: {}
  }

  type PrestadorGetPayload<S extends boolean | null | undefined | PrestadorDefaultArgs> = $Result.GetResult<Prisma.$PrestadorPayload, S>

  type PrestadorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrestadorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrestadorCountAggregateInputType | true
    }

  export interface PrestadorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prestador'], meta: { name: 'Prestador' } }
    /**
     * Find zero or one Prestador that matches the filter.
     * @param {PrestadorFindUniqueArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrestadorFindUniqueArgs>(args: SelectSubset<T, PrestadorFindUniqueArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prestador that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrestadorFindUniqueOrThrowArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrestadorFindUniqueOrThrowArgs>(args: SelectSubset<T, PrestadorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prestador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindFirstArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrestadorFindFirstArgs>(args?: SelectSubset<T, PrestadorFindFirstArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prestador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindFirstOrThrowArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrestadorFindFirstOrThrowArgs>(args?: SelectSubset<T, PrestadorFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prestadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prestadors
     * const prestadors = await prisma.prestador.findMany()
     * 
     * // Get first 10 Prestadors
     * const prestadors = await prisma.prestador.findMany({ take: 10 })
     * 
     * // Only select the `id_prestador`
     * const prestadorWithId_prestadorOnly = await prisma.prestador.findMany({ select: { id_prestador: true } })
     * 
     */
    findMany<T extends PrestadorFindManyArgs>(args?: SelectSubset<T, PrestadorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prestador.
     * @param {PrestadorCreateArgs} args - Arguments to create a Prestador.
     * @example
     * // Create one Prestador
     * const Prestador = await prisma.prestador.create({
     *   data: {
     *     // ... data to create a Prestador
     *   }
     * })
     * 
     */
    create<T extends PrestadorCreateArgs>(args: SelectSubset<T, PrestadorCreateArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prestadors.
     * @param {PrestadorCreateManyArgs} args - Arguments to create many Prestadors.
     * @example
     * // Create many Prestadors
     * const prestador = await prisma.prestador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrestadorCreateManyArgs>(args?: SelectSubset<T, PrestadorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prestador.
     * @param {PrestadorDeleteArgs} args - Arguments to delete one Prestador.
     * @example
     * // Delete one Prestador
     * const Prestador = await prisma.prestador.delete({
     *   where: {
     *     // ... filter to delete one Prestador
     *   }
     * })
     * 
     */
    delete<T extends PrestadorDeleteArgs>(args: SelectSubset<T, PrestadorDeleteArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prestador.
     * @param {PrestadorUpdateArgs} args - Arguments to update one Prestador.
     * @example
     * // Update one Prestador
     * const prestador = await prisma.prestador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrestadorUpdateArgs>(args: SelectSubset<T, PrestadorUpdateArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prestadors.
     * @param {PrestadorDeleteManyArgs} args - Arguments to filter Prestadors to delete.
     * @example
     * // Delete a few Prestadors
     * const { count } = await prisma.prestador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrestadorDeleteManyArgs>(args?: SelectSubset<T, PrestadorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prestadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prestadors
     * const prestador = await prisma.prestador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrestadorUpdateManyArgs>(args: SelectSubset<T, PrestadorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prestador.
     * @param {PrestadorUpsertArgs} args - Arguments to update or create a Prestador.
     * @example
     * // Update or create a Prestador
     * const prestador = await prisma.prestador.upsert({
     *   create: {
     *     // ... data to create a Prestador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prestador we want to update
     *   }
     * })
     */
    upsert<T extends PrestadorUpsertArgs>(args: SelectSubset<T, PrestadorUpsertArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prestadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorCountArgs} args - Arguments to filter Prestadors to count.
     * @example
     * // Count the number of Prestadors
     * const count = await prisma.prestador.count({
     *   where: {
     *     // ... the filter for the Prestadors we want to count
     *   }
     * })
    **/
    count<T extends PrestadorCountArgs>(
      args?: Subset<T, PrestadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrestadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prestador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrestadorAggregateArgs>(args: Subset<T, PrestadorAggregateArgs>): Prisma.PrismaPromise<GetPrestadorAggregateType<T>>

    /**
     * Group by Prestador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrestadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrestadorGroupByArgs['orderBy'] }
        : { orderBy?: PrestadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrestadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prestador model
   */
  readonly fields: PrestadorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prestador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrestadorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends Prestador$servicioArgs<ExtArgs> = {}>(args?: Subset<T, Prestador$servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany"> | Null>
    empleado<T extends Prestador$empleadoArgs<ExtArgs> = {}>(args?: Subset<T, Prestador$empleadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prestador model
   */ 
  interface PrestadorFieldRefs {
    readonly id_prestador: FieldRef<"Prestador", 'Int'>
    readonly codigo: FieldRef<"Prestador", 'BigInt'>
    readonly razon_social: FieldRef<"Prestador", 'String'>
    readonly consecutivo: FieldRef<"Prestador", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Prestador findUnique
   */
  export type PrestadorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador findUniqueOrThrow
   */
  export type PrestadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador findFirst
   */
  export type PrestadorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prestadors.
     */
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador findFirstOrThrow
   */
  export type PrestadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestador to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prestadors.
     */
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador findMany
   */
  export type PrestadorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter, which Prestadors to fetch.
     */
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     */
    orderBy?: PrestadorOrderByWithRelationInput | PrestadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prestadors.
     */
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     */
    skip?: number
    distinct?: PrestadorScalarFieldEnum | PrestadorScalarFieldEnum[]
  }

  /**
   * Prestador create
   */
  export type PrestadorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The data needed to create a Prestador.
     */
    data: XOR<PrestadorCreateInput, PrestadorUncheckedCreateInput>
  }

  /**
   * Prestador createMany
   */
  export type PrestadorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prestadors.
     */
    data: PrestadorCreateManyInput | PrestadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prestador update
   */
  export type PrestadorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The data needed to update a Prestador.
     */
    data: XOR<PrestadorUpdateInput, PrestadorUncheckedUpdateInput>
    /**
     * Choose, which Prestador to update.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador updateMany
   */
  export type PrestadorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prestadors.
     */
    data: XOR<PrestadorUpdateManyMutationInput, PrestadorUncheckedUpdateManyInput>
    /**
     * Filter which Prestadors to update
     */
    where?: PrestadorWhereInput
  }

  /**
   * Prestador upsert
   */
  export type PrestadorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * The filter to search for the Prestador to update in case it exists.
     */
    where: PrestadorWhereUniqueInput
    /**
     * In case the Prestador found by the `where` argument doesn't exist, create a new Prestador with this data.
     */
    create: XOR<PrestadorCreateInput, PrestadorUncheckedCreateInput>
    /**
     * In case the Prestador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrestadorUpdateInput, PrestadorUncheckedUpdateInput>
  }

  /**
   * Prestador delete
   */
  export type PrestadorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
    /**
     * Filter which Prestador to delete.
     */
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador deleteMany
   */
  export type PrestadorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prestadors to delete
     */
    where?: PrestadorWhereInput
  }

  /**
   * Prestador.servicio
   */
  export type Prestador$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    cursor?: ServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Prestador.empleado
   */
  export type Prestador$empleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    where?: EmpleadoWhereInput
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    cursor?: EmpleadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }

  /**
   * Prestador without action
   */
  export type PrestadorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prestador
     */
    select?: PrestadorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrestadorInclude<ExtArgs> | null
  }


  /**
   * Model Empleado
   */

  export type AggregateEmpleado = {
    _count: EmpleadoCountAggregateOutputType | null
    _avg: EmpleadoAvgAggregateOutputType | null
    _sum: EmpleadoSumAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  export type EmpleadoAvgAggregateOutputType = {
    id_empleado: number | null
    identificacion: number | null
    prestador: number | null
  }

  export type EmpleadoSumAggregateOutputType = {
    id_empleado: number | null
    identificacion: bigint | null
    prestador: number | null
  }

  export type EmpleadoMinAggregateOutputType = {
    id_empleado: number | null
    identificacion: bigint | null
    nombre: string | null
    cargo: string | null
    rol: $Enums.Rol | null
    password: string | null
    prestador: number | null
  }

  export type EmpleadoMaxAggregateOutputType = {
    id_empleado: number | null
    identificacion: bigint | null
    nombre: string | null
    cargo: string | null
    rol: $Enums.Rol | null
    password: string | null
    prestador: number | null
  }

  export type EmpleadoCountAggregateOutputType = {
    id_empleado: number
    identificacion: number
    nombre: number
    cargo: number
    rol: number
    password: number
    prestador: number
    _all: number
  }


  export type EmpleadoAvgAggregateInputType = {
    id_empleado?: true
    identificacion?: true
    prestador?: true
  }

  export type EmpleadoSumAggregateInputType = {
    id_empleado?: true
    identificacion?: true
    prestador?: true
  }

  export type EmpleadoMinAggregateInputType = {
    id_empleado?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    password?: true
    prestador?: true
  }

  export type EmpleadoMaxAggregateInputType = {
    id_empleado?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    password?: true
    prestador?: true
  }

  export type EmpleadoCountAggregateInputType = {
    id_empleado?: true
    identificacion?: true
    nombre?: true
    cargo?: true
    rol?: true
    password?: true
    prestador?: true
    _all?: true
  }

  export type EmpleadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empleado to aggregate.
     */
    where?: EmpleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     */
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empleados
    **/
    _count?: true | EmpleadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpleadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpleadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadoMaxAggregateInputType
  }

  export type GetEmpleadoAggregateType<T extends EmpleadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleado[P]>
      : GetScalarType<T[P], AggregateEmpleado[P]>
  }




  export type EmpleadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpleadoWhereInput
    orderBy?: EmpleadoOrderByWithAggregationInput | EmpleadoOrderByWithAggregationInput[]
    by: EmpleadoScalarFieldEnum[] | EmpleadoScalarFieldEnum
    having?: EmpleadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadoCountAggregateInputType | true
    _avg?: EmpleadoAvgAggregateInputType
    _sum?: EmpleadoSumAggregateInputType
    _min?: EmpleadoMinAggregateInputType
    _max?: EmpleadoMaxAggregateInputType
  }

  export type EmpleadoGroupByOutputType = {
    id_empleado: number
    identificacion: bigint
    nombre: string
    cargo: string
    rol: $Enums.Rol
    password: string
    prestador: number
    _count: EmpleadoCountAggregateOutputType | null
    _avg: EmpleadoAvgAggregateOutputType | null
    _sum: EmpleadoSumAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  type GetEmpleadoGroupByPayload<T extends EmpleadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpleadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
        }
      >
    >


  export type EmpleadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empleado?: boolean
    identificacion?: boolean
    nombre?: boolean
    cargo?: boolean
    rol?: boolean
    password?: boolean
    prestador?: boolean
    Pretador_Empleado?: boolean | PrestadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empleado"]>


  export type EmpleadoSelectScalar = {
    id_empleado?: boolean
    identificacion?: boolean
    nombre?: boolean
    cargo?: boolean
    rol?: boolean
    password?: boolean
    prestador?: boolean
  }

  export type EmpleadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Pretador_Empleado?: boolean | PrestadorDefaultArgs<ExtArgs>
  }

  export type $EmpleadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empleado"
    objects: {
      Pretador_Empleado: Prisma.$PrestadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_empleado: number
      identificacion: bigint
      nombre: string
      cargo: string
      rol: $Enums.Rol
      password: string
      prestador: number
    }, ExtArgs["result"]["empleado"]>
    composites: {}
  }

  type EmpleadoGetPayload<S extends boolean | null | undefined | EmpleadoDefaultArgs> = $Result.GetResult<Prisma.$EmpleadoPayload, S>

  type EmpleadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpleadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpleadoCountAggregateInputType | true
    }

  export interface EmpleadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empleado'], meta: { name: 'Empleado' } }
    /**
     * Find zero or one Empleado that matches the filter.
     * @param {EmpleadoFindUniqueArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpleadoFindUniqueArgs>(args: SelectSubset<T, EmpleadoFindUniqueArgs<ExtArgs>>): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empleado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpleadoFindUniqueOrThrowArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpleadoFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpleadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empleado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoFindFirstArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpleadoFindFirstArgs>(args?: SelectSubset<T, EmpleadoFindFirstArgs<ExtArgs>>): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empleado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoFindFirstOrThrowArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpleadoFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpleadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleados
     * const empleados = await prisma.empleado.findMany()
     * 
     * // Get first 10 Empleados
     * const empleados = await prisma.empleado.findMany({ take: 10 })
     * 
     * // Only select the `id_empleado`
     * const empleadoWithId_empleadoOnly = await prisma.empleado.findMany({ select: { id_empleado: true } })
     * 
     */
    findMany<T extends EmpleadoFindManyArgs>(args?: SelectSubset<T, EmpleadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empleado.
     * @param {EmpleadoCreateArgs} args - Arguments to create a Empleado.
     * @example
     * // Create one Empleado
     * const Empleado = await prisma.empleado.create({
     *   data: {
     *     // ... data to create a Empleado
     *   }
     * })
     * 
     */
    create<T extends EmpleadoCreateArgs>(args: SelectSubset<T, EmpleadoCreateArgs<ExtArgs>>): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empleados.
     * @param {EmpleadoCreateManyArgs} args - Arguments to create many Empleados.
     * @example
     * // Create many Empleados
     * const empleado = await prisma.empleado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpleadoCreateManyArgs>(args?: SelectSubset<T, EmpleadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empleado.
     * @param {EmpleadoDeleteArgs} args - Arguments to delete one Empleado.
     * @example
     * // Delete one Empleado
     * const Empleado = await prisma.empleado.delete({
     *   where: {
     *     // ... filter to delete one Empleado
     *   }
     * })
     * 
     */
    delete<T extends EmpleadoDeleteArgs>(args: SelectSubset<T, EmpleadoDeleteArgs<ExtArgs>>): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empleado.
     * @param {EmpleadoUpdateArgs} args - Arguments to update one Empleado.
     * @example
     * // Update one Empleado
     * const empleado = await prisma.empleado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpleadoUpdateArgs>(args: SelectSubset<T, EmpleadoUpdateArgs<ExtArgs>>): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empleados.
     * @param {EmpleadoDeleteManyArgs} args - Arguments to filter Empleados to delete.
     * @example
     * // Delete a few Empleados
     * const { count } = await prisma.empleado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpleadoDeleteManyArgs>(args?: SelectSubset<T, EmpleadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleados
     * const empleado = await prisma.empleado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpleadoUpdateManyArgs>(args: SelectSubset<T, EmpleadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleado.
     * @param {EmpleadoUpsertArgs} args - Arguments to update or create a Empleado.
     * @example
     * // Update or create a Empleado
     * const empleado = await prisma.empleado.upsert({
     *   create: {
     *     // ... data to create a Empleado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleado we want to update
     *   }
     * })
     */
    upsert<T extends EmpleadoUpsertArgs>(args: SelectSubset<T, EmpleadoUpsertArgs<ExtArgs>>): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoCountArgs} args - Arguments to filter Empleados to count.
     * @example
     * // Count the number of Empleados
     * const count = await prisma.empleado.count({
     *   where: {
     *     // ... the filter for the Empleados we want to count
     *   }
     * })
    **/
    count<T extends EmpleadoCountArgs>(
      args?: Subset<T, EmpleadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadoAggregateArgs>(args: Subset<T, EmpleadoAggregateArgs>): Prisma.PrismaPromise<GetEmpleadoAggregateType<T>>

    /**
     * Group by Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpleadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpleadoGroupByArgs['orderBy'] }
        : { orderBy?: EmpleadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpleadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empleado model
   */
  readonly fields: EmpleadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empleado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpleadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Pretador_Empleado<T extends PrestadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrestadorDefaultArgs<ExtArgs>>): Prisma__PrestadorClient<$Result.GetResult<Prisma.$PrestadorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empleado model
   */ 
  interface EmpleadoFieldRefs {
    readonly id_empleado: FieldRef<"Empleado", 'Int'>
    readonly identificacion: FieldRef<"Empleado", 'BigInt'>
    readonly nombre: FieldRef<"Empleado", 'String'>
    readonly cargo: FieldRef<"Empleado", 'String'>
    readonly rol: FieldRef<"Empleado", 'Rol'>
    readonly password: FieldRef<"Empleado", 'String'>
    readonly prestador: FieldRef<"Empleado", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Empleado findUnique
   */
  export type EmpleadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * Filter, which Empleado to fetch.
     */
    where: EmpleadoWhereUniqueInput
  }

  /**
   * Empleado findUniqueOrThrow
   */
  export type EmpleadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * Filter, which Empleado to fetch.
     */
    where: EmpleadoWhereUniqueInput
  }

  /**
   * Empleado findFirst
   */
  export type EmpleadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * Filter, which Empleado to fetch.
     */
    where?: EmpleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     */
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empleados.
     */
    cursor?: EmpleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empleados.
     */
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }

  /**
   * Empleado findFirstOrThrow
   */
  export type EmpleadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * Filter, which Empleado to fetch.
     */
    where?: EmpleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     */
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empleados.
     */
    cursor?: EmpleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empleados.
     */
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }

  /**
   * Empleado findMany
   */
  export type EmpleadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * Filter, which Empleados to fetch.
     */
    where?: EmpleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     */
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empleados.
     */
    cursor?: EmpleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     */
    skip?: number
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }

  /**
   * Empleado create
   */
  export type EmpleadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * The data needed to create a Empleado.
     */
    data: XOR<EmpleadoCreateInput, EmpleadoUncheckedCreateInput>
  }

  /**
   * Empleado createMany
   */
  export type EmpleadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empleados.
     */
    data: EmpleadoCreateManyInput | EmpleadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empleado update
   */
  export type EmpleadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * The data needed to update a Empleado.
     */
    data: XOR<EmpleadoUpdateInput, EmpleadoUncheckedUpdateInput>
    /**
     * Choose, which Empleado to update.
     */
    where: EmpleadoWhereUniqueInput
  }

  /**
   * Empleado updateMany
   */
  export type EmpleadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empleados.
     */
    data: XOR<EmpleadoUpdateManyMutationInput, EmpleadoUncheckedUpdateManyInput>
    /**
     * Filter which Empleados to update
     */
    where?: EmpleadoWhereInput
  }

  /**
   * Empleado upsert
   */
  export type EmpleadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * The filter to search for the Empleado to update in case it exists.
     */
    where: EmpleadoWhereUniqueInput
    /**
     * In case the Empleado found by the `where` argument doesn't exist, create a new Empleado with this data.
     */
    create: XOR<EmpleadoCreateInput, EmpleadoUncheckedCreateInput>
    /**
     * In case the Empleado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpleadoUpdateInput, EmpleadoUncheckedUpdateInput>
  }

  /**
   * Empleado delete
   */
  export type EmpleadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
    /**
     * Filter which Empleado to delete.
     */
    where: EmpleadoWhereUniqueInput
  }

  /**
   * Empleado deleteMany
   */
  export type EmpleadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empleados to delete
     */
    where?: EmpleadoWhereInput
  }

  /**
   * Empleado without action
   */
  export type EmpleadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadoInclude<ExtArgs> | null
  }


  /**
   * Model Tarifa
   */

  export type AggregateTarifa = {
    _count: TarifaCountAggregateOutputType | null
    _avg: TarifaAvgAggregateOutputType | null
    _sum: TarifaSumAggregateOutputType | null
    _min: TarifaMinAggregateOutputType | null
    _max: TarifaMaxAggregateOutputType | null
  }

  export type TarifaAvgAggregateOutputType = {
    id_tarifa: number | null
    precio: Decimal | null
  }

  export type TarifaSumAggregateOutputType = {
    id_tarifa: number | null
    precio: Decimal | null
  }

  export type TarifaMinAggregateOutputType = {
    id_tarifa: number | null
    nombre: string | null
    precio: Decimal | null
    estado: $Enums.Estado | null
  }

  export type TarifaMaxAggregateOutputType = {
    id_tarifa: number | null
    nombre: string | null
    precio: Decimal | null
    estado: $Enums.Estado | null
  }

  export type TarifaCountAggregateOutputType = {
    id_tarifa: number
    nombre: number
    precio: number
    estado: number
    _all: number
  }


  export type TarifaAvgAggregateInputType = {
    id_tarifa?: true
    precio?: true
  }

  export type TarifaSumAggregateInputType = {
    id_tarifa?: true
    precio?: true
  }

  export type TarifaMinAggregateInputType = {
    id_tarifa?: true
    nombre?: true
    precio?: true
    estado?: true
  }

  export type TarifaMaxAggregateInputType = {
    id_tarifa?: true
    nombre?: true
    precio?: true
    estado?: true
  }

  export type TarifaCountAggregateInputType = {
    id_tarifa?: true
    nombre?: true
    precio?: true
    estado?: true
    _all?: true
  }

  export type TarifaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tarifa to aggregate.
     */
    where?: TarifaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifas to fetch.
     */
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TarifaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tarifas
    **/
    _count?: true | TarifaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TarifaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TarifaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TarifaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TarifaMaxAggregateInputType
  }

  export type GetTarifaAggregateType<T extends TarifaAggregateArgs> = {
        [P in keyof T & keyof AggregateTarifa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarifa[P]>
      : GetScalarType<T[P], AggregateTarifa[P]>
  }




  export type TarifaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TarifaWhereInput
    orderBy?: TarifaOrderByWithAggregationInput | TarifaOrderByWithAggregationInput[]
    by: TarifaScalarFieldEnum[] | TarifaScalarFieldEnum
    having?: TarifaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TarifaCountAggregateInputType | true
    _avg?: TarifaAvgAggregateInputType
    _sum?: TarifaSumAggregateInputType
    _min?: TarifaMinAggregateInputType
    _max?: TarifaMaxAggregateInputType
  }

  export type TarifaGroupByOutputType = {
    id_tarifa: number
    nombre: string
    precio: Decimal
    estado: $Enums.Estado
    _count: TarifaCountAggregateOutputType | null
    _avg: TarifaAvgAggregateOutputType | null
    _sum: TarifaSumAggregateOutputType | null
    _min: TarifaMinAggregateOutputType | null
    _max: TarifaMaxAggregateOutputType | null
  }

  type GetTarifaGroupByPayload<T extends TarifaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TarifaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TarifaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TarifaGroupByOutputType[P]>
            : GetScalarType<T[P], TarifaGroupByOutputType[P]>
        }
      >
    >


  export type TarifaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tarifa?: boolean
    nombre?: boolean
    precio?: boolean
    estado?: boolean
    servicio?: boolean | Tarifa$servicioArgs<ExtArgs>
    acuerdo?: boolean | Tarifa$acuerdoArgs<ExtArgs>
    _count?: boolean | TarifaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tarifa"]>


  export type TarifaSelectScalar = {
    id_tarifa?: boolean
    nombre?: boolean
    precio?: boolean
    estado?: boolean
  }

  export type TarifaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Tarifa$servicioArgs<ExtArgs>
    acuerdo?: boolean | Tarifa$acuerdoArgs<ExtArgs>
    _count?: boolean | TarifaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TarifaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tarifa"
    objects: {
      servicio: Prisma.$ServicioPayload<ExtArgs>[]
      acuerdo: Prisma.$AcuerdoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tarifa: number
      nombre: string
      precio: Prisma.Decimal
      estado: $Enums.Estado
    }, ExtArgs["result"]["tarifa"]>
    composites: {}
  }

  type TarifaGetPayload<S extends boolean | null | undefined | TarifaDefaultArgs> = $Result.GetResult<Prisma.$TarifaPayload, S>

  type TarifaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TarifaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TarifaCountAggregateInputType | true
    }

  export interface TarifaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tarifa'], meta: { name: 'Tarifa' } }
    /**
     * Find zero or one Tarifa that matches the filter.
     * @param {TarifaFindUniqueArgs} args - Arguments to find a Tarifa
     * @example
     * // Get one Tarifa
     * const tarifa = await prisma.tarifa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TarifaFindUniqueArgs>(args: SelectSubset<T, TarifaFindUniqueArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tarifa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TarifaFindUniqueOrThrowArgs} args - Arguments to find a Tarifa
     * @example
     * // Get one Tarifa
     * const tarifa = await prisma.tarifa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TarifaFindUniqueOrThrowArgs>(args: SelectSubset<T, TarifaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tarifa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaFindFirstArgs} args - Arguments to find a Tarifa
     * @example
     * // Get one Tarifa
     * const tarifa = await prisma.tarifa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TarifaFindFirstArgs>(args?: SelectSubset<T, TarifaFindFirstArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tarifa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaFindFirstOrThrowArgs} args - Arguments to find a Tarifa
     * @example
     * // Get one Tarifa
     * const tarifa = await prisma.tarifa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TarifaFindFirstOrThrowArgs>(args?: SelectSubset<T, TarifaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tarifas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tarifas
     * const tarifas = await prisma.tarifa.findMany()
     * 
     * // Get first 10 Tarifas
     * const tarifas = await prisma.tarifa.findMany({ take: 10 })
     * 
     * // Only select the `id_tarifa`
     * const tarifaWithId_tarifaOnly = await prisma.tarifa.findMany({ select: { id_tarifa: true } })
     * 
     */
    findMany<T extends TarifaFindManyArgs>(args?: SelectSubset<T, TarifaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tarifa.
     * @param {TarifaCreateArgs} args - Arguments to create a Tarifa.
     * @example
     * // Create one Tarifa
     * const Tarifa = await prisma.tarifa.create({
     *   data: {
     *     // ... data to create a Tarifa
     *   }
     * })
     * 
     */
    create<T extends TarifaCreateArgs>(args: SelectSubset<T, TarifaCreateArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tarifas.
     * @param {TarifaCreateManyArgs} args - Arguments to create many Tarifas.
     * @example
     * // Create many Tarifas
     * const tarifa = await prisma.tarifa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TarifaCreateManyArgs>(args?: SelectSubset<T, TarifaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tarifa.
     * @param {TarifaDeleteArgs} args - Arguments to delete one Tarifa.
     * @example
     * // Delete one Tarifa
     * const Tarifa = await prisma.tarifa.delete({
     *   where: {
     *     // ... filter to delete one Tarifa
     *   }
     * })
     * 
     */
    delete<T extends TarifaDeleteArgs>(args: SelectSubset<T, TarifaDeleteArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tarifa.
     * @param {TarifaUpdateArgs} args - Arguments to update one Tarifa.
     * @example
     * // Update one Tarifa
     * const tarifa = await prisma.tarifa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TarifaUpdateArgs>(args: SelectSubset<T, TarifaUpdateArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tarifas.
     * @param {TarifaDeleteManyArgs} args - Arguments to filter Tarifas to delete.
     * @example
     * // Delete a few Tarifas
     * const { count } = await prisma.tarifa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TarifaDeleteManyArgs>(args?: SelectSubset<T, TarifaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tarifas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tarifas
     * const tarifa = await prisma.tarifa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TarifaUpdateManyArgs>(args: SelectSubset<T, TarifaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tarifa.
     * @param {TarifaUpsertArgs} args - Arguments to update or create a Tarifa.
     * @example
     * // Update or create a Tarifa
     * const tarifa = await prisma.tarifa.upsert({
     *   create: {
     *     // ... data to create a Tarifa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tarifa we want to update
     *   }
     * })
     */
    upsert<T extends TarifaUpsertArgs>(args: SelectSubset<T, TarifaUpsertArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tarifas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaCountArgs} args - Arguments to filter Tarifas to count.
     * @example
     * // Count the number of Tarifas
     * const count = await prisma.tarifa.count({
     *   where: {
     *     // ... the filter for the Tarifas we want to count
     *   }
     * })
    **/
    count<T extends TarifaCountArgs>(
      args?: Subset<T, TarifaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TarifaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tarifa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TarifaAggregateArgs>(args: Subset<T, TarifaAggregateArgs>): Prisma.PrismaPromise<GetTarifaAggregateType<T>>

    /**
     * Group by Tarifa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarifaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TarifaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TarifaGroupByArgs['orderBy'] }
        : { orderBy?: TarifaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TarifaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTarifaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tarifa model
   */
  readonly fields: TarifaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tarifa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TarifaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends Tarifa$servicioArgs<ExtArgs> = {}>(args?: Subset<T, Tarifa$servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany"> | Null>
    acuerdo<T extends Tarifa$acuerdoArgs<ExtArgs> = {}>(args?: Subset<T, Tarifa$acuerdoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tarifa model
   */ 
  interface TarifaFieldRefs {
    readonly id_tarifa: FieldRef<"Tarifa", 'Int'>
    readonly nombre: FieldRef<"Tarifa", 'String'>
    readonly precio: FieldRef<"Tarifa", 'Decimal'>
    readonly estado: FieldRef<"Tarifa", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Tarifa findUnique
   */
  export type TarifaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifa to fetch.
     */
    where: TarifaWhereUniqueInput
  }

  /**
   * Tarifa findUniqueOrThrow
   */
  export type TarifaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifa to fetch.
     */
    where: TarifaWhereUniqueInput
  }

  /**
   * Tarifa findFirst
   */
  export type TarifaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifa to fetch.
     */
    where?: TarifaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifas to fetch.
     */
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tarifas.
     */
    cursor?: TarifaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tarifas.
     */
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Tarifa findFirstOrThrow
   */
  export type TarifaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifa to fetch.
     */
    where?: TarifaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifas to fetch.
     */
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tarifas.
     */
    cursor?: TarifaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tarifas.
     */
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Tarifa findMany
   */
  export type TarifaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter, which Tarifas to fetch.
     */
    where?: TarifaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tarifas to fetch.
     */
    orderBy?: TarifaOrderByWithRelationInput | TarifaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tarifas.
     */
    cursor?: TarifaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tarifas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tarifas.
     */
    skip?: number
    distinct?: TarifaScalarFieldEnum | TarifaScalarFieldEnum[]
  }

  /**
   * Tarifa create
   */
  export type TarifaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * The data needed to create a Tarifa.
     */
    data: XOR<TarifaCreateInput, TarifaUncheckedCreateInput>
  }

  /**
   * Tarifa createMany
   */
  export type TarifaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tarifas.
     */
    data: TarifaCreateManyInput | TarifaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tarifa update
   */
  export type TarifaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * The data needed to update a Tarifa.
     */
    data: XOR<TarifaUpdateInput, TarifaUncheckedUpdateInput>
    /**
     * Choose, which Tarifa to update.
     */
    where: TarifaWhereUniqueInput
  }

  /**
   * Tarifa updateMany
   */
  export type TarifaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tarifas.
     */
    data: XOR<TarifaUpdateManyMutationInput, TarifaUncheckedUpdateManyInput>
    /**
     * Filter which Tarifas to update
     */
    where?: TarifaWhereInput
  }

  /**
   * Tarifa upsert
   */
  export type TarifaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * The filter to search for the Tarifa to update in case it exists.
     */
    where: TarifaWhereUniqueInput
    /**
     * In case the Tarifa found by the `where` argument doesn't exist, create a new Tarifa with this data.
     */
    create: XOR<TarifaCreateInput, TarifaUncheckedCreateInput>
    /**
     * In case the Tarifa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TarifaUpdateInput, TarifaUncheckedUpdateInput>
  }

  /**
   * Tarifa delete
   */
  export type TarifaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
    /**
     * Filter which Tarifa to delete.
     */
    where: TarifaWhereUniqueInput
  }

  /**
   * Tarifa deleteMany
   */
  export type TarifaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tarifas to delete
     */
    where?: TarifaWhereInput
  }

  /**
   * Tarifa.servicio
   */
  export type Tarifa$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    cursor?: ServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Tarifa.acuerdo
   */
  export type Tarifa$acuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    where?: AcuerdoWhereInput
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    cursor?: AcuerdoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Tarifa without action
   */
  export type TarifaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tarifa
     */
    select?: TarifaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TarifaInclude<ExtArgs> | null
  }


  /**
   * Model Protocolo
   */

  export type AggregateProtocolo = {
    _count: ProtocoloCountAggregateOutputType | null
    _avg: ProtocoloAvgAggregateOutputType | null
    _sum: ProtocoloSumAggregateOutputType | null
    _min: ProtocoloMinAggregateOutputType | null
    _max: ProtocoloMaxAggregateOutputType | null
  }

  export type ProtocoloAvgAggregateOutputType = {
    id_protocolo: number | null
  }

  export type ProtocoloSumAggregateOutputType = {
    id_protocolo: number | null
  }

  export type ProtocoloMinAggregateOutputType = {
    id_protocolo: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type ProtocoloMaxAggregateOutputType = {
    id_protocolo: number | null
    nombre: string | null
    estado: $Enums.Estado | null
  }

  export type ProtocoloCountAggregateOutputType = {
    id_protocolo: number
    nombre: number
    estado: number
    _all: number
  }


  export type ProtocoloAvgAggregateInputType = {
    id_protocolo?: true
  }

  export type ProtocoloSumAggregateInputType = {
    id_protocolo?: true
  }

  export type ProtocoloMinAggregateInputType = {
    id_protocolo?: true
    nombre?: true
    estado?: true
  }

  export type ProtocoloMaxAggregateInputType = {
    id_protocolo?: true
    nombre?: true
    estado?: true
  }

  export type ProtocoloCountAggregateInputType = {
    id_protocolo?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type ProtocoloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Protocolo to aggregate.
     */
    where?: ProtocoloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocolos to fetch.
     */
    orderBy?: ProtocoloOrderByWithRelationInput | ProtocoloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProtocoloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocolos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocolos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Protocolos
    **/
    _count?: true | ProtocoloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProtocoloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProtocoloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProtocoloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProtocoloMaxAggregateInputType
  }

  export type GetProtocoloAggregateType<T extends ProtocoloAggregateArgs> = {
        [P in keyof T & keyof AggregateProtocolo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtocolo[P]>
      : GetScalarType<T[P], AggregateProtocolo[P]>
  }




  export type ProtocoloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProtocoloWhereInput
    orderBy?: ProtocoloOrderByWithAggregationInput | ProtocoloOrderByWithAggregationInput[]
    by: ProtocoloScalarFieldEnum[] | ProtocoloScalarFieldEnum
    having?: ProtocoloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProtocoloCountAggregateInputType | true
    _avg?: ProtocoloAvgAggregateInputType
    _sum?: ProtocoloSumAggregateInputType
    _min?: ProtocoloMinAggregateInputType
    _max?: ProtocoloMaxAggregateInputType
  }

  export type ProtocoloGroupByOutputType = {
    id_protocolo: number
    nombre: string
    estado: $Enums.Estado
    _count: ProtocoloCountAggregateOutputType | null
    _avg: ProtocoloAvgAggregateOutputType | null
    _sum: ProtocoloSumAggregateOutputType | null
    _min: ProtocoloMinAggregateOutputType | null
    _max: ProtocoloMaxAggregateOutputType | null
  }

  type GetProtocoloGroupByPayload<T extends ProtocoloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProtocoloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProtocoloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProtocoloGroupByOutputType[P]>
            : GetScalarType<T[P], ProtocoloGroupByOutputType[P]>
        }
      >
    >


  export type ProtocoloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_protocolo?: boolean
    nombre?: boolean
    estado?: boolean
    servicio?: boolean | Protocolo$servicioArgs<ExtArgs>
    _count?: boolean | ProtocoloCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["protocolo"]>


  export type ProtocoloSelectScalar = {
    id_protocolo?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type ProtocoloInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | Protocolo$servicioArgs<ExtArgs>
    _count?: boolean | ProtocoloCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProtocoloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Protocolo"
    objects: {
      servicio: Prisma.$ServicioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_protocolo: number
      nombre: string
      estado: $Enums.Estado
    }, ExtArgs["result"]["protocolo"]>
    composites: {}
  }

  type ProtocoloGetPayload<S extends boolean | null | undefined | ProtocoloDefaultArgs> = $Result.GetResult<Prisma.$ProtocoloPayload, S>

  type ProtocoloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProtocoloFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProtocoloCountAggregateInputType | true
    }

  export interface ProtocoloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Protocolo'], meta: { name: 'Protocolo' } }
    /**
     * Find zero or one Protocolo that matches the filter.
     * @param {ProtocoloFindUniqueArgs} args - Arguments to find a Protocolo
     * @example
     * // Get one Protocolo
     * const protocolo = await prisma.protocolo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProtocoloFindUniqueArgs>(args: SelectSubset<T, ProtocoloFindUniqueArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Protocolo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProtocoloFindUniqueOrThrowArgs} args - Arguments to find a Protocolo
     * @example
     * // Get one Protocolo
     * const protocolo = await prisma.protocolo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProtocoloFindUniqueOrThrowArgs>(args: SelectSubset<T, ProtocoloFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Protocolo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocoloFindFirstArgs} args - Arguments to find a Protocolo
     * @example
     * // Get one Protocolo
     * const protocolo = await prisma.protocolo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProtocoloFindFirstArgs>(args?: SelectSubset<T, ProtocoloFindFirstArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Protocolo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocoloFindFirstOrThrowArgs} args - Arguments to find a Protocolo
     * @example
     * // Get one Protocolo
     * const protocolo = await prisma.protocolo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProtocoloFindFirstOrThrowArgs>(args?: SelectSubset<T, ProtocoloFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Protocolos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocoloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Protocolos
     * const protocolos = await prisma.protocolo.findMany()
     * 
     * // Get first 10 Protocolos
     * const protocolos = await prisma.protocolo.findMany({ take: 10 })
     * 
     * // Only select the `id_protocolo`
     * const protocoloWithId_protocoloOnly = await prisma.protocolo.findMany({ select: { id_protocolo: true } })
     * 
     */
    findMany<T extends ProtocoloFindManyArgs>(args?: SelectSubset<T, ProtocoloFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Protocolo.
     * @param {ProtocoloCreateArgs} args - Arguments to create a Protocolo.
     * @example
     * // Create one Protocolo
     * const Protocolo = await prisma.protocolo.create({
     *   data: {
     *     // ... data to create a Protocolo
     *   }
     * })
     * 
     */
    create<T extends ProtocoloCreateArgs>(args: SelectSubset<T, ProtocoloCreateArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Protocolos.
     * @param {ProtocoloCreateManyArgs} args - Arguments to create many Protocolos.
     * @example
     * // Create many Protocolos
     * const protocolo = await prisma.protocolo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProtocoloCreateManyArgs>(args?: SelectSubset<T, ProtocoloCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Protocolo.
     * @param {ProtocoloDeleteArgs} args - Arguments to delete one Protocolo.
     * @example
     * // Delete one Protocolo
     * const Protocolo = await prisma.protocolo.delete({
     *   where: {
     *     // ... filter to delete one Protocolo
     *   }
     * })
     * 
     */
    delete<T extends ProtocoloDeleteArgs>(args: SelectSubset<T, ProtocoloDeleteArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Protocolo.
     * @param {ProtocoloUpdateArgs} args - Arguments to update one Protocolo.
     * @example
     * // Update one Protocolo
     * const protocolo = await prisma.protocolo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProtocoloUpdateArgs>(args: SelectSubset<T, ProtocoloUpdateArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Protocolos.
     * @param {ProtocoloDeleteManyArgs} args - Arguments to filter Protocolos to delete.
     * @example
     * // Delete a few Protocolos
     * const { count } = await prisma.protocolo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProtocoloDeleteManyArgs>(args?: SelectSubset<T, ProtocoloDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Protocolos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocoloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Protocolos
     * const protocolo = await prisma.protocolo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProtocoloUpdateManyArgs>(args: SelectSubset<T, ProtocoloUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Protocolo.
     * @param {ProtocoloUpsertArgs} args - Arguments to update or create a Protocolo.
     * @example
     * // Update or create a Protocolo
     * const protocolo = await prisma.protocolo.upsert({
     *   create: {
     *     // ... data to create a Protocolo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Protocolo we want to update
     *   }
     * })
     */
    upsert<T extends ProtocoloUpsertArgs>(args: SelectSubset<T, ProtocoloUpsertArgs<ExtArgs>>): Prisma__ProtocoloClient<$Result.GetResult<Prisma.$ProtocoloPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Protocolos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocoloCountArgs} args - Arguments to filter Protocolos to count.
     * @example
     * // Count the number of Protocolos
     * const count = await prisma.protocolo.count({
     *   where: {
     *     // ... the filter for the Protocolos we want to count
     *   }
     * })
    **/
    count<T extends ProtocoloCountArgs>(
      args?: Subset<T, ProtocoloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProtocoloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Protocolo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocoloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProtocoloAggregateArgs>(args: Subset<T, ProtocoloAggregateArgs>): Prisma.PrismaPromise<GetProtocoloAggregateType<T>>

    /**
     * Group by Protocolo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProtocoloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProtocoloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProtocoloGroupByArgs['orderBy'] }
        : { orderBy?: ProtocoloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProtocoloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProtocoloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Protocolo model
   */
  readonly fields: ProtocoloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Protocolo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProtocoloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends Protocolo$servicioArgs<ExtArgs> = {}>(args?: Subset<T, Protocolo$servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Protocolo model
   */ 
  interface ProtocoloFieldRefs {
    readonly id_protocolo: FieldRef<"Protocolo", 'Int'>
    readonly nombre: FieldRef<"Protocolo", 'String'>
    readonly estado: FieldRef<"Protocolo", 'Estado'>
  }
    

  // Custom InputTypes
  /**
   * Protocolo findUnique
   */
  export type ProtocoloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * Filter, which Protocolo to fetch.
     */
    where: ProtocoloWhereUniqueInput
  }

  /**
   * Protocolo findUniqueOrThrow
   */
  export type ProtocoloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * Filter, which Protocolo to fetch.
     */
    where: ProtocoloWhereUniqueInput
  }

  /**
   * Protocolo findFirst
   */
  export type ProtocoloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * Filter, which Protocolo to fetch.
     */
    where?: ProtocoloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocolos to fetch.
     */
    orderBy?: ProtocoloOrderByWithRelationInput | ProtocoloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Protocolos.
     */
    cursor?: ProtocoloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocolos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocolos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Protocolos.
     */
    distinct?: ProtocoloScalarFieldEnum | ProtocoloScalarFieldEnum[]
  }

  /**
   * Protocolo findFirstOrThrow
   */
  export type ProtocoloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * Filter, which Protocolo to fetch.
     */
    where?: ProtocoloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocolos to fetch.
     */
    orderBy?: ProtocoloOrderByWithRelationInput | ProtocoloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Protocolos.
     */
    cursor?: ProtocoloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocolos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocolos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Protocolos.
     */
    distinct?: ProtocoloScalarFieldEnum | ProtocoloScalarFieldEnum[]
  }

  /**
   * Protocolo findMany
   */
  export type ProtocoloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * Filter, which Protocolos to fetch.
     */
    where?: ProtocoloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Protocolos to fetch.
     */
    orderBy?: ProtocoloOrderByWithRelationInput | ProtocoloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Protocolos.
     */
    cursor?: ProtocoloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Protocolos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Protocolos.
     */
    skip?: number
    distinct?: ProtocoloScalarFieldEnum | ProtocoloScalarFieldEnum[]
  }

  /**
   * Protocolo create
   */
  export type ProtocoloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * The data needed to create a Protocolo.
     */
    data: XOR<ProtocoloCreateInput, ProtocoloUncheckedCreateInput>
  }

  /**
   * Protocolo createMany
   */
  export type ProtocoloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Protocolos.
     */
    data: ProtocoloCreateManyInput | ProtocoloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Protocolo update
   */
  export type ProtocoloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * The data needed to update a Protocolo.
     */
    data: XOR<ProtocoloUpdateInput, ProtocoloUncheckedUpdateInput>
    /**
     * Choose, which Protocolo to update.
     */
    where: ProtocoloWhereUniqueInput
  }

  /**
   * Protocolo updateMany
   */
  export type ProtocoloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Protocolos.
     */
    data: XOR<ProtocoloUpdateManyMutationInput, ProtocoloUncheckedUpdateManyInput>
    /**
     * Filter which Protocolos to update
     */
    where?: ProtocoloWhereInput
  }

  /**
   * Protocolo upsert
   */
  export type ProtocoloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * The filter to search for the Protocolo to update in case it exists.
     */
    where: ProtocoloWhereUniqueInput
    /**
     * In case the Protocolo found by the `where` argument doesn't exist, create a new Protocolo with this data.
     */
    create: XOR<ProtocoloCreateInput, ProtocoloUncheckedCreateInput>
    /**
     * In case the Protocolo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProtocoloUpdateInput, ProtocoloUncheckedUpdateInput>
  }

  /**
   * Protocolo delete
   */
  export type ProtocoloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
    /**
     * Filter which Protocolo to delete.
     */
    where: ProtocoloWhereUniqueInput
  }

  /**
   * Protocolo deleteMany
   */
  export type ProtocoloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Protocolos to delete
     */
    where?: ProtocoloWhereInput
  }

  /**
   * Protocolo.servicio
   */
  export type Protocolo$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    cursor?: ServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Protocolo without action
   */
  export type ProtocoloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Protocolo
     */
    select?: ProtocoloSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProtocoloInclude<ExtArgs> | null
  }


  /**
   * Model Empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaAvgAggregateOutputType = {
    id_empresa: number | null
    codigo: number | null
    municipio: number | null
  }

  export type EmpresaSumAggregateOutputType = {
    id_empresa: number | null
    codigo: number | null
    municipio: number | null
  }

  export type EmpresaMinAggregateOutputType = {
    id_empresa: number | null
    nit: string | null
    codigo: number | null
    nombre: string | null
    sigla: string | null
    tipo: $Enums.Tipo_Empresa | null
    estado: $Enums.Estado | null
    municipio: number | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id_empresa: number | null
    nit: string | null
    codigo: number | null
    nombre: string | null
    sigla: string | null
    tipo: $Enums.Tipo_Empresa | null
    estado: $Enums.Estado | null
    municipio: number | null
  }

  export type EmpresaCountAggregateOutputType = {
    id_empresa: number
    nit: number
    codigo: number
    nombre: number
    sigla: number
    tipo: number
    estado: number
    municipio: number
    _all: number
  }


  export type EmpresaAvgAggregateInputType = {
    id_empresa?: true
    codigo?: true
    municipio?: true
  }

  export type EmpresaSumAggregateInputType = {
    id_empresa?: true
    codigo?: true
    municipio?: true
  }

  export type EmpresaMinAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipio?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipio?: true
  }

  export type EmpresaCountAggregateInputType = {
    id_empresa?: true
    nit?: true
    codigo?: true
    nombre?: true
    sigla?: true
    tipo?: true
    estado?: true
    municipio?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresa to aggregate.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithAggregationInput | EmpresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: EmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _avg?: EmpresaAvgAggregateInputType
    _sum?: EmpresaSumAggregateInputType
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id_empresa: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipio: number
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_empresa?: boolean
    nit?: boolean
    codigo?: boolean
    nombre?: boolean
    sigla?: boolean
    tipo?: boolean
    estado?: boolean
    municipio?: boolean
    contrato?: boolean | Empresa$contratoArgs<ExtArgs>
    Muncipio_Empresa?: boolean | MunicipioDefaultArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>


  export type EmpresaSelectScalar = {
    id_empresa?: boolean
    nit?: boolean
    codigo?: boolean
    nombre?: boolean
    sigla?: boolean
    tipo?: boolean
    estado?: boolean
    municipio?: boolean
  }

  export type EmpresaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contrato?: boolean | Empresa$contratoArgs<ExtArgs>
    Muncipio_Empresa?: boolean | MunicipioDefaultArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmpresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empresa"
    objects: {
      contrato: Prisma.$ContratoPayload<ExtArgs>[]
      Muncipio_Empresa: Prisma.$MunicipioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_empresa: number
      nit: string
      codigo: number
      nombre: string
      sigla: string
      tipo: $Enums.Tipo_Empresa
      estado: $Enums.Estado
      municipio: number
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type EmpresaGetPayload<S extends boolean | null | undefined | EmpresaDefaultArgs> = $Result.GetResult<Prisma.$EmpresaPayload, S>

  type EmpresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface EmpresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empresa'], meta: { name: 'Empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {EmpresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaFindUniqueArgs>(args: SelectSubset<T, EmpresaFindUniqueArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaFindFirstArgs>(args?: SelectSubset<T, EmpresaFindFirstArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id_empresa`
     * const empresaWithId_empresaOnly = await prisma.empresa.findMany({ select: { id_empresa: true } })
     * 
     */
    findMany<T extends EmpresaFindManyArgs>(args?: SelectSubset<T, EmpresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empresa.
     * @param {EmpresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends EmpresaCreateArgs>(args: SelectSubset<T, EmpresaCreateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empresas.
     * @param {EmpresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaCreateManyArgs>(args?: SelectSubset<T, EmpresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empresa.
     * @param {EmpresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends EmpresaDeleteArgs>(args: SelectSubset<T, EmpresaDeleteArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empresa.
     * @param {EmpresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaUpdateArgs>(args: SelectSubset<T, EmpresaUpdateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {EmpresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaDeleteManyArgs>(args?: SelectSubset<T, EmpresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaUpdateManyArgs>(args: SelectSubset<T, EmpresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {EmpresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaUpsertArgs>(args: SelectSubset<T, EmpresaUpsertArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends EmpresaCountArgs>(
      args?: Subset<T, EmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empresa model
   */
  readonly fields: EmpresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contrato<T extends Empresa$contratoArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$contratoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findMany"> | Null>
    Muncipio_Empresa<T extends MunicipioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipioDefaultArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empresa model
   */ 
  interface EmpresaFieldRefs {
    readonly id_empresa: FieldRef<"Empresa", 'Int'>
    readonly nit: FieldRef<"Empresa", 'String'>
    readonly codigo: FieldRef<"Empresa", 'Int'>
    readonly nombre: FieldRef<"Empresa", 'String'>
    readonly sigla: FieldRef<"Empresa", 'String'>
    readonly tipo: FieldRef<"Empresa", 'Tipo_Empresa'>
    readonly estado: FieldRef<"Empresa", 'Estado'>
    readonly municipio: FieldRef<"Empresa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Empresa findUnique
   */
  export type EmpresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findUniqueOrThrow
   */
  export type EmpresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findFirst
   */
  export type EmpresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findFirstOrThrow
   */
  export type EmpresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findMany
   */
  export type EmpresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresas to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa create
   */
  export type EmpresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to create a Empresa.
     */
    data: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
  }

  /**
   * Empresa createMany
   */
  export type EmpresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa update
   */
  export type EmpresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to update a Empresa.
     */
    data: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
    /**
     * Choose, which Empresa to update.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa updateMany
   */
  export type EmpresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa upsert
   */
  export type EmpresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The filter to search for the Empresa to update in case it exists.
     */
    where: EmpresaWhereUniqueInput
    /**
     * In case the Empresa found by the `where` argument doesn't exist, create a new Empresa with this data.
     */
    create: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
    /**
     * In case the Empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
  }

  /**
   * Empresa delete
   */
  export type EmpresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter which Empresa to delete.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa deleteMany
   */
  export type EmpresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresas to delete
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa.contrato
   */
  export type Empresa$contratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    where?: ContratoWhereInput
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    cursor?: ContratoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Empresa without action
   */
  export type EmpresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
  }


  /**
   * Model Contrato
   */

  export type AggregateContrato = {
    _count: ContratoCountAggregateOutputType | null
    _avg: ContratoAvgAggregateOutputType | null
    _sum: ContratoSumAggregateOutputType | null
    _min: ContratoMinAggregateOutputType | null
    _max: ContratoMaxAggregateOutputType | null
  }

  export type ContratoAvgAggregateOutputType = {
    id_contrato: number | null
    empresa: number | null
  }

  export type ContratoSumAggregateOutputType = {
    id_contrato: number | null
    empresa: number | null
  }

  export type ContratoMinAggregateOutputType = {
    id_contrato: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: $Enums.Estado | null
    empresa: number | null
  }

  export type ContratoMaxAggregateOutputType = {
    id_contrato: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: $Enums.Estado | null
    empresa: number | null
  }

  export type ContratoCountAggregateOutputType = {
    id_contrato: number
    fecha_inicio: number
    fecha_fin: number
    estado: number
    empresa: number
    _all: number
  }


  export type ContratoAvgAggregateInputType = {
    id_contrato?: true
    empresa?: true
  }

  export type ContratoSumAggregateInputType = {
    id_contrato?: true
    empresa?: true
  }

  export type ContratoMinAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresa?: true
  }

  export type ContratoMaxAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresa?: true
  }

  export type ContratoCountAggregateInputType = {
    id_contrato?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empresa?: true
    _all?: true
  }

  export type ContratoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contrato to aggregate.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contratoes
    **/
    _count?: true | ContratoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContratoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContratoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContratoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContratoMaxAggregateInputType
  }

  export type GetContratoAggregateType<T extends ContratoAggregateArgs> = {
        [P in keyof T & keyof AggregateContrato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContrato[P]>
      : GetScalarType<T[P], AggregateContrato[P]>
  }




  export type ContratoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratoWhereInput
    orderBy?: ContratoOrderByWithAggregationInput | ContratoOrderByWithAggregationInput[]
    by: ContratoScalarFieldEnum[] | ContratoScalarFieldEnum
    having?: ContratoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContratoCountAggregateInputType | true
    _avg?: ContratoAvgAggregateInputType
    _sum?: ContratoSumAggregateInputType
    _min?: ContratoMinAggregateInputType
    _max?: ContratoMaxAggregateInputType
  }

  export type ContratoGroupByOutputType = {
    id_contrato: number
    fecha_inicio: Date
    fecha_fin: Date
    estado: $Enums.Estado
    empresa: number
    _count: ContratoCountAggregateOutputType | null
    _avg: ContratoAvgAggregateOutputType | null
    _sum: ContratoSumAggregateOutputType | null
    _min: ContratoMinAggregateOutputType | null
    _max: ContratoMaxAggregateOutputType | null
  }

  type GetContratoGroupByPayload<T extends ContratoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContratoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContratoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContratoGroupByOutputType[P]>
            : GetScalarType<T[P], ContratoGroupByOutputType[P]>
        }
      >
    >


  export type ContratoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_contrato?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empresa?: boolean
    acuerdo?: boolean | Contrato$acuerdoArgs<ExtArgs>
    Contrato_Empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    _count?: boolean | ContratoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contrato"]>


  export type ContratoSelectScalar = {
    id_contrato?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empresa?: boolean
  }

  export type ContratoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acuerdo?: boolean | Contrato$acuerdoArgs<ExtArgs>
    Contrato_Empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    _count?: boolean | ContratoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContratoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contrato"
    objects: {
      acuerdo: Prisma.$AcuerdoPayload<ExtArgs>[]
      Contrato_Empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_contrato: number
      fecha_inicio: Date
      fecha_fin: Date
      estado: $Enums.Estado
      empresa: number
    }, ExtArgs["result"]["contrato"]>
    composites: {}
  }

  type ContratoGetPayload<S extends boolean | null | undefined | ContratoDefaultArgs> = $Result.GetResult<Prisma.$ContratoPayload, S>

  type ContratoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContratoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContratoCountAggregateInputType | true
    }

  export interface ContratoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contrato'], meta: { name: 'Contrato' } }
    /**
     * Find zero or one Contrato that matches the filter.
     * @param {ContratoFindUniqueArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContratoFindUniqueArgs>(args: SelectSubset<T, ContratoFindUniqueArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contrato that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContratoFindUniqueOrThrowArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContratoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContratoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contrato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindFirstArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContratoFindFirstArgs>(args?: SelectSubset<T, ContratoFindFirstArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contrato that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindFirstOrThrowArgs} args - Arguments to find a Contrato
     * @example
     * // Get one Contrato
     * const contrato = await prisma.contrato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContratoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContratoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contratoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contratoes
     * const contratoes = await prisma.contrato.findMany()
     * 
     * // Get first 10 Contratoes
     * const contratoes = await prisma.contrato.findMany({ take: 10 })
     * 
     * // Only select the `id_contrato`
     * const contratoWithId_contratoOnly = await prisma.contrato.findMany({ select: { id_contrato: true } })
     * 
     */
    findMany<T extends ContratoFindManyArgs>(args?: SelectSubset<T, ContratoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contrato.
     * @param {ContratoCreateArgs} args - Arguments to create a Contrato.
     * @example
     * // Create one Contrato
     * const Contrato = await prisma.contrato.create({
     *   data: {
     *     // ... data to create a Contrato
     *   }
     * })
     * 
     */
    create<T extends ContratoCreateArgs>(args: SelectSubset<T, ContratoCreateArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contratoes.
     * @param {ContratoCreateManyArgs} args - Arguments to create many Contratoes.
     * @example
     * // Create many Contratoes
     * const contrato = await prisma.contrato.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContratoCreateManyArgs>(args?: SelectSubset<T, ContratoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contrato.
     * @param {ContratoDeleteArgs} args - Arguments to delete one Contrato.
     * @example
     * // Delete one Contrato
     * const Contrato = await prisma.contrato.delete({
     *   where: {
     *     // ... filter to delete one Contrato
     *   }
     * })
     * 
     */
    delete<T extends ContratoDeleteArgs>(args: SelectSubset<T, ContratoDeleteArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contrato.
     * @param {ContratoUpdateArgs} args - Arguments to update one Contrato.
     * @example
     * // Update one Contrato
     * const contrato = await prisma.contrato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContratoUpdateArgs>(args: SelectSubset<T, ContratoUpdateArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contratoes.
     * @param {ContratoDeleteManyArgs} args - Arguments to filter Contratoes to delete.
     * @example
     * // Delete a few Contratoes
     * const { count } = await prisma.contrato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContratoDeleteManyArgs>(args?: SelectSubset<T, ContratoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contratoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contratoes
     * const contrato = await prisma.contrato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContratoUpdateManyArgs>(args: SelectSubset<T, ContratoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contrato.
     * @param {ContratoUpsertArgs} args - Arguments to update or create a Contrato.
     * @example
     * // Update or create a Contrato
     * const contrato = await prisma.contrato.upsert({
     *   create: {
     *     // ... data to create a Contrato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contrato we want to update
     *   }
     * })
     */
    upsert<T extends ContratoUpsertArgs>(args: SelectSubset<T, ContratoUpsertArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contratoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoCountArgs} args - Arguments to filter Contratoes to count.
     * @example
     * // Count the number of Contratoes
     * const count = await prisma.contrato.count({
     *   where: {
     *     // ... the filter for the Contratoes we want to count
     *   }
     * })
    **/
    count<T extends ContratoCountArgs>(
      args?: Subset<T, ContratoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContratoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contrato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContratoAggregateArgs>(args: Subset<T, ContratoAggregateArgs>): Prisma.PrismaPromise<GetContratoAggregateType<T>>

    /**
     * Group by Contrato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContratoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContratoGroupByArgs['orderBy'] }
        : { orderBy?: ContratoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContratoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContratoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contrato model
   */
  readonly fields: ContratoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contrato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContratoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    acuerdo<T extends Contrato$acuerdoArgs<ExtArgs> = {}>(args?: Subset<T, Contrato$acuerdoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findMany"> | Null>
    Contrato_Empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contrato model
   */ 
  interface ContratoFieldRefs {
    readonly id_contrato: FieldRef<"Contrato", 'Int'>
    readonly fecha_inicio: FieldRef<"Contrato", 'DateTime'>
    readonly fecha_fin: FieldRef<"Contrato", 'DateTime'>
    readonly estado: FieldRef<"Contrato", 'Estado'>
    readonly empresa: FieldRef<"Contrato", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Contrato findUnique
   */
  export type ContratoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato findUniqueOrThrow
   */
  export type ContratoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato findFirst
   */
  export type ContratoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contratoes.
     */
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato findFirstOrThrow
   */
  export type ContratoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contrato to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contratoes.
     */
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato findMany
   */
  export type ContratoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter, which Contratoes to fetch.
     */
    where?: ContratoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contratoes to fetch.
     */
    orderBy?: ContratoOrderByWithRelationInput | ContratoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contratoes.
     */
    cursor?: ContratoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contratoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contratoes.
     */
    skip?: number
    distinct?: ContratoScalarFieldEnum | ContratoScalarFieldEnum[]
  }

  /**
   * Contrato create
   */
  export type ContratoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The data needed to create a Contrato.
     */
    data: XOR<ContratoCreateInput, ContratoUncheckedCreateInput>
  }

  /**
   * Contrato createMany
   */
  export type ContratoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contratoes.
     */
    data: ContratoCreateManyInput | ContratoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contrato update
   */
  export type ContratoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The data needed to update a Contrato.
     */
    data: XOR<ContratoUpdateInput, ContratoUncheckedUpdateInput>
    /**
     * Choose, which Contrato to update.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato updateMany
   */
  export type ContratoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contratoes.
     */
    data: XOR<ContratoUpdateManyMutationInput, ContratoUncheckedUpdateManyInput>
    /**
     * Filter which Contratoes to update
     */
    where?: ContratoWhereInput
  }

  /**
   * Contrato upsert
   */
  export type ContratoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * The filter to search for the Contrato to update in case it exists.
     */
    where: ContratoWhereUniqueInput
    /**
     * In case the Contrato found by the `where` argument doesn't exist, create a new Contrato with this data.
     */
    create: XOR<ContratoCreateInput, ContratoUncheckedCreateInput>
    /**
     * In case the Contrato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContratoUpdateInput, ContratoUncheckedUpdateInput>
  }

  /**
   * Contrato delete
   */
  export type ContratoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
    /**
     * Filter which Contrato to delete.
     */
    where: ContratoWhereUniqueInput
  }

  /**
   * Contrato deleteMany
   */
  export type ContratoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contratoes to delete
     */
    where?: ContratoWhereInput
  }

  /**
   * Contrato.acuerdo
   */
  export type Contrato$acuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    where?: AcuerdoWhereInput
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    cursor?: AcuerdoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Contrato without action
   */
  export type ContratoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrato
     */
    select?: ContratoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratoInclude<ExtArgs> | null
  }


  /**
   * Model Acuerdo
   */

  export type AggregateAcuerdo = {
    _count: AcuerdoCountAggregateOutputType | null
    _avg: AcuerdoAvgAggregateOutputType | null
    _sum: AcuerdoSumAggregateOutputType | null
    _min: AcuerdoMinAggregateOutputType | null
    _max: AcuerdoMaxAggregateOutputType | null
  }

  export type AcuerdoAvgAggregateOutputType = {
    id_acuerdo: number | null
    contrato: number | null
    valor: Decimal | null
    tarifa: number | null
  }

  export type AcuerdoSumAggregateOutputType = {
    id_acuerdo: number | null
    contrato: number | null
    valor: Decimal | null
    tarifa: number | null
  }

  export type AcuerdoMinAggregateOutputType = {
    id_acuerdo: number | null
    estado: $Enums.Estado | null
    contrato: number | null
    valor: Decimal | null
    tarifa: number | null
  }

  export type AcuerdoMaxAggregateOutputType = {
    id_acuerdo: number | null
    estado: $Enums.Estado | null
    contrato: number | null
    valor: Decimal | null
    tarifa: number | null
  }

  export type AcuerdoCountAggregateOutputType = {
    id_acuerdo: number
    estado: number
    contrato: number
    valor: number
    tarifa: number
    _all: number
  }


  export type AcuerdoAvgAggregateInputType = {
    id_acuerdo?: true
    contrato?: true
    valor?: true
    tarifa?: true
  }

  export type AcuerdoSumAggregateInputType = {
    id_acuerdo?: true
    contrato?: true
    valor?: true
    tarifa?: true
  }

  export type AcuerdoMinAggregateInputType = {
    id_acuerdo?: true
    estado?: true
    contrato?: true
    valor?: true
    tarifa?: true
  }

  export type AcuerdoMaxAggregateInputType = {
    id_acuerdo?: true
    estado?: true
    contrato?: true
    valor?: true
    tarifa?: true
  }

  export type AcuerdoCountAggregateInputType = {
    id_acuerdo?: true
    estado?: true
    contrato?: true
    valor?: true
    tarifa?: true
    _all?: true
  }

  export type AcuerdoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acuerdo to aggregate.
     */
    where?: AcuerdoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acuerdos to fetch.
     */
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcuerdoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acuerdos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acuerdos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Acuerdos
    **/
    _count?: true | AcuerdoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcuerdoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcuerdoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcuerdoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcuerdoMaxAggregateInputType
  }

  export type GetAcuerdoAggregateType<T extends AcuerdoAggregateArgs> = {
        [P in keyof T & keyof AggregateAcuerdo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcuerdo[P]>
      : GetScalarType<T[P], AggregateAcuerdo[P]>
  }




  export type AcuerdoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcuerdoWhereInput
    orderBy?: AcuerdoOrderByWithAggregationInput | AcuerdoOrderByWithAggregationInput[]
    by: AcuerdoScalarFieldEnum[] | AcuerdoScalarFieldEnum
    having?: AcuerdoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcuerdoCountAggregateInputType | true
    _avg?: AcuerdoAvgAggregateInputType
    _sum?: AcuerdoSumAggregateInputType
    _min?: AcuerdoMinAggregateInputType
    _max?: AcuerdoMaxAggregateInputType
  }

  export type AcuerdoGroupByOutputType = {
    id_acuerdo: number
    estado: $Enums.Estado
    contrato: number
    valor: Decimal
    tarifa: number
    _count: AcuerdoCountAggregateOutputType | null
    _avg: AcuerdoAvgAggregateOutputType | null
    _sum: AcuerdoSumAggregateOutputType | null
    _min: AcuerdoMinAggregateOutputType | null
    _max: AcuerdoMaxAggregateOutputType | null
  }

  type GetAcuerdoGroupByPayload<T extends AcuerdoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcuerdoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcuerdoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcuerdoGroupByOutputType[P]>
            : GetScalarType<T[P], AcuerdoGroupByOutputType[P]>
        }
      >
    >


  export type AcuerdoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_acuerdo?: boolean
    estado?: boolean
    contrato?: boolean
    valor?: boolean
    tarifa?: boolean
    procedimiento?: boolean | Acuerdo$procedimientoArgs<ExtArgs>
    Contrato_Acuerdo?: boolean | ContratoDefaultArgs<ExtArgs>
    Tarifa_Acuerdo?: boolean | TarifaDefaultArgs<ExtArgs>
    _count?: boolean | AcuerdoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acuerdo"]>


  export type AcuerdoSelectScalar = {
    id_acuerdo?: boolean
    estado?: boolean
    contrato?: boolean
    valor?: boolean
    tarifa?: boolean
  }

  export type AcuerdoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedimiento?: boolean | Acuerdo$procedimientoArgs<ExtArgs>
    Contrato_Acuerdo?: boolean | ContratoDefaultArgs<ExtArgs>
    Tarifa_Acuerdo?: boolean | TarifaDefaultArgs<ExtArgs>
    _count?: boolean | AcuerdoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AcuerdoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Acuerdo"
    objects: {
      procedimiento: Prisma.$ProcedimientoPayload<ExtArgs>[]
      Contrato_Acuerdo: Prisma.$ContratoPayload<ExtArgs>
      Tarifa_Acuerdo: Prisma.$TarifaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_acuerdo: number
      estado: $Enums.Estado
      contrato: number
      valor: Prisma.Decimal
      tarifa: number
    }, ExtArgs["result"]["acuerdo"]>
    composites: {}
  }

  type AcuerdoGetPayload<S extends boolean | null | undefined | AcuerdoDefaultArgs> = $Result.GetResult<Prisma.$AcuerdoPayload, S>

  type AcuerdoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcuerdoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcuerdoCountAggregateInputType | true
    }

  export interface AcuerdoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Acuerdo'], meta: { name: 'Acuerdo' } }
    /**
     * Find zero or one Acuerdo that matches the filter.
     * @param {AcuerdoFindUniqueArgs} args - Arguments to find a Acuerdo
     * @example
     * // Get one Acuerdo
     * const acuerdo = await prisma.acuerdo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcuerdoFindUniqueArgs>(args: SelectSubset<T, AcuerdoFindUniqueArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Acuerdo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcuerdoFindUniqueOrThrowArgs} args - Arguments to find a Acuerdo
     * @example
     * // Get one Acuerdo
     * const acuerdo = await prisma.acuerdo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcuerdoFindUniqueOrThrowArgs>(args: SelectSubset<T, AcuerdoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Acuerdo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoFindFirstArgs} args - Arguments to find a Acuerdo
     * @example
     * // Get one Acuerdo
     * const acuerdo = await prisma.acuerdo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcuerdoFindFirstArgs>(args?: SelectSubset<T, AcuerdoFindFirstArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Acuerdo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoFindFirstOrThrowArgs} args - Arguments to find a Acuerdo
     * @example
     * // Get one Acuerdo
     * const acuerdo = await prisma.acuerdo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcuerdoFindFirstOrThrowArgs>(args?: SelectSubset<T, AcuerdoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Acuerdos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Acuerdos
     * const acuerdos = await prisma.acuerdo.findMany()
     * 
     * // Get first 10 Acuerdos
     * const acuerdos = await prisma.acuerdo.findMany({ take: 10 })
     * 
     * // Only select the `id_acuerdo`
     * const acuerdoWithId_acuerdoOnly = await prisma.acuerdo.findMany({ select: { id_acuerdo: true } })
     * 
     */
    findMany<T extends AcuerdoFindManyArgs>(args?: SelectSubset<T, AcuerdoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Acuerdo.
     * @param {AcuerdoCreateArgs} args - Arguments to create a Acuerdo.
     * @example
     * // Create one Acuerdo
     * const Acuerdo = await prisma.acuerdo.create({
     *   data: {
     *     // ... data to create a Acuerdo
     *   }
     * })
     * 
     */
    create<T extends AcuerdoCreateArgs>(args: SelectSubset<T, AcuerdoCreateArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Acuerdos.
     * @param {AcuerdoCreateManyArgs} args - Arguments to create many Acuerdos.
     * @example
     * // Create many Acuerdos
     * const acuerdo = await prisma.acuerdo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcuerdoCreateManyArgs>(args?: SelectSubset<T, AcuerdoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Acuerdo.
     * @param {AcuerdoDeleteArgs} args - Arguments to delete one Acuerdo.
     * @example
     * // Delete one Acuerdo
     * const Acuerdo = await prisma.acuerdo.delete({
     *   where: {
     *     // ... filter to delete one Acuerdo
     *   }
     * })
     * 
     */
    delete<T extends AcuerdoDeleteArgs>(args: SelectSubset<T, AcuerdoDeleteArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Acuerdo.
     * @param {AcuerdoUpdateArgs} args - Arguments to update one Acuerdo.
     * @example
     * // Update one Acuerdo
     * const acuerdo = await prisma.acuerdo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcuerdoUpdateArgs>(args: SelectSubset<T, AcuerdoUpdateArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Acuerdos.
     * @param {AcuerdoDeleteManyArgs} args - Arguments to filter Acuerdos to delete.
     * @example
     * // Delete a few Acuerdos
     * const { count } = await prisma.acuerdo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcuerdoDeleteManyArgs>(args?: SelectSubset<T, AcuerdoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Acuerdos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Acuerdos
     * const acuerdo = await prisma.acuerdo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcuerdoUpdateManyArgs>(args: SelectSubset<T, AcuerdoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Acuerdo.
     * @param {AcuerdoUpsertArgs} args - Arguments to update or create a Acuerdo.
     * @example
     * // Update or create a Acuerdo
     * const acuerdo = await prisma.acuerdo.upsert({
     *   create: {
     *     // ... data to create a Acuerdo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Acuerdo we want to update
     *   }
     * })
     */
    upsert<T extends AcuerdoUpsertArgs>(args: SelectSubset<T, AcuerdoUpsertArgs<ExtArgs>>): Prisma__AcuerdoClient<$Result.GetResult<Prisma.$AcuerdoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Acuerdos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoCountArgs} args - Arguments to filter Acuerdos to count.
     * @example
     * // Count the number of Acuerdos
     * const count = await prisma.acuerdo.count({
     *   where: {
     *     // ... the filter for the Acuerdos we want to count
     *   }
     * })
    **/
    count<T extends AcuerdoCountArgs>(
      args?: Subset<T, AcuerdoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcuerdoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Acuerdo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcuerdoAggregateArgs>(args: Subset<T, AcuerdoAggregateArgs>): Prisma.PrismaPromise<GetAcuerdoAggregateType<T>>

    /**
     * Group by Acuerdo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcuerdoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcuerdoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcuerdoGroupByArgs['orderBy'] }
        : { orderBy?: AcuerdoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcuerdoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcuerdoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Acuerdo model
   */
  readonly fields: AcuerdoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Acuerdo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcuerdoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedimiento<T extends Acuerdo$procedimientoArgs<ExtArgs> = {}>(args?: Subset<T, Acuerdo$procedimientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedimientoPayload<ExtArgs>, T, "findMany"> | Null>
    Contrato_Acuerdo<T extends ContratoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContratoDefaultArgs<ExtArgs>>): Prisma__ContratoClient<$Result.GetResult<Prisma.$ContratoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tarifa_Acuerdo<T extends TarifaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TarifaDefaultArgs<ExtArgs>>): Prisma__TarifaClient<$Result.GetResult<Prisma.$TarifaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Acuerdo model
   */ 
  interface AcuerdoFieldRefs {
    readonly id_acuerdo: FieldRef<"Acuerdo", 'Int'>
    readonly estado: FieldRef<"Acuerdo", 'Estado'>
    readonly contrato: FieldRef<"Acuerdo", 'Int'>
    readonly valor: FieldRef<"Acuerdo", 'Decimal'>
    readonly tarifa: FieldRef<"Acuerdo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Acuerdo findUnique
   */
  export type AcuerdoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdo to fetch.
     */
    where: AcuerdoWhereUniqueInput
  }

  /**
   * Acuerdo findUniqueOrThrow
   */
  export type AcuerdoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdo to fetch.
     */
    where: AcuerdoWhereUniqueInput
  }

  /**
   * Acuerdo findFirst
   */
  export type AcuerdoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdo to fetch.
     */
    where?: AcuerdoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acuerdos to fetch.
     */
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Acuerdos.
     */
    cursor?: AcuerdoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acuerdos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acuerdos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Acuerdos.
     */
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Acuerdo findFirstOrThrow
   */
  export type AcuerdoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdo to fetch.
     */
    where?: AcuerdoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acuerdos to fetch.
     */
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Acuerdos.
     */
    cursor?: AcuerdoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acuerdos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acuerdos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Acuerdos.
     */
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Acuerdo findMany
   */
  export type AcuerdoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter, which Acuerdos to fetch.
     */
    where?: AcuerdoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acuerdos to fetch.
     */
    orderBy?: AcuerdoOrderByWithRelationInput | AcuerdoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Acuerdos.
     */
    cursor?: AcuerdoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acuerdos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acuerdos.
     */
    skip?: number
    distinct?: AcuerdoScalarFieldEnum | AcuerdoScalarFieldEnum[]
  }

  /**
   * Acuerdo create
   */
  export type AcuerdoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * The data needed to create a Acuerdo.
     */
    data: XOR<AcuerdoCreateInput, AcuerdoUncheckedCreateInput>
  }

  /**
   * Acuerdo createMany
   */
  export type AcuerdoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Acuerdos.
     */
    data: AcuerdoCreateManyInput | AcuerdoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Acuerdo update
   */
  export type AcuerdoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * The data needed to update a Acuerdo.
     */
    data: XOR<AcuerdoUpdateInput, AcuerdoUncheckedUpdateInput>
    /**
     * Choose, which Acuerdo to update.
     */
    where: AcuerdoWhereUniqueInput
  }

  /**
   * Acuerdo updateMany
   */
  export type AcuerdoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Acuerdos.
     */
    data: XOR<AcuerdoUpdateManyMutationInput, AcuerdoUncheckedUpdateManyInput>
    /**
     * Filter which Acuerdos to update
     */
    where?: AcuerdoWhereInput
  }

  /**
   * Acuerdo upsert
   */
  export type AcuerdoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * The filter to search for the Acuerdo to update in case it exists.
     */
    where: AcuerdoWhereUniqueInput
    /**
     * In case the Acuerdo found by the `where` argument doesn't exist, create a new Acuerdo with this data.
     */
    create: XOR<AcuerdoCreateInput, AcuerdoUncheckedCreateInput>
    /**
     * In case the Acuerdo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcuerdoUpdateInput, AcuerdoUncheckedUpdateInput>
  }

  /**
   * Acuerdo delete
   */
  export type AcuerdoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
    /**
     * Filter which Acuerdo to delete.
     */
    where: AcuerdoWhereUniqueInput
  }

  /**
   * Acuerdo deleteMany
   */
  export type AcuerdoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acuerdos to delete
     */
    where?: AcuerdoWhereInput
  }

  /**
   * Acuerdo.procedimiento
   */
  export type Acuerdo$procedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedimiento
     */
    select?: ProcedimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedimientoInclude<ExtArgs> | null
    where?: ProcedimientoWhereInput
    orderBy?: ProcedimientoOrderByWithRelationInput | ProcedimientoOrderByWithRelationInput[]
    cursor?: ProcedimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedimientoScalarFieldEnum | ProcedimientoScalarFieldEnum[]
  }

  /**
   * Acuerdo without action
   */
  export type AcuerdoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acuerdo
     */
    select?: AcuerdoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcuerdoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id_usuario: 'id_usuario',
    tipo_identificacion: 'tipo_identificacion',
    identificacion: 'identificacion',
    primer_nombre: 'primer_nombre',
    segundo_nombre: 'segundo_nombre',
    primer_apellido: 'primer_apellido',
    segundo_apellido: 'segundo_apellido',
    fecha_nacimiento: 'fecha_nacimiento',
    sexo: 'sexo',
    email: 'email',
    telefono: 'telefono',
    tipo_usuario: 'tipo_usuario',
    municipio: 'municipio',
    estado: 'estado',
    createAt: 'createAt',
    updateAt: 'updateAt',
    eps: 'eps'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const EpsScalarFieldEnum: {
    id_eps: 'id_eps',
    codigo: 'codigo',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type EpsScalarFieldEnum = (typeof EpsScalarFieldEnum)[keyof typeof EpsScalarFieldEnum]


  export const ProcedimientoScalarFieldEnum: {
    id_procedimiento: 'id_procedimiento',
    consecutivo: 'consecutivo',
    fecha: 'fecha',
    factura: 'factura',
    usuario: 'usuario',
    acuerdo: 'acuerdo'
  };

  export type ProcedimientoScalarFieldEnum = (typeof ProcedimientoScalarFieldEnum)[keyof typeof ProcedimientoScalarFieldEnum]


  export const DepartamentoScalarFieldEnum: {
    id_departamento: 'id_departamento',
    nombre: 'nombre'
  };

  export type DepartamentoScalarFieldEnum = (typeof DepartamentoScalarFieldEnum)[keyof typeof DepartamentoScalarFieldEnum]


  export const MunicipioScalarFieldEnum: {
    id_municipio: 'id_municipio',
    nombre: 'nombre',
    departamento: 'departamento'
  };

  export type MunicipioScalarFieldEnum = (typeof MunicipioScalarFieldEnum)[keyof typeof MunicipioScalarFieldEnum]


  export const ServicioScalarFieldEnum: {
    id_servicio: 'id_servicio',
    nombre: 'nombre',
    precio: 'precio',
    iva: 'iva',
    nivel: 'nivel',
    tarifa: 'tarifa',
    protocolo: 'protocolo',
    prestador: 'prestador'
  };

  export type ServicioScalarFieldEnum = (typeof ServicioScalarFieldEnum)[keyof typeof ServicioScalarFieldEnum]


  export const PrestadorScalarFieldEnum: {
    id_prestador: 'id_prestador',
    codigo: 'codigo',
    razon_social: 'razon_social',
    consecutivo: 'consecutivo'
  };

  export type PrestadorScalarFieldEnum = (typeof PrestadorScalarFieldEnum)[keyof typeof PrestadorScalarFieldEnum]


  export const EmpleadoScalarFieldEnum: {
    id_empleado: 'id_empleado',
    identificacion: 'identificacion',
    nombre: 'nombre',
    cargo: 'cargo',
    rol: 'rol',
    password: 'password',
    prestador: 'prestador'
  };

  export type EmpleadoScalarFieldEnum = (typeof EmpleadoScalarFieldEnum)[keyof typeof EmpleadoScalarFieldEnum]


  export const TarifaScalarFieldEnum: {
    id_tarifa: 'id_tarifa',
    nombre: 'nombre',
    precio: 'precio',
    estado: 'estado'
  };

  export type TarifaScalarFieldEnum = (typeof TarifaScalarFieldEnum)[keyof typeof TarifaScalarFieldEnum]


  export const ProtocoloScalarFieldEnum: {
    id_protocolo: 'id_protocolo',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type ProtocoloScalarFieldEnum = (typeof ProtocoloScalarFieldEnum)[keyof typeof ProtocoloScalarFieldEnum]


  export const EmpresaScalarFieldEnum: {
    id_empresa: 'id_empresa',
    nit: 'nit',
    codigo: 'codigo',
    nombre: 'nombre',
    sigla: 'sigla',
    tipo: 'tipo',
    estado: 'estado',
    municipio: 'municipio'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const ContratoScalarFieldEnum: {
    id_contrato: 'id_contrato',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    estado: 'estado',
    empresa: 'empresa'
  };

  export type ContratoScalarFieldEnum = (typeof ContratoScalarFieldEnum)[keyof typeof ContratoScalarFieldEnum]


  export const AcuerdoScalarFieldEnum: {
    id_acuerdo: 'id_acuerdo',
    estado: 'estado',
    contrato: 'contrato',
    valor: 'valor',
    tarifa: 'tarifa'
  };

  export type AcuerdoScalarFieldEnum = (typeof AcuerdoScalarFieldEnum)[keyof typeof AcuerdoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Tipo_Ident'
   */
  export type EnumTipo_IdentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Ident'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Sex'
   */
  export type EnumSexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sex'>
    


  /**
   * Reference to a field of type 'Tipo_Usuario'
   */
  export type EnumTipo_UsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Usuario'>
    


  /**
   * Reference to a field of type 'Estado'
   */
  export type EnumEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Estado'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Tipo_Empresa'
   */
  export type EnumTipo_EmpresaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_Empresa'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id_usuario?: IntFilter<"Usuario"> | number
    tipo_identificacion?: EnumTipo_IdentFilter<"Usuario"> | $Enums.Tipo_Ident
    identificacion?: StringFilter<"Usuario"> | string
    primer_nombre?: StringFilter<"Usuario"> | string
    segundo_nombre?: StringNullableFilter<"Usuario"> | string | null
    primer_apellido?: StringFilter<"Usuario"> | string
    segundo_apellido?: StringNullableFilter<"Usuario"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Usuario"> | Date | string
    sexo?: EnumSexFilter<"Usuario"> | $Enums.Sex
    email?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    tipo_usuario?: EnumTipo_UsuarioFilter<"Usuario"> | $Enums.Tipo_Usuario
    municipio?: IntFilter<"Usuario"> | number
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    createAt?: DateTimeFilter<"Usuario"> | Date | string
    updateAt?: DateTimeFilter<"Usuario"> | Date | string
    eps?: IntFilter<"Usuario"> | number
    procedimiento?: ProcedimientoListRelationFilter
    Municipio_Usuario?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    Eps_usuario?: XOR<EpsRelationFilter, EpsWhereInput>
  }

  export type UsuarioOrderByWithRelationInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrderInput | SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
    procedimiento?: ProcedimientoOrderByRelationAggregateInput
    Municipio_Usuario?: MunicipioOrderByWithRelationInput
    Eps_usuario?: EpsOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    tipo_identificacion?: EnumTipo_IdentFilter<"Usuario"> | $Enums.Tipo_Ident
    identificacion?: StringFilter<"Usuario"> | string
    primer_nombre?: StringFilter<"Usuario"> | string
    segundo_nombre?: StringNullableFilter<"Usuario"> | string | null
    primer_apellido?: StringFilter<"Usuario"> | string
    segundo_apellido?: StringNullableFilter<"Usuario"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Usuario"> | Date | string
    sexo?: EnumSexFilter<"Usuario"> | $Enums.Sex
    telefono?: StringNullableFilter<"Usuario"> | string | null
    tipo_usuario?: EnumTipo_UsuarioFilter<"Usuario"> | $Enums.Tipo_Usuario
    municipio?: IntFilter<"Usuario"> | number
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    createAt?: DateTimeFilter<"Usuario"> | Date | string
    updateAt?: DateTimeFilter<"Usuario"> | Date | string
    eps?: IntFilter<"Usuario"> | number
    procedimiento?: ProcedimientoListRelationFilter
    Municipio_Usuario?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    Eps_usuario?: XOR<EpsRelationFilter, EpsWhereInput>
  }, "id_usuario" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrderInput | SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"Usuario"> | number
    tipo_identificacion?: EnumTipo_IdentWithAggregatesFilter<"Usuario"> | $Enums.Tipo_Ident
    identificacion?: StringWithAggregatesFilter<"Usuario"> | string
    primer_nombre?: StringWithAggregatesFilter<"Usuario"> | string
    segundo_nombre?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    primer_apellido?: StringWithAggregatesFilter<"Usuario"> | string
    segundo_apellido?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    fecha_nacimiento?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    sexo?: EnumSexWithAggregatesFilter<"Usuario"> | $Enums.Sex
    email?: StringWithAggregatesFilter<"Usuario"> | string
    telefono?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    tipo_usuario?: EnumTipo_UsuarioWithAggregatesFilter<"Usuario"> | $Enums.Tipo_Usuario
    municipio?: IntWithAggregatesFilter<"Usuario"> | number
    estado?: EnumEstadoWithAggregatesFilter<"Usuario"> | $Enums.Estado
    createAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    eps?: IntWithAggregatesFilter<"Usuario"> | number
  }

  export type EpsWhereInput = {
    AND?: EpsWhereInput | EpsWhereInput[]
    OR?: EpsWhereInput[]
    NOT?: EpsWhereInput | EpsWhereInput[]
    id_eps?: IntFilter<"Eps"> | number
    codigo?: StringFilter<"Eps"> | string
    nombre?: StringFilter<"Eps"> | string
    estado?: EnumEstadoFilter<"Eps"> | $Enums.Estado
    usuario?: UsuarioListRelationFilter
  }

  export type EpsOrderByWithRelationInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    usuario?: UsuarioOrderByRelationAggregateInput
  }

  export type EpsWhereUniqueInput = Prisma.AtLeast<{
    id_eps?: number
    AND?: EpsWhereInput | EpsWhereInput[]
    OR?: EpsWhereInput[]
    NOT?: EpsWhereInput | EpsWhereInput[]
    codigo?: StringFilter<"Eps"> | string
    nombre?: StringFilter<"Eps"> | string
    estado?: EnumEstadoFilter<"Eps"> | $Enums.Estado
    usuario?: UsuarioListRelationFilter
  }, "id_eps">

  export type EpsOrderByWithAggregationInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    _count?: EpsCountOrderByAggregateInput
    _avg?: EpsAvgOrderByAggregateInput
    _max?: EpsMaxOrderByAggregateInput
    _min?: EpsMinOrderByAggregateInput
    _sum?: EpsSumOrderByAggregateInput
  }

  export type EpsScalarWhereWithAggregatesInput = {
    AND?: EpsScalarWhereWithAggregatesInput | EpsScalarWhereWithAggregatesInput[]
    OR?: EpsScalarWhereWithAggregatesInput[]
    NOT?: EpsScalarWhereWithAggregatesInput | EpsScalarWhereWithAggregatesInput[]
    id_eps?: IntWithAggregatesFilter<"Eps"> | number
    codigo?: StringWithAggregatesFilter<"Eps"> | string
    nombre?: StringWithAggregatesFilter<"Eps"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Eps"> | $Enums.Estado
  }

  export type ProcedimientoWhereInput = {
    AND?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    OR?: ProcedimientoWhereInput[]
    NOT?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    id_procedimiento?: IntFilter<"Procedimiento"> | number
    consecutivo?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    factura?: IntFilter<"Procedimiento"> | number
    usuario?: IntFilter<"Procedimiento"> | number
    acuerdo?: IntFilter<"Procedimiento"> | number
    Procedimiento_Acuerdo?: XOR<AcuerdoRelationFilter, AcuerdoWhereInput>
    Procedimiento_Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type ProcedimientoOrderByWithRelationInput = {
    id_procedimiento?: SortOrder
    consecutivo?: SortOrder
    fecha?: SortOrder
    factura?: SortOrder
    usuario?: SortOrder
    acuerdo?: SortOrder
    Procedimiento_Acuerdo?: AcuerdoOrderByWithRelationInput
    Procedimiento_Usuario?: UsuarioOrderByWithRelationInput
  }

  export type ProcedimientoWhereUniqueInput = Prisma.AtLeast<{
    id_procedimiento?: number
    AND?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    OR?: ProcedimientoWhereInput[]
    NOT?: ProcedimientoWhereInput | ProcedimientoWhereInput[]
    consecutivo?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    factura?: IntFilter<"Procedimiento"> | number
    usuario?: IntFilter<"Procedimiento"> | number
    acuerdo?: IntFilter<"Procedimiento"> | number
    Procedimiento_Acuerdo?: XOR<AcuerdoRelationFilter, AcuerdoWhereInput>
    Procedimiento_Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id_procedimiento">

  export type ProcedimientoOrderByWithAggregationInput = {
    id_procedimiento?: SortOrder
    consecutivo?: SortOrder
    fecha?: SortOrder
    factura?: SortOrder
    usuario?: SortOrder
    acuerdo?: SortOrder
    _count?: ProcedimientoCountOrderByAggregateInput
    _avg?: ProcedimientoAvgOrderByAggregateInput
    _max?: ProcedimientoMaxOrderByAggregateInput
    _min?: ProcedimientoMinOrderByAggregateInput
    _sum?: ProcedimientoSumOrderByAggregateInput
  }

  export type ProcedimientoScalarWhereWithAggregatesInput = {
    AND?: ProcedimientoScalarWhereWithAggregatesInput | ProcedimientoScalarWhereWithAggregatesInput[]
    OR?: ProcedimientoScalarWhereWithAggregatesInput[]
    NOT?: ProcedimientoScalarWhereWithAggregatesInput | ProcedimientoScalarWhereWithAggregatesInput[]
    id_procedimiento?: IntWithAggregatesFilter<"Procedimiento"> | number
    consecutivo?: IntWithAggregatesFilter<"Procedimiento"> | number
    fecha?: DateTimeWithAggregatesFilter<"Procedimiento"> | Date | string
    factura?: IntWithAggregatesFilter<"Procedimiento"> | number
    usuario?: IntWithAggregatesFilter<"Procedimiento"> | number
    acuerdo?: IntWithAggregatesFilter<"Procedimiento"> | number
  }

  export type DepartamentoWhereInput = {
    AND?: DepartamentoWhereInput | DepartamentoWhereInput[]
    OR?: DepartamentoWhereInput[]
    NOT?: DepartamentoWhereInput | DepartamentoWhereInput[]
    id_departamento?: IntFilter<"Departamento"> | number
    nombre?: StringFilter<"Departamento"> | string
    municipio?: MunicipioListRelationFilter
  }

  export type DepartamentoOrderByWithRelationInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
    municipio?: MunicipioOrderByRelationAggregateInput
  }

  export type DepartamentoWhereUniqueInput = Prisma.AtLeast<{
    id_departamento?: number
    AND?: DepartamentoWhereInput | DepartamentoWhereInput[]
    OR?: DepartamentoWhereInput[]
    NOT?: DepartamentoWhereInput | DepartamentoWhereInput[]
    nombre?: StringFilter<"Departamento"> | string
    municipio?: MunicipioListRelationFilter
  }, "id_departamento">

  export type DepartamentoOrderByWithAggregationInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
    _count?: DepartamentoCountOrderByAggregateInput
    _avg?: DepartamentoAvgOrderByAggregateInput
    _max?: DepartamentoMaxOrderByAggregateInput
    _min?: DepartamentoMinOrderByAggregateInput
    _sum?: DepartamentoSumOrderByAggregateInput
  }

  export type DepartamentoScalarWhereWithAggregatesInput = {
    AND?: DepartamentoScalarWhereWithAggregatesInput | DepartamentoScalarWhereWithAggregatesInput[]
    OR?: DepartamentoScalarWhereWithAggregatesInput[]
    NOT?: DepartamentoScalarWhereWithAggregatesInput | DepartamentoScalarWhereWithAggregatesInput[]
    id_departamento?: IntWithAggregatesFilter<"Departamento"> | number
    nombre?: StringWithAggregatesFilter<"Departamento"> | string
  }

  export type MunicipioWhereInput = {
    AND?: MunicipioWhereInput | MunicipioWhereInput[]
    OR?: MunicipioWhereInput[]
    NOT?: MunicipioWhereInput | MunicipioWhereInput[]
    id_municipio?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
    departamento?: IntFilter<"Municipio"> | number
    suario?: UsuarioListRelationFilter
    empresa?: EmpresaListRelationFilter
    Departamentos_Municipio?: XOR<DepartamentoRelationFilter, DepartamentoWhereInput>
  }

  export type MunicipioOrderByWithRelationInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
    suario?: UsuarioOrderByRelationAggregateInput
    empresa?: EmpresaOrderByRelationAggregateInput
    Departamentos_Municipio?: DepartamentoOrderByWithRelationInput
  }

  export type MunicipioWhereUniqueInput = Prisma.AtLeast<{
    id_municipio?: number
    AND?: MunicipioWhereInput | MunicipioWhereInput[]
    OR?: MunicipioWhereInput[]
    NOT?: MunicipioWhereInput | MunicipioWhereInput[]
    nombre?: StringFilter<"Municipio"> | string
    departamento?: IntFilter<"Municipio"> | number
    suario?: UsuarioListRelationFilter
    empresa?: EmpresaListRelationFilter
    Departamentos_Municipio?: XOR<DepartamentoRelationFilter, DepartamentoWhereInput>
  }, "id_municipio">

  export type MunicipioOrderByWithAggregationInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
    _count?: MunicipioCountOrderByAggregateInput
    _avg?: MunicipioAvgOrderByAggregateInput
    _max?: MunicipioMaxOrderByAggregateInput
    _min?: MunicipioMinOrderByAggregateInput
    _sum?: MunicipioSumOrderByAggregateInput
  }

  export type MunicipioScalarWhereWithAggregatesInput = {
    AND?: MunicipioScalarWhereWithAggregatesInput | MunicipioScalarWhereWithAggregatesInput[]
    OR?: MunicipioScalarWhereWithAggregatesInput[]
    NOT?: MunicipioScalarWhereWithAggregatesInput | MunicipioScalarWhereWithAggregatesInput[]
    id_municipio?: IntWithAggregatesFilter<"Municipio"> | number
    nombre?: StringWithAggregatesFilter<"Municipio"> | string
    departamento?: IntWithAggregatesFilter<"Municipio"> | number
  }

  export type ServicioWhereInput = {
    AND?: ServicioWhereInput | ServicioWhereInput[]
    OR?: ServicioWhereInput[]
    NOT?: ServicioWhereInput | ServicioWhereInput[]
    id_servicio?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    nivel?: IntFilter<"Servicio"> | number
    tarifa?: IntFilter<"Servicio"> | number
    protocolo?: IntFilter<"Servicio"> | number
    prestador?: IntFilter<"Servicio"> | number
    Tarifa_Servicio?: XOR<TarifaRelationFilter, TarifaWhereInput>
    Tarifa_Protocolo?: XOR<ProtocoloRelationFilter, ProtocoloWhereInput>
    Prestador_Servicio?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }

  export type ServicioOrderByWithRelationInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tarifa?: SortOrder
    protocolo?: SortOrder
    prestador?: SortOrder
    Tarifa_Servicio?: TarifaOrderByWithRelationInput
    Tarifa_Protocolo?: ProtocoloOrderByWithRelationInput
    Prestador_Servicio?: PrestadorOrderByWithRelationInput
  }

  export type ServicioWhereUniqueInput = Prisma.AtLeast<{
    id_servicio?: number
    AND?: ServicioWhereInput | ServicioWhereInput[]
    OR?: ServicioWhereInput[]
    NOT?: ServicioWhereInput | ServicioWhereInput[]
    nombre?: StringFilter<"Servicio"> | string
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    nivel?: IntFilter<"Servicio"> | number
    tarifa?: IntFilter<"Servicio"> | number
    protocolo?: IntFilter<"Servicio"> | number
    prestador?: IntFilter<"Servicio"> | number
    Tarifa_Servicio?: XOR<TarifaRelationFilter, TarifaWhereInput>
    Tarifa_Protocolo?: XOR<ProtocoloRelationFilter, ProtocoloWhereInput>
    Prestador_Servicio?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }, "id_servicio">

  export type ServicioOrderByWithAggregationInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tarifa?: SortOrder
    protocolo?: SortOrder
    prestador?: SortOrder
    _count?: ServicioCountOrderByAggregateInput
    _avg?: ServicioAvgOrderByAggregateInput
    _max?: ServicioMaxOrderByAggregateInput
    _min?: ServicioMinOrderByAggregateInput
    _sum?: ServicioSumOrderByAggregateInput
  }

  export type ServicioScalarWhereWithAggregatesInput = {
    AND?: ServicioScalarWhereWithAggregatesInput | ServicioScalarWhereWithAggregatesInput[]
    OR?: ServicioScalarWhereWithAggregatesInput[]
    NOT?: ServicioScalarWhereWithAggregatesInput | ServicioScalarWhereWithAggregatesInput[]
    id_servicio?: IntWithAggregatesFilter<"Servicio"> | number
    nombre?: StringWithAggregatesFilter<"Servicio"> | string
    precio?: DecimalWithAggregatesFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalWithAggregatesFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    nivel?: IntWithAggregatesFilter<"Servicio"> | number
    tarifa?: IntWithAggregatesFilter<"Servicio"> | number
    protocolo?: IntWithAggregatesFilter<"Servicio"> | number
    prestador?: IntWithAggregatesFilter<"Servicio"> | number
  }

  export type PrestadorWhereInput = {
    AND?: PrestadorWhereInput | PrestadorWhereInput[]
    OR?: PrestadorWhereInput[]
    NOT?: PrestadorWhereInput | PrestadorWhereInput[]
    id_prestador?: IntFilter<"Prestador"> | number
    codigo?: BigIntFilter<"Prestador"> | bigint | number
    razon_social?: StringFilter<"Prestador"> | string
    consecutivo?: IntFilter<"Prestador"> | number
    servicio?: ServicioListRelationFilter
    empleado?: EmpleadoListRelationFilter
  }

  export type PrestadorOrderByWithRelationInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    razon_social?: SortOrder
    consecutivo?: SortOrder
    servicio?: ServicioOrderByRelationAggregateInput
    empleado?: EmpleadoOrderByRelationAggregateInput
  }

  export type PrestadorWhereUniqueInput = Prisma.AtLeast<{
    id_prestador?: number
    AND?: PrestadorWhereInput | PrestadorWhereInput[]
    OR?: PrestadorWhereInput[]
    NOT?: PrestadorWhereInput | PrestadorWhereInput[]
    codigo?: BigIntFilter<"Prestador"> | bigint | number
    razon_social?: StringFilter<"Prestador"> | string
    consecutivo?: IntFilter<"Prestador"> | number
    servicio?: ServicioListRelationFilter
    empleado?: EmpleadoListRelationFilter
  }, "id_prestador">

  export type PrestadorOrderByWithAggregationInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    razon_social?: SortOrder
    consecutivo?: SortOrder
    _count?: PrestadorCountOrderByAggregateInput
    _avg?: PrestadorAvgOrderByAggregateInput
    _max?: PrestadorMaxOrderByAggregateInput
    _min?: PrestadorMinOrderByAggregateInput
    _sum?: PrestadorSumOrderByAggregateInput
  }

  export type PrestadorScalarWhereWithAggregatesInput = {
    AND?: PrestadorScalarWhereWithAggregatesInput | PrestadorScalarWhereWithAggregatesInput[]
    OR?: PrestadorScalarWhereWithAggregatesInput[]
    NOT?: PrestadorScalarWhereWithAggregatesInput | PrestadorScalarWhereWithAggregatesInput[]
    id_prestador?: IntWithAggregatesFilter<"Prestador"> | number
    codigo?: BigIntWithAggregatesFilter<"Prestador"> | bigint | number
    razon_social?: StringWithAggregatesFilter<"Prestador"> | string
    consecutivo?: IntWithAggregatesFilter<"Prestador"> | number
  }

  export type EmpleadoWhereInput = {
    AND?: EmpleadoWhereInput | EmpleadoWhereInput[]
    OR?: EmpleadoWhereInput[]
    NOT?: EmpleadoWhereInput | EmpleadoWhereInput[]
    id_empleado?: IntFilter<"Empleado"> | number
    identificacion?: BigIntFilter<"Empleado"> | bigint | number
    nombre?: StringFilter<"Empleado"> | string
    cargo?: StringFilter<"Empleado"> | string
    rol?: EnumRolFilter<"Empleado"> | $Enums.Rol
    password?: StringFilter<"Empleado"> | string
    prestador?: IntFilter<"Empleado"> | number
    Pretador_Empleado?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }

  export type EmpleadoOrderByWithRelationInput = {
    id_empleado?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    password?: SortOrder
    prestador?: SortOrder
    Pretador_Empleado?: PrestadorOrderByWithRelationInput
  }

  export type EmpleadoWhereUniqueInput = Prisma.AtLeast<{
    id_empleado?: number
    AND?: EmpleadoWhereInput | EmpleadoWhereInput[]
    OR?: EmpleadoWhereInput[]
    NOT?: EmpleadoWhereInput | EmpleadoWhereInput[]
    identificacion?: BigIntFilter<"Empleado"> | bigint | number
    nombre?: StringFilter<"Empleado"> | string
    cargo?: StringFilter<"Empleado"> | string
    rol?: EnumRolFilter<"Empleado"> | $Enums.Rol
    password?: StringFilter<"Empleado"> | string
    prestador?: IntFilter<"Empleado"> | number
    Pretador_Empleado?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
  }, "id_empleado">

  export type EmpleadoOrderByWithAggregationInput = {
    id_empleado?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    password?: SortOrder
    prestador?: SortOrder
    _count?: EmpleadoCountOrderByAggregateInput
    _avg?: EmpleadoAvgOrderByAggregateInput
    _max?: EmpleadoMaxOrderByAggregateInput
    _min?: EmpleadoMinOrderByAggregateInput
    _sum?: EmpleadoSumOrderByAggregateInput
  }

  export type EmpleadoScalarWhereWithAggregatesInput = {
    AND?: EmpleadoScalarWhereWithAggregatesInput | EmpleadoScalarWhereWithAggregatesInput[]
    OR?: EmpleadoScalarWhereWithAggregatesInput[]
    NOT?: EmpleadoScalarWhereWithAggregatesInput | EmpleadoScalarWhereWithAggregatesInput[]
    id_empleado?: IntWithAggregatesFilter<"Empleado"> | number
    identificacion?: BigIntWithAggregatesFilter<"Empleado"> | bigint | number
    nombre?: StringWithAggregatesFilter<"Empleado"> | string
    cargo?: StringWithAggregatesFilter<"Empleado"> | string
    rol?: EnumRolWithAggregatesFilter<"Empleado"> | $Enums.Rol
    password?: StringWithAggregatesFilter<"Empleado"> | string
    prestador?: IntWithAggregatesFilter<"Empleado"> | number
  }

  export type TarifaWhereInput = {
    AND?: TarifaWhereInput | TarifaWhereInput[]
    OR?: TarifaWhereInput[]
    NOT?: TarifaWhereInput | TarifaWhereInput[]
    id_tarifa?: IntFilter<"Tarifa"> | number
    nombre?: StringFilter<"Tarifa"> | string
    precio?: DecimalFilter<"Tarifa"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Tarifa"> | $Enums.Estado
    servicio?: ServicioListRelationFilter
    acuerdo?: AcuerdoListRelationFilter
  }

  export type TarifaOrderByWithRelationInput = {
    id_tarifa?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    servicio?: ServicioOrderByRelationAggregateInput
    acuerdo?: AcuerdoOrderByRelationAggregateInput
  }

  export type TarifaWhereUniqueInput = Prisma.AtLeast<{
    id_tarifa?: number
    AND?: TarifaWhereInput | TarifaWhereInput[]
    OR?: TarifaWhereInput[]
    NOT?: TarifaWhereInput | TarifaWhereInput[]
    nombre?: StringFilter<"Tarifa"> | string
    precio?: DecimalFilter<"Tarifa"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFilter<"Tarifa"> | $Enums.Estado
    servicio?: ServicioListRelationFilter
    acuerdo?: AcuerdoListRelationFilter
  }, "id_tarifa">

  export type TarifaOrderByWithAggregationInput = {
    id_tarifa?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
    _count?: TarifaCountOrderByAggregateInput
    _avg?: TarifaAvgOrderByAggregateInput
    _max?: TarifaMaxOrderByAggregateInput
    _min?: TarifaMinOrderByAggregateInput
    _sum?: TarifaSumOrderByAggregateInput
  }

  export type TarifaScalarWhereWithAggregatesInput = {
    AND?: TarifaScalarWhereWithAggregatesInput | TarifaScalarWhereWithAggregatesInput[]
    OR?: TarifaScalarWhereWithAggregatesInput[]
    NOT?: TarifaScalarWhereWithAggregatesInput | TarifaScalarWhereWithAggregatesInput[]
    id_tarifa?: IntWithAggregatesFilter<"Tarifa"> | number
    nombre?: StringWithAggregatesFilter<"Tarifa"> | string
    precio?: DecimalWithAggregatesFilter<"Tarifa"> | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoWithAggregatesFilter<"Tarifa"> | $Enums.Estado
  }

  export type ProtocoloWhereInput = {
    AND?: ProtocoloWhereInput | ProtocoloWhereInput[]
    OR?: ProtocoloWhereInput[]
    NOT?: ProtocoloWhereInput | ProtocoloWhereInput[]
    id_protocolo?: IntFilter<"Protocolo"> | number
    nombre?: StringFilter<"Protocolo"> | string
    estado?: EnumEstadoFilter<"Protocolo"> | $Enums.Estado
    servicio?: ServicioListRelationFilter
  }

  export type ProtocoloOrderByWithRelationInput = {
    id_protocolo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    servicio?: ServicioOrderByRelationAggregateInput
  }

  export type ProtocoloWhereUniqueInput = Prisma.AtLeast<{
    id_protocolo?: number
    AND?: ProtocoloWhereInput | ProtocoloWhereInput[]
    OR?: ProtocoloWhereInput[]
    NOT?: ProtocoloWhereInput | ProtocoloWhereInput[]
    nombre?: StringFilter<"Protocolo"> | string
    estado?: EnumEstadoFilter<"Protocolo"> | $Enums.Estado
    servicio?: ServicioListRelationFilter
  }, "id_protocolo">

  export type ProtocoloOrderByWithAggregationInput = {
    id_protocolo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    _count?: ProtocoloCountOrderByAggregateInput
    _avg?: ProtocoloAvgOrderByAggregateInput
    _max?: ProtocoloMaxOrderByAggregateInput
    _min?: ProtocoloMinOrderByAggregateInput
    _sum?: ProtocoloSumOrderByAggregateInput
  }

  export type ProtocoloScalarWhereWithAggregatesInput = {
    AND?: ProtocoloScalarWhereWithAggregatesInput | ProtocoloScalarWhereWithAggregatesInput[]
    OR?: ProtocoloScalarWhereWithAggregatesInput[]
    NOT?: ProtocoloScalarWhereWithAggregatesInput | ProtocoloScalarWhereWithAggregatesInput[]
    id_protocolo?: IntWithAggregatesFilter<"Protocolo"> | number
    nombre?: StringWithAggregatesFilter<"Protocolo"> | string
    estado?: EnumEstadoWithAggregatesFilter<"Protocolo"> | $Enums.Estado
  }

  export type EmpresaWhereInput = {
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    id_empresa?: IntFilter<"Empresa"> | number
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipio?: IntFilter<"Empresa"> | number
    contrato?: ContratoListRelationFilter
    Muncipio_Empresa?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
  }

  export type EmpresaOrderByWithRelationInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
    contrato?: ContratoOrderByRelationAggregateInput
    Muncipio_Empresa?: MunicipioOrderByWithRelationInput
  }

  export type EmpresaWhereUniqueInput = Prisma.AtLeast<{
    id_empresa?: number
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipio?: IntFilter<"Empresa"> | number
    contrato?: ContratoListRelationFilter
    Muncipio_Empresa?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
  }, "id_empresa">

  export type EmpresaOrderByWithAggregationInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
    _count?: EmpresaCountOrderByAggregateInput
    _avg?: EmpresaAvgOrderByAggregateInput
    _max?: EmpresaMaxOrderByAggregateInput
    _min?: EmpresaMinOrderByAggregateInput
    _sum?: EmpresaSumOrderByAggregateInput
  }

  export type EmpresaScalarWhereWithAggregatesInput = {
    AND?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    OR?: EmpresaScalarWhereWithAggregatesInput[]
    NOT?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    id_empresa?: IntWithAggregatesFilter<"Empresa"> | number
    nit?: StringWithAggregatesFilter<"Empresa"> | string
    codigo?: IntWithAggregatesFilter<"Empresa"> | number
    nombre?: StringWithAggregatesFilter<"Empresa"> | string
    sigla?: StringWithAggregatesFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaWithAggregatesFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoWithAggregatesFilter<"Empresa"> | $Enums.Estado
    municipio?: IntWithAggregatesFilter<"Empresa"> | number
  }

  export type ContratoWhereInput = {
    AND?: ContratoWhereInput | ContratoWhereInput[]
    OR?: ContratoWhereInput[]
    NOT?: ContratoWhereInput | ContratoWhereInput[]
    id_contrato?: IntFilter<"Contrato"> | number
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresa?: IntFilter<"Contrato"> | number
    acuerdo?: AcuerdoListRelationFilter
    Contrato_Empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type ContratoOrderByWithRelationInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
    acuerdo?: AcuerdoOrderByRelationAggregateInput
    Contrato_Empresa?: EmpresaOrderByWithRelationInput
  }

  export type ContratoWhereUniqueInput = Prisma.AtLeast<{
    id_contrato?: number
    AND?: ContratoWhereInput | ContratoWhereInput[]
    OR?: ContratoWhereInput[]
    NOT?: ContratoWhereInput | ContratoWhereInput[]
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresa?: IntFilter<"Contrato"> | number
    acuerdo?: AcuerdoListRelationFilter
    Contrato_Empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id_contrato">

  export type ContratoOrderByWithAggregationInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
    _count?: ContratoCountOrderByAggregateInput
    _avg?: ContratoAvgOrderByAggregateInput
    _max?: ContratoMaxOrderByAggregateInput
    _min?: ContratoMinOrderByAggregateInput
    _sum?: ContratoSumOrderByAggregateInput
  }

  export type ContratoScalarWhereWithAggregatesInput = {
    AND?: ContratoScalarWhereWithAggregatesInput | ContratoScalarWhereWithAggregatesInput[]
    OR?: ContratoScalarWhereWithAggregatesInput[]
    NOT?: ContratoScalarWhereWithAggregatesInput | ContratoScalarWhereWithAggregatesInput[]
    id_contrato?: IntWithAggregatesFilter<"Contrato"> | number
    fecha_inicio?: DateTimeWithAggregatesFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeWithAggregatesFilter<"Contrato"> | Date | string
    estado?: EnumEstadoWithAggregatesFilter<"Contrato"> | $Enums.Estado
    empresa?: IntWithAggregatesFilter<"Contrato"> | number
  }

  export type AcuerdoWhereInput = {
    AND?: AcuerdoWhereInput | AcuerdoWhereInput[]
    OR?: AcuerdoWhereInput[]
    NOT?: AcuerdoWhereInput | AcuerdoWhereInput[]
    id_acuerdo?: IntFilter<"Acuerdo"> | number
    estado?: EnumEstadoFilter<"Acuerdo"> | $Enums.Estado
    contrato?: IntFilter<"Acuerdo"> | number
    valor?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    tarifa?: IntFilter<"Acuerdo"> | number
    procedimiento?: ProcedimientoListRelationFilter
    Contrato_Acuerdo?: XOR<ContratoRelationFilter, ContratoWhereInput>
    Tarifa_Acuerdo?: XOR<TarifaRelationFilter, TarifaWhereInput>
  }

  export type AcuerdoOrderByWithRelationInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    valor?: SortOrder
    tarifa?: SortOrder
    procedimiento?: ProcedimientoOrderByRelationAggregateInput
    Contrato_Acuerdo?: ContratoOrderByWithRelationInput
    Tarifa_Acuerdo?: TarifaOrderByWithRelationInput
  }

  export type AcuerdoWhereUniqueInput = Prisma.AtLeast<{
    id_acuerdo?: number
    AND?: AcuerdoWhereInput | AcuerdoWhereInput[]
    OR?: AcuerdoWhereInput[]
    NOT?: AcuerdoWhereInput | AcuerdoWhereInput[]
    estado?: EnumEstadoFilter<"Acuerdo"> | $Enums.Estado
    contrato?: IntFilter<"Acuerdo"> | number
    valor?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    tarifa?: IntFilter<"Acuerdo"> | number
    procedimiento?: ProcedimientoListRelationFilter
    Contrato_Acuerdo?: XOR<ContratoRelationFilter, ContratoWhereInput>
    Tarifa_Acuerdo?: XOR<TarifaRelationFilter, TarifaWhereInput>
  }, "id_acuerdo">

  export type AcuerdoOrderByWithAggregationInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    valor?: SortOrder
    tarifa?: SortOrder
    _count?: AcuerdoCountOrderByAggregateInput
    _avg?: AcuerdoAvgOrderByAggregateInput
    _max?: AcuerdoMaxOrderByAggregateInput
    _min?: AcuerdoMinOrderByAggregateInput
    _sum?: AcuerdoSumOrderByAggregateInput
  }

  export type AcuerdoScalarWhereWithAggregatesInput = {
    AND?: AcuerdoScalarWhereWithAggregatesInput | AcuerdoScalarWhereWithAggregatesInput[]
    OR?: AcuerdoScalarWhereWithAggregatesInput[]
    NOT?: AcuerdoScalarWhereWithAggregatesInput | AcuerdoScalarWhereWithAggregatesInput[]
    id_acuerdo?: IntWithAggregatesFilter<"Acuerdo"> | number
    estado?: EnumEstadoWithAggregatesFilter<"Acuerdo"> | $Enums.Estado
    contrato?: IntWithAggregatesFilter<"Acuerdo"> | number
    valor?: DecimalWithAggregatesFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    tarifa?: IntWithAggregatesFilter<"Acuerdo"> | number
  }

  export type UsuarioCreateInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_UsuarioInput
    Municipio_Usuario: MunicipioCreateNestedOneWithoutSuarioInput
    Eps_usuario: EpsCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_UsuarioInput
  }

  export type UsuarioUpdateInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_UsuarioNestedInput
    Municipio_Usuario?: MunicipioUpdateOneRequiredWithoutSuarioNestedInput
    Eps_usuario?: EpsUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
  }

  export type UsuarioUpdateManyMutationInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
  }

  export type EpsCreateInput = {
    codigo: string
    nombre: string
    estado: $Enums.Estado
    usuario?: UsuarioCreateNestedManyWithoutEps_usuarioInput
  }

  export type EpsUncheckedCreateInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
    usuario?: UsuarioUncheckedCreateNestedManyWithoutEps_usuarioInput
  }

  export type EpsUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    usuario?: UsuarioUpdateManyWithoutEps_usuarioNestedInput
  }

  export type EpsUncheckedUpdateInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    usuario?: UsuarioUncheckedUpdateManyWithoutEps_usuarioNestedInput
  }

  export type EpsCreateManyInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
  }

  export type EpsUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EpsUncheckedUpdateManyInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ProcedimientoCreateInput = {
    consecutivo: number
    fecha: Date | string
    factura: number
    Procedimiento_Acuerdo: AcuerdoCreateNestedOneWithoutProcedimientoInput
    Procedimiento_Usuario: UsuarioCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateInput = {
    id_procedimiento?: number
    consecutivo: number
    fecha: Date | string
    factura: number
    usuario: number
    acuerdo: number
  }

  export type ProcedimientoUpdateInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    Procedimiento_Acuerdo?: AcuerdoUpdateOneRequiredWithoutProcedimientoNestedInput
    Procedimiento_Usuario?: UsuarioUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
    acuerdo?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoCreateManyInput = {
    id_procedimiento?: number
    consecutivo: number
    fecha: Date | string
    factura: number
    usuario: number
    acuerdo: number
  }

  export type ProcedimientoUpdateManyMutationInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoUncheckedUpdateManyInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
    acuerdo?: IntFieldUpdateOperationsInput | number
  }

  export type DepartamentoCreateInput = {
    nombre: string
    municipio?: MunicipioCreateNestedManyWithoutDepartamentos_MunicipioInput
  }

  export type DepartamentoUncheckedCreateInput = {
    id_departamento?: number
    nombre: string
    municipio?: MunicipioUncheckedCreateNestedManyWithoutDepartamentos_MunicipioInput
  }

  export type DepartamentoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    municipio?: MunicipioUpdateManyWithoutDepartamentos_MunicipioNestedInput
  }

  export type DepartamentoUncheckedUpdateInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    municipio?: MunicipioUncheckedUpdateManyWithoutDepartamentos_MunicipioNestedInput
  }

  export type DepartamentoCreateManyInput = {
    id_departamento?: number
    nombre: string
  }

  export type DepartamentoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentoUncheckedUpdateManyInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipioCreateInput = {
    nombre: string
    suario?: UsuarioCreateNestedManyWithoutMunicipio_UsuarioInput
    empresa?: EmpresaCreateNestedManyWithoutMuncipio_EmpresaInput
    Departamentos_Municipio: DepartamentoCreateNestedOneWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateInput = {
    id_municipio?: number
    nombre: string
    departamento: number
    suario?: UsuarioUncheckedCreateNestedManyWithoutMunicipio_UsuarioInput
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMuncipio_EmpresaInput
  }

  export type MunicipioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    suario?: UsuarioUpdateManyWithoutMunicipio_UsuarioNestedInput
    empresa?: EmpresaUpdateManyWithoutMuncipio_EmpresaNestedInput
    Departamentos_Municipio?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: IntFieldUpdateOperationsInput | number
    suario?: UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioNestedInput
    empresa?: EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaNestedInput
  }

  export type MunicipioCreateManyInput = {
    id_municipio?: number
    nombre: string
    departamento: number
  }

  export type MunicipioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipioUncheckedUpdateManyInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioCreateInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    Tarifa_Servicio: TarifaCreateNestedOneWithoutServicioInput
    Tarifa_Protocolo: ProtocoloCreateNestedOneWithoutServicioInput
    Prestador_Servicio: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa: number
    protocolo: number
    prestador: number
  }

  export type ServicioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    Tarifa_Servicio?: TarifaUpdateOneRequiredWithoutServicioNestedInput
    Tarifa_Protocolo?: ProtocoloUpdateOneRequiredWithoutServicioNestedInput
    Prestador_Servicio?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
    protocolo?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioCreateManyInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa: number
    protocolo: number
    prestador: number
  }

  export type ServicioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioUncheckedUpdateManyInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
    protocolo?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type PrestadorCreateInput = {
    codigo: bigint | number
    razon_social: string
    consecutivo: number
    servicio?: ServicioCreateNestedManyWithoutPrestador_ServicioInput
    empleado?: EmpleadoCreateNestedManyWithoutPretador_EmpleadoInput
  }

  export type PrestadorUncheckedCreateInput = {
    id_prestador?: number
    codigo: bigint | number
    razon_social: string
    consecutivo: number
    servicio?: ServicioUncheckedCreateNestedManyWithoutPrestador_ServicioInput
    empleado?: EmpleadoUncheckedCreateNestedManyWithoutPretador_EmpleadoInput
  }

  export type PrestadorUpdateInput = {
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    razon_social?: StringFieldUpdateOperationsInput | string
    consecutivo?: IntFieldUpdateOperationsInput | number
    servicio?: ServicioUpdateManyWithoutPrestador_ServicioNestedInput
    empleado?: EmpleadoUpdateManyWithoutPretador_EmpleadoNestedInput
  }

  export type PrestadorUncheckedUpdateInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    razon_social?: StringFieldUpdateOperationsInput | string
    consecutivo?: IntFieldUpdateOperationsInput | number
    servicio?: ServicioUncheckedUpdateManyWithoutPrestador_ServicioNestedInput
    empleado?: EmpleadoUncheckedUpdateManyWithoutPretador_EmpleadoNestedInput
  }

  export type PrestadorCreateManyInput = {
    id_prestador?: number
    codigo: bigint | number
    razon_social: string
    consecutivo: number
  }

  export type PrestadorUpdateManyMutationInput = {
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    razon_social?: StringFieldUpdateOperationsInput | string
    consecutivo?: IntFieldUpdateOperationsInput | number
  }

  export type PrestadorUncheckedUpdateManyInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    razon_social?: StringFieldUpdateOperationsInput | string
    consecutivo?: IntFieldUpdateOperationsInput | number
  }

  export type EmpleadoCreateInput = {
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    password: string
    Pretador_Empleado: PrestadorCreateNestedOneWithoutEmpleadoInput
  }

  export type EmpleadoUncheckedCreateInput = {
    id_empleado?: number
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    password: string
    prestador: number
  }

  export type EmpleadoUpdateInput = {
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    password?: StringFieldUpdateOperationsInput | string
    Pretador_Empleado?: PrestadorUpdateOneRequiredWithoutEmpleadoNestedInput
  }

  export type EmpleadoUncheckedUpdateInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    password?: StringFieldUpdateOperationsInput | string
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type EmpleadoCreateManyInput = {
    id_empleado?: number
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    password: string
    prestador: number
  }

  export type EmpleadoUpdateManyMutationInput = {
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    password?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadoUncheckedUpdateManyInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    password?: StringFieldUpdateOperationsInput | string
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type TarifaCreateInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    servicio?: ServicioCreateNestedManyWithoutTarifa_ServicioInput
    acuerdo?: AcuerdoCreateNestedManyWithoutTarifa_AcuerdoInput
  }

  export type TarifaUncheckedCreateInput = {
    id_tarifa?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    servicio?: ServicioUncheckedCreateNestedManyWithoutTarifa_ServicioInput
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutTarifa_AcuerdoInput
  }

  export type TarifaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUpdateManyWithoutTarifa_ServicioNestedInput
    acuerdo?: AcuerdoUpdateManyWithoutTarifa_AcuerdoNestedInput
  }

  export type TarifaUncheckedUpdateInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUncheckedUpdateManyWithoutTarifa_ServicioNestedInput
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutTarifa_AcuerdoNestedInput
  }

  export type TarifaCreateManyInput = {
    id_tarifa?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
  }

  export type TarifaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type TarifaUncheckedUpdateManyInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ProtocoloCreateInput = {
    nombre: string
    estado: $Enums.Estado
    servicio?: ServicioCreateNestedManyWithoutTarifa_ProtocoloInput
  }

  export type ProtocoloUncheckedCreateInput = {
    id_protocolo?: number
    nombre: string
    estado: $Enums.Estado
    servicio?: ServicioUncheckedCreateNestedManyWithoutTarifa_ProtocoloInput
  }

  export type ProtocoloUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUpdateManyWithoutTarifa_ProtocoloNestedInput
  }

  export type ProtocoloUncheckedUpdateInput = {
    id_protocolo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUncheckedUpdateManyWithoutTarifa_ProtocoloNestedInput
  }

  export type ProtocoloCreateManyInput = {
    id_protocolo?: number
    nombre: string
    estado: $Enums.Estado
  }

  export type ProtocoloUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ProtocoloUncheckedUpdateManyInput = {
    id_protocolo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EmpresaCreateInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    contrato?: ContratoCreateNestedManyWithoutContrato_EmpresaInput
    Muncipio_Empresa: MunicipioCreateNestedOneWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipio: number
    contrato?: ContratoUncheckedCreateNestedManyWithoutContrato_EmpresaInput
  }

  export type EmpresaUpdateInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: ContratoUpdateManyWithoutContrato_EmpresaNestedInput
    Muncipio_Empresa?: MunicipioUpdateOneRequiredWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: IntFieldUpdateOperationsInput | number
    contrato?: ContratoUncheckedUpdateManyWithoutContrato_EmpresaNestedInput
  }

  export type EmpresaCreateManyInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipio: number
  }

  export type EmpresaUpdateManyMutationInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EmpresaUncheckedUpdateManyInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: IntFieldUpdateOperationsInput | number
  }

  export type ContratoCreateInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    acuerdo?: AcuerdoCreateNestedManyWithoutContrato_AcuerdoInput
    Contrato_Empresa: EmpresaCreateNestedOneWithoutContratoInput
  }

  export type ContratoUncheckedCreateInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    empresa: number
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutContrato_AcuerdoInput
  }

  export type ContratoUpdateInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    acuerdo?: AcuerdoUpdateManyWithoutContrato_AcuerdoNestedInput
    Contrato_Empresa?: EmpresaUpdateOneRequiredWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: IntFieldUpdateOperationsInput | number
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutContrato_AcuerdoNestedInput
  }

  export type ContratoCreateManyInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    empresa: number
  }

  export type ContratoUpdateManyMutationInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ContratoUncheckedUpdateManyInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: IntFieldUpdateOperationsInput | number
  }

  export type AcuerdoCreateInput = {
    estado: $Enums.Estado
    valor: Decimal | DecimalJsLike | number | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_AcuerdoInput
    Contrato_Acuerdo: ContratoCreateNestedOneWithoutAcuerdoInput
    Tarifa_Acuerdo: TarifaCreateNestedOneWithoutAcuerdoInput
  }

  export type AcuerdoUncheckedCreateInput = {
    id_acuerdo?: number
    estado: $Enums.Estado
    contrato: number
    valor: Decimal | DecimalJsLike | number | string
    tarifa: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_AcuerdoInput
  }

  export type AcuerdoUpdateInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_AcuerdoNestedInput
    Contrato_Acuerdo?: ContratoUpdateOneRequiredWithoutAcuerdoNestedInput
    Tarifa_Acuerdo?: TarifaUpdateOneRequiredWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tarifa?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_AcuerdoNestedInput
  }

  export type AcuerdoCreateManyInput = {
    id_acuerdo?: number
    estado: $Enums.Estado
    contrato: number
    valor: Decimal | DecimalJsLike | number | string
    tarifa: number
  }

  export type AcuerdoUpdateManyMutationInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AcuerdoUncheckedUpdateManyInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tarifa?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumTipo_IdentFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentFilter<$PrismaModel> | $Enums.Tipo_Ident
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumSexFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexFilter<$PrismaModel> | $Enums.Sex
  }

  export type EnumTipo_UsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Usuario | EnumTipo_UsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Usuario[]
    notIn?: $Enums.Tipo_Usuario[]
    not?: NestedEnumTipo_UsuarioFilter<$PrismaModel> | $Enums.Tipo_Usuario
  }

  export type EnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type ProcedimientoListRelationFilter = {
    every?: ProcedimientoWhereInput
    some?: ProcedimientoWhereInput
    none?: ProcedimientoWhereInput
  }

  export type MunicipioRelationFilter = {
    is?: MunicipioWhereInput
    isNot?: MunicipioWhereInput
  }

  export type EpsRelationFilter = {
    is?: EpsWhereInput
    isNot?: EpsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProcedimientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    municipio?: SortOrder
    eps?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    tipo_identificacion?: SortOrder
    identificacion?: SortOrder
    primer_nombre?: SortOrder
    segundo_nombre?: SortOrder
    primer_apellido?: SortOrder
    segundo_apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    tipo_usuario?: SortOrder
    municipio?: SortOrder
    estado?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    eps?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    municipio?: SortOrder
    eps?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTipo_IdentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Ident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_IdentFilter<$PrismaModel>
    _max?: NestedEnumTipo_IdentFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexWithAggregatesFilter<$PrismaModel> | $Enums.Sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexFilter<$PrismaModel>
    _max?: NestedEnumSexFilter<$PrismaModel>
  }

  export type EnumTipo_UsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Usuario | EnumTipo_UsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Usuario[]
    notIn?: $Enums.Tipo_Usuario[]
    not?: NestedEnumTipo_UsuarioWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Usuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_UsuarioFilter<$PrismaModel>
    _max?: NestedEnumTipo_UsuarioFilter<$PrismaModel>
  }

  export type EnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EpsCountOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsAvgOrderByAggregateInput = {
    id_eps?: SortOrder
  }

  export type EpsMaxOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsMinOrderByAggregateInput = {
    id_eps?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type EpsSumOrderByAggregateInput = {
    id_eps?: SortOrder
  }

  export type AcuerdoRelationFilter = {
    is?: AcuerdoWhereInput
    isNot?: AcuerdoWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type ProcedimientoCountOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    consecutivo?: SortOrder
    fecha?: SortOrder
    factura?: SortOrder
    usuario?: SortOrder
    acuerdo?: SortOrder
  }

  export type ProcedimientoAvgOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    consecutivo?: SortOrder
    factura?: SortOrder
    usuario?: SortOrder
    acuerdo?: SortOrder
  }

  export type ProcedimientoMaxOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    consecutivo?: SortOrder
    fecha?: SortOrder
    factura?: SortOrder
    usuario?: SortOrder
    acuerdo?: SortOrder
  }

  export type ProcedimientoMinOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    consecutivo?: SortOrder
    fecha?: SortOrder
    factura?: SortOrder
    usuario?: SortOrder
    acuerdo?: SortOrder
  }

  export type ProcedimientoSumOrderByAggregateInput = {
    id_procedimiento?: SortOrder
    consecutivo?: SortOrder
    factura?: SortOrder
    usuario?: SortOrder
    acuerdo?: SortOrder
  }

  export type MunicipioListRelationFilter = {
    every?: MunicipioWhereInput
    some?: MunicipioWhereInput
    none?: MunicipioWhereInput
  }

  export type MunicipioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartamentoCountOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoAvgOrderByAggregateInput = {
    id_departamento?: SortOrder
  }

  export type DepartamentoMaxOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoMinOrderByAggregateInput = {
    id_departamento?: SortOrder
    nombre?: SortOrder
  }

  export type DepartamentoSumOrderByAggregateInput = {
    id_departamento?: SortOrder
  }

  export type EmpresaListRelationFilter = {
    every?: EmpresaWhereInput
    some?: EmpresaWhereInput
    none?: EmpresaWhereInput
  }

  export type DepartamentoRelationFilter = {
    is?: DepartamentoWhereInput
    isNot?: DepartamentoWhereInput
  }

  export type EmpresaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipioCountOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
  }

  export type MunicipioAvgOrderByAggregateInput = {
    id_municipio?: SortOrder
    departamento?: SortOrder
  }

  export type MunicipioMaxOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
  }

  export type MunicipioMinOrderByAggregateInput = {
    id_municipio?: SortOrder
    nombre?: SortOrder
    departamento?: SortOrder
  }

  export type MunicipioSumOrderByAggregateInput = {
    id_municipio?: SortOrder
    departamento?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TarifaRelationFilter = {
    is?: TarifaWhereInput
    isNot?: TarifaWhereInput
  }

  export type ProtocoloRelationFilter = {
    is?: ProtocoloWhereInput
    isNot?: ProtocoloWhereInput
  }

  export type PrestadorRelationFilter = {
    is?: PrestadorWhereInput
    isNot?: PrestadorWhereInput
  }

  export type ServicioCountOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tarifa?: SortOrder
    protocolo?: SortOrder
    prestador?: SortOrder
  }

  export type ServicioAvgOrderByAggregateInput = {
    id_servicio?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tarifa?: SortOrder
    protocolo?: SortOrder
    prestador?: SortOrder
  }

  export type ServicioMaxOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tarifa?: SortOrder
    protocolo?: SortOrder
    prestador?: SortOrder
  }

  export type ServicioMinOrderByAggregateInput = {
    id_servicio?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tarifa?: SortOrder
    protocolo?: SortOrder
    prestador?: SortOrder
  }

  export type ServicioSumOrderByAggregateInput = {
    id_servicio?: SortOrder
    precio?: SortOrder
    iva?: SortOrder
    nivel?: SortOrder
    tarifa?: SortOrder
    protocolo?: SortOrder
    prestador?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type ServicioListRelationFilter = {
    every?: ServicioWhereInput
    some?: ServicioWhereInput
    none?: ServicioWhereInput
  }

  export type EmpleadoListRelationFilter = {
    every?: EmpleadoWhereInput
    some?: EmpleadoWhereInput
    none?: EmpleadoWhereInput
  }

  export type ServicioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpleadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrestadorCountOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    razon_social?: SortOrder
    consecutivo?: SortOrder
  }

  export type PrestadorAvgOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    consecutivo?: SortOrder
  }

  export type PrestadorMaxOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    razon_social?: SortOrder
    consecutivo?: SortOrder
  }

  export type PrestadorMinOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    razon_social?: SortOrder
    consecutivo?: SortOrder
  }

  export type PrestadorSumOrderByAggregateInput = {
    id_prestador?: SortOrder
    codigo?: SortOrder
    consecutivo?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type EmpleadoCountOrderByAggregateInput = {
    id_empleado?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    password?: SortOrder
    prestador?: SortOrder
  }

  export type EmpleadoAvgOrderByAggregateInput = {
    id_empleado?: SortOrder
    identificacion?: SortOrder
    prestador?: SortOrder
  }

  export type EmpleadoMaxOrderByAggregateInput = {
    id_empleado?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    password?: SortOrder
    prestador?: SortOrder
  }

  export type EmpleadoMinOrderByAggregateInput = {
    id_empleado?: SortOrder
    identificacion?: SortOrder
    nombre?: SortOrder
    cargo?: SortOrder
    rol?: SortOrder
    password?: SortOrder
    prestador?: SortOrder
  }

  export type EmpleadoSumOrderByAggregateInput = {
    id_empleado?: SortOrder
    identificacion?: SortOrder
    prestador?: SortOrder
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type AcuerdoListRelationFilter = {
    every?: AcuerdoWhereInput
    some?: AcuerdoWhereInput
    none?: AcuerdoWhereInput
  }

  export type AcuerdoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TarifaCountOrderByAggregateInput = {
    id_tarifa?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
  }

  export type TarifaAvgOrderByAggregateInput = {
    id_tarifa?: SortOrder
    precio?: SortOrder
  }

  export type TarifaMaxOrderByAggregateInput = {
    id_tarifa?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
  }

  export type TarifaMinOrderByAggregateInput = {
    id_tarifa?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado?: SortOrder
  }

  export type TarifaSumOrderByAggregateInput = {
    id_tarifa?: SortOrder
    precio?: SortOrder
  }

  export type ProtocoloCountOrderByAggregateInput = {
    id_protocolo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type ProtocoloAvgOrderByAggregateInput = {
    id_protocolo?: SortOrder
  }

  export type ProtocoloMaxOrderByAggregateInput = {
    id_protocolo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type ProtocoloMinOrderByAggregateInput = {
    id_protocolo?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type ProtocoloSumOrderByAggregateInput = {
    id_protocolo?: SortOrder
  }

  export type EnumTipo_EmpresaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaFilter<$PrismaModel> | $Enums.Tipo_Empresa
  }

  export type ContratoListRelationFilter = {
    every?: ContratoWhereInput
    some?: ContratoWhereInput
    none?: ContratoWhereInput
  }

  export type ContratoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaCountOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
  }

  export type EmpresaAvgOrderByAggregateInput = {
    id_empresa?: SortOrder
    codigo?: SortOrder
    municipio?: SortOrder
  }

  export type EmpresaMaxOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
  }

  export type EmpresaMinOrderByAggregateInput = {
    id_empresa?: SortOrder
    nit?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    sigla?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    municipio?: SortOrder
  }

  export type EmpresaSumOrderByAggregateInput = {
    id_empresa?: SortOrder
    codigo?: SortOrder
    municipio?: SortOrder
  }

  export type EnumTipo_EmpresaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Empresa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
    _max?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
  }

  export type EmpresaRelationFilter = {
    is?: EmpresaWhereInput
    isNot?: EmpresaWhereInput
  }

  export type ContratoCountOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoAvgOrderByAggregateInput = {
    id_contrato?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoMaxOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoMinOrderByAggregateInput = {
    id_contrato?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoSumOrderByAggregateInput = {
    id_contrato?: SortOrder
    empresa?: SortOrder
  }

  export type ContratoRelationFilter = {
    is?: ContratoWhereInput
    isNot?: ContratoWhereInput
  }

  export type AcuerdoCountOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    valor?: SortOrder
    tarifa?: SortOrder
  }

  export type AcuerdoAvgOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    contrato?: SortOrder
    valor?: SortOrder
    tarifa?: SortOrder
  }

  export type AcuerdoMaxOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    valor?: SortOrder
    tarifa?: SortOrder
  }

  export type AcuerdoMinOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    valor?: SortOrder
    tarifa?: SortOrder
  }

  export type AcuerdoSumOrderByAggregateInput = {
    id_acuerdo?: SortOrder
    contrato?: SortOrder
    valor?: SortOrder
    tarifa?: SortOrder
  }

  export type ProcedimientoCreateNestedManyWithoutProcedimiento_UsuarioInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput> | ProcedimientoCreateWithoutProcedimiento_UsuarioInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput | ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type MunicipioCreateNestedOneWithoutSuarioInput = {
    create?: XOR<MunicipioCreateWithoutSuarioInput, MunicipioUncheckedCreateWithoutSuarioInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutSuarioInput
    connect?: MunicipioWhereUniqueInput
  }

  export type EpsCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EpsCreateWithoutUsuarioInput, EpsUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EpsCreateOrConnectWithoutUsuarioInput
    connect?: EpsWhereUniqueInput
  }

  export type ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_UsuarioInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput> | ProcedimientoCreateWithoutProcedimiento_UsuarioInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput | ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type EnumTipo_IdentFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Ident
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumSexFieldUpdateOperationsInput = {
    set?: $Enums.Sex
  }

  export type EnumTipo_UsuarioFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Usuario
  }

  export type EnumEstadoFieldUpdateOperationsInput = {
    set?: $Enums.Estado
  }

  export type ProcedimientoUpdateManyWithoutProcedimiento_UsuarioNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput> | ProcedimientoCreateWithoutProcedimiento_UsuarioInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput | ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput | ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput | ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput | ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type MunicipioUpdateOneRequiredWithoutSuarioNestedInput = {
    create?: XOR<MunicipioCreateWithoutSuarioInput, MunicipioUncheckedCreateWithoutSuarioInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutSuarioInput
    upsert?: MunicipioUpsertWithoutSuarioInput
    connect?: MunicipioWhereUniqueInput
    update?: XOR<XOR<MunicipioUpdateToOneWithWhereWithoutSuarioInput, MunicipioUpdateWithoutSuarioInput>, MunicipioUncheckedUpdateWithoutSuarioInput>
  }

  export type EpsUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<EpsCreateWithoutUsuarioInput, EpsUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EpsCreateOrConnectWithoutUsuarioInput
    upsert?: EpsUpsertWithoutUsuarioInput
    connect?: EpsWhereUniqueInput
    update?: XOR<XOR<EpsUpdateToOneWithWhereWithoutUsuarioInput, EpsUpdateWithoutUsuarioInput>, EpsUncheckedUpdateWithoutUsuarioInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput> | ProcedimientoCreateWithoutProcedimiento_UsuarioInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput | ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput | ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput | ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput | ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type UsuarioCreateNestedManyWithoutEps_usuarioInput = {
    create?: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput> | UsuarioCreateWithoutEps_usuarioInput[] | UsuarioUncheckedCreateWithoutEps_usuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEps_usuarioInput | UsuarioCreateOrConnectWithoutEps_usuarioInput[]
    createMany?: UsuarioCreateManyEps_usuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutEps_usuarioInput = {
    create?: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput> | UsuarioCreateWithoutEps_usuarioInput[] | UsuarioUncheckedCreateWithoutEps_usuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEps_usuarioInput | UsuarioCreateOrConnectWithoutEps_usuarioInput[]
    createMany?: UsuarioCreateManyEps_usuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUpdateManyWithoutEps_usuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput> | UsuarioCreateWithoutEps_usuarioInput[] | UsuarioUncheckedCreateWithoutEps_usuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEps_usuarioInput | UsuarioCreateOrConnectWithoutEps_usuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput | UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput[]
    createMany?: UsuarioCreateManyEps_usuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput | UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutEps_usuarioInput | UsuarioUpdateManyWithWhereWithoutEps_usuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutEps_usuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput> | UsuarioCreateWithoutEps_usuarioInput[] | UsuarioUncheckedCreateWithoutEps_usuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEps_usuarioInput | UsuarioCreateOrConnectWithoutEps_usuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput | UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput[]
    createMany?: UsuarioCreateManyEps_usuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput | UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutEps_usuarioInput | UsuarioUpdateManyWithWhereWithoutEps_usuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type AcuerdoCreateNestedOneWithoutProcedimientoInput = {
    create?: XOR<AcuerdoCreateWithoutProcedimientoInput, AcuerdoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: AcuerdoCreateOrConnectWithoutProcedimientoInput
    connect?: AcuerdoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutProcedimientoInput = {
    create?: XOR<UsuarioCreateWithoutProcedimientoInput, UsuarioUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProcedimientoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type AcuerdoUpdateOneRequiredWithoutProcedimientoNestedInput = {
    create?: XOR<AcuerdoCreateWithoutProcedimientoInput, AcuerdoUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: AcuerdoCreateOrConnectWithoutProcedimientoInput
    upsert?: AcuerdoUpsertWithoutProcedimientoInput
    connect?: AcuerdoWhereUniqueInput
    update?: XOR<XOR<AcuerdoUpdateToOneWithWhereWithoutProcedimientoInput, AcuerdoUpdateWithoutProcedimientoInput>, AcuerdoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type UsuarioUpdateOneRequiredWithoutProcedimientoNestedInput = {
    create?: XOR<UsuarioCreateWithoutProcedimientoInput, UsuarioUncheckedCreateWithoutProcedimientoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProcedimientoInput
    upsert?: UsuarioUpsertWithoutProcedimientoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutProcedimientoInput, UsuarioUpdateWithoutProcedimientoInput>, UsuarioUncheckedUpdateWithoutProcedimientoInput>
  }

  export type MunicipioCreateNestedManyWithoutDepartamentos_MunicipioInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput> | MunicipioCreateWithoutDepartamentos_MunicipioInput[] | MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput | MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput[]
    createMany?: MunicipioCreateManyDepartamentos_MunicipioInputEnvelope
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
  }

  export type MunicipioUncheckedCreateNestedManyWithoutDepartamentos_MunicipioInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput> | MunicipioCreateWithoutDepartamentos_MunicipioInput[] | MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput | MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput[]
    createMany?: MunicipioCreateManyDepartamentos_MunicipioInputEnvelope
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
  }

  export type MunicipioUpdateManyWithoutDepartamentos_MunicipioNestedInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput> | MunicipioCreateWithoutDepartamentos_MunicipioInput[] | MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput | MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput[]
    upsert?: MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput | MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput[]
    createMany?: MunicipioCreateManyDepartamentos_MunicipioInputEnvelope
    set?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    disconnect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    delete?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    update?: MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput | MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput[]
    updateMany?: MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput | MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput[]
    deleteMany?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
  }

  export type MunicipioUncheckedUpdateManyWithoutDepartamentos_MunicipioNestedInput = {
    create?: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput> | MunicipioCreateWithoutDepartamentos_MunicipioInput[] | MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput | MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput[]
    upsert?: MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput | MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput[]
    createMany?: MunicipioCreateManyDepartamentos_MunicipioInputEnvelope
    set?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    disconnect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    delete?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    update?: MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput | MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput[]
    updateMany?: MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput | MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput[]
    deleteMany?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
  }

  export type UsuarioCreateNestedManyWithoutMunicipio_UsuarioInput = {
    create?: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput> | UsuarioCreateWithoutMunicipio_UsuarioInput[] | UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput | UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput[]
    createMany?: UsuarioCreateManyMunicipio_UsuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EmpresaCreateNestedManyWithoutMuncipio_EmpresaInput = {
    create?: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput> | EmpresaCreateWithoutMuncipio_EmpresaInput[] | EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput | EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput[]
    createMany?: EmpresaCreateManyMuncipio_EmpresaInputEnvelope
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
  }

  export type DepartamentoCreateNestedOneWithoutMunicipioInput = {
    create?: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    connectOrCreate?: DepartamentoCreateOrConnectWithoutMunicipioInput
    connect?: DepartamentoWhereUniqueInput
  }

  export type UsuarioUncheckedCreateNestedManyWithoutMunicipio_UsuarioInput = {
    create?: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput> | UsuarioCreateWithoutMunicipio_UsuarioInput[] | UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput | UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput[]
    createMany?: UsuarioCreateManyMunicipio_UsuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EmpresaUncheckedCreateNestedManyWithoutMuncipio_EmpresaInput = {
    create?: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput> | EmpresaCreateWithoutMuncipio_EmpresaInput[] | EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput | EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput[]
    createMany?: EmpresaCreateManyMuncipio_EmpresaInputEnvelope
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
  }

  export type UsuarioUpdateManyWithoutMunicipio_UsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput> | UsuarioCreateWithoutMunicipio_UsuarioInput[] | UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput | UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput | UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput[]
    createMany?: UsuarioCreateManyMunicipio_UsuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput | UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput | UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EmpresaUpdateManyWithoutMuncipio_EmpresaNestedInput = {
    create?: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput> | EmpresaCreateWithoutMuncipio_EmpresaInput[] | EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput | EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput[]
    upsert?: EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput | EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput[]
    createMany?: EmpresaCreateManyMuncipio_EmpresaInputEnvelope
    set?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    disconnect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    delete?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    update?: EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput | EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput[]
    updateMany?: EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput | EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput[]
    deleteMany?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
  }

  export type DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput = {
    create?: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    connectOrCreate?: DepartamentoCreateOrConnectWithoutMunicipioInput
    upsert?: DepartamentoUpsertWithoutMunicipioInput
    connect?: DepartamentoWhereUniqueInput
    update?: XOR<XOR<DepartamentoUpdateToOneWithWhereWithoutMunicipioInput, DepartamentoUpdateWithoutMunicipioInput>, DepartamentoUncheckedUpdateWithoutMunicipioInput>
  }

  export type UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput> | UsuarioCreateWithoutMunicipio_UsuarioInput[] | UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput | UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput | UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput[]
    createMany?: UsuarioCreateManyMunicipio_UsuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput | UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput | UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaNestedInput = {
    create?: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput> | EmpresaCreateWithoutMuncipio_EmpresaInput[] | EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput[]
    connectOrCreate?: EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput | EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput[]
    upsert?: EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput | EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput[]
    createMany?: EmpresaCreateManyMuncipio_EmpresaInputEnvelope
    set?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    disconnect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    delete?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    connect?: EmpresaWhereUniqueInput | EmpresaWhereUniqueInput[]
    update?: EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput | EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput[]
    updateMany?: EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput | EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput[]
    deleteMany?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
  }

  export type TarifaCreateNestedOneWithoutServicioInput = {
    create?: XOR<TarifaCreateWithoutServicioInput, TarifaUncheckedCreateWithoutServicioInput>
    connectOrCreate?: TarifaCreateOrConnectWithoutServicioInput
    connect?: TarifaWhereUniqueInput
  }

  export type ProtocoloCreateNestedOneWithoutServicioInput = {
    create?: XOR<ProtocoloCreateWithoutServicioInput, ProtocoloUncheckedCreateWithoutServicioInput>
    connectOrCreate?: ProtocoloCreateOrConnectWithoutServicioInput
    connect?: ProtocoloWhereUniqueInput
  }

  export type PrestadorCreateNestedOneWithoutServicioInput = {
    create?: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutServicioInput
    connect?: PrestadorWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TarifaUpdateOneRequiredWithoutServicioNestedInput = {
    create?: XOR<TarifaCreateWithoutServicioInput, TarifaUncheckedCreateWithoutServicioInput>
    connectOrCreate?: TarifaCreateOrConnectWithoutServicioInput
    upsert?: TarifaUpsertWithoutServicioInput
    connect?: TarifaWhereUniqueInput
    update?: XOR<XOR<TarifaUpdateToOneWithWhereWithoutServicioInput, TarifaUpdateWithoutServicioInput>, TarifaUncheckedUpdateWithoutServicioInput>
  }

  export type ProtocoloUpdateOneRequiredWithoutServicioNestedInput = {
    create?: XOR<ProtocoloCreateWithoutServicioInput, ProtocoloUncheckedCreateWithoutServicioInput>
    connectOrCreate?: ProtocoloCreateOrConnectWithoutServicioInput
    upsert?: ProtocoloUpsertWithoutServicioInput
    connect?: ProtocoloWhereUniqueInput
    update?: XOR<XOR<ProtocoloUpdateToOneWithWhereWithoutServicioInput, ProtocoloUpdateWithoutServicioInput>, ProtocoloUncheckedUpdateWithoutServicioInput>
  }

  export type PrestadorUpdateOneRequiredWithoutServicioNestedInput = {
    create?: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutServicioInput
    upsert?: PrestadorUpsertWithoutServicioInput
    connect?: PrestadorWhereUniqueInput
    update?: XOR<XOR<PrestadorUpdateToOneWithWhereWithoutServicioInput, PrestadorUpdateWithoutServicioInput>, PrestadorUncheckedUpdateWithoutServicioInput>
  }

  export type ServicioCreateNestedManyWithoutPrestador_ServicioInput = {
    create?: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput> | ServicioCreateWithoutPrestador_ServicioInput[] | ServicioUncheckedCreateWithoutPrestador_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestador_ServicioInput | ServicioCreateOrConnectWithoutPrestador_ServicioInput[]
    createMany?: ServicioCreateManyPrestador_ServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type EmpleadoCreateNestedManyWithoutPretador_EmpleadoInput = {
    create?: XOR<EmpleadoCreateWithoutPretador_EmpleadoInput, EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput> | EmpleadoCreateWithoutPretador_EmpleadoInput[] | EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput[]
    connectOrCreate?: EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput | EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput[]
    createMany?: EmpleadoCreateManyPretador_EmpleadoInputEnvelope
    connect?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
  }

  export type ServicioUncheckedCreateNestedManyWithoutPrestador_ServicioInput = {
    create?: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput> | ServicioCreateWithoutPrestador_ServicioInput[] | ServicioUncheckedCreateWithoutPrestador_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestador_ServicioInput | ServicioCreateOrConnectWithoutPrestador_ServicioInput[]
    createMany?: ServicioCreateManyPrestador_ServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type EmpleadoUncheckedCreateNestedManyWithoutPretador_EmpleadoInput = {
    create?: XOR<EmpleadoCreateWithoutPretador_EmpleadoInput, EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput> | EmpleadoCreateWithoutPretador_EmpleadoInput[] | EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput[]
    connectOrCreate?: EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput | EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput[]
    createMany?: EmpleadoCreateManyPretador_EmpleadoInputEnvelope
    connect?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ServicioUpdateManyWithoutPrestador_ServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput> | ServicioCreateWithoutPrestador_ServicioInput[] | ServicioUncheckedCreateWithoutPrestador_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestador_ServicioInput | ServicioCreateOrConnectWithoutPrestador_ServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput | ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput[]
    createMany?: ServicioCreateManyPrestador_ServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput | ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput | ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type EmpleadoUpdateManyWithoutPretador_EmpleadoNestedInput = {
    create?: XOR<EmpleadoCreateWithoutPretador_EmpleadoInput, EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput> | EmpleadoCreateWithoutPretador_EmpleadoInput[] | EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput[]
    connectOrCreate?: EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput | EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput[]
    upsert?: EmpleadoUpsertWithWhereUniqueWithoutPretador_EmpleadoInput | EmpleadoUpsertWithWhereUniqueWithoutPretador_EmpleadoInput[]
    createMany?: EmpleadoCreateManyPretador_EmpleadoInputEnvelope
    set?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
    disconnect?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
    delete?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
    connect?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
    update?: EmpleadoUpdateWithWhereUniqueWithoutPretador_EmpleadoInput | EmpleadoUpdateWithWhereUniqueWithoutPretador_EmpleadoInput[]
    updateMany?: EmpleadoUpdateManyWithWhereWithoutPretador_EmpleadoInput | EmpleadoUpdateManyWithWhereWithoutPretador_EmpleadoInput[]
    deleteMany?: EmpleadoScalarWhereInput | EmpleadoScalarWhereInput[]
  }

  export type ServicioUncheckedUpdateManyWithoutPrestador_ServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput> | ServicioCreateWithoutPrestador_ServicioInput[] | ServicioUncheckedCreateWithoutPrestador_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutPrestador_ServicioInput | ServicioCreateOrConnectWithoutPrestador_ServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput | ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput[]
    createMany?: ServicioCreateManyPrestador_ServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput | ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput | ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type EmpleadoUncheckedUpdateManyWithoutPretador_EmpleadoNestedInput = {
    create?: XOR<EmpleadoCreateWithoutPretador_EmpleadoInput, EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput> | EmpleadoCreateWithoutPretador_EmpleadoInput[] | EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput[]
    connectOrCreate?: EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput | EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput[]
    upsert?: EmpleadoUpsertWithWhereUniqueWithoutPretador_EmpleadoInput | EmpleadoUpsertWithWhereUniqueWithoutPretador_EmpleadoInput[]
    createMany?: EmpleadoCreateManyPretador_EmpleadoInputEnvelope
    set?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
    disconnect?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
    delete?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
    connect?: EmpleadoWhereUniqueInput | EmpleadoWhereUniqueInput[]
    update?: EmpleadoUpdateWithWhereUniqueWithoutPretador_EmpleadoInput | EmpleadoUpdateWithWhereUniqueWithoutPretador_EmpleadoInput[]
    updateMany?: EmpleadoUpdateManyWithWhereWithoutPretador_EmpleadoInput | EmpleadoUpdateManyWithWhereWithoutPretador_EmpleadoInput[]
    deleteMany?: EmpleadoScalarWhereInput | EmpleadoScalarWhereInput[]
  }

  export type PrestadorCreateNestedOneWithoutEmpleadoInput = {
    create?: XOR<PrestadorCreateWithoutEmpleadoInput, PrestadorUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutEmpleadoInput
    connect?: PrestadorWhereUniqueInput
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type PrestadorUpdateOneRequiredWithoutEmpleadoNestedInput = {
    create?: XOR<PrestadorCreateWithoutEmpleadoInput, PrestadorUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutEmpleadoInput
    upsert?: PrestadorUpsertWithoutEmpleadoInput
    connect?: PrestadorWhereUniqueInput
    update?: XOR<XOR<PrestadorUpdateToOneWithWhereWithoutEmpleadoInput, PrestadorUpdateWithoutEmpleadoInput>, PrestadorUncheckedUpdateWithoutEmpleadoInput>
  }

  export type ServicioCreateNestedManyWithoutTarifa_ServicioInput = {
    create?: XOR<ServicioCreateWithoutTarifa_ServicioInput, ServicioUncheckedCreateWithoutTarifa_ServicioInput> | ServicioCreateWithoutTarifa_ServicioInput[] | ServicioUncheckedCreateWithoutTarifa_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifa_ServicioInput | ServicioCreateOrConnectWithoutTarifa_ServicioInput[]
    createMany?: ServicioCreateManyTarifa_ServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type AcuerdoCreateNestedManyWithoutTarifa_AcuerdoInput = {
    create?: XOR<AcuerdoCreateWithoutTarifa_AcuerdoInput, AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput> | AcuerdoCreateWithoutTarifa_AcuerdoInput[] | AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput | AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput[]
    createMany?: AcuerdoCreateManyTarifa_AcuerdoInputEnvelope
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
  }

  export type ServicioUncheckedCreateNestedManyWithoutTarifa_ServicioInput = {
    create?: XOR<ServicioCreateWithoutTarifa_ServicioInput, ServicioUncheckedCreateWithoutTarifa_ServicioInput> | ServicioCreateWithoutTarifa_ServicioInput[] | ServicioUncheckedCreateWithoutTarifa_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifa_ServicioInput | ServicioCreateOrConnectWithoutTarifa_ServicioInput[]
    createMany?: ServicioCreateManyTarifa_ServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type AcuerdoUncheckedCreateNestedManyWithoutTarifa_AcuerdoInput = {
    create?: XOR<AcuerdoCreateWithoutTarifa_AcuerdoInput, AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput> | AcuerdoCreateWithoutTarifa_AcuerdoInput[] | AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput | AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput[]
    createMany?: AcuerdoCreateManyTarifa_AcuerdoInputEnvelope
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
  }

  export type ServicioUpdateManyWithoutTarifa_ServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutTarifa_ServicioInput, ServicioUncheckedCreateWithoutTarifa_ServicioInput> | ServicioCreateWithoutTarifa_ServicioInput[] | ServicioUncheckedCreateWithoutTarifa_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifa_ServicioInput | ServicioCreateOrConnectWithoutTarifa_ServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutTarifa_ServicioInput | ServicioUpsertWithWhereUniqueWithoutTarifa_ServicioInput[]
    createMany?: ServicioCreateManyTarifa_ServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutTarifa_ServicioInput | ServicioUpdateWithWhereUniqueWithoutTarifa_ServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutTarifa_ServicioInput | ServicioUpdateManyWithWhereWithoutTarifa_ServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type AcuerdoUpdateManyWithoutTarifa_AcuerdoNestedInput = {
    create?: XOR<AcuerdoCreateWithoutTarifa_AcuerdoInput, AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput> | AcuerdoCreateWithoutTarifa_AcuerdoInput[] | AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput | AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput[]
    upsert?: AcuerdoUpsertWithWhereUniqueWithoutTarifa_AcuerdoInput | AcuerdoUpsertWithWhereUniqueWithoutTarifa_AcuerdoInput[]
    createMany?: AcuerdoCreateManyTarifa_AcuerdoInputEnvelope
    set?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    disconnect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    delete?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    update?: AcuerdoUpdateWithWhereUniqueWithoutTarifa_AcuerdoInput | AcuerdoUpdateWithWhereUniqueWithoutTarifa_AcuerdoInput[]
    updateMany?: AcuerdoUpdateManyWithWhereWithoutTarifa_AcuerdoInput | AcuerdoUpdateManyWithWhereWithoutTarifa_AcuerdoInput[]
    deleteMany?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
  }

  export type ServicioUncheckedUpdateManyWithoutTarifa_ServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutTarifa_ServicioInput, ServicioUncheckedCreateWithoutTarifa_ServicioInput> | ServicioCreateWithoutTarifa_ServicioInput[] | ServicioUncheckedCreateWithoutTarifa_ServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifa_ServicioInput | ServicioCreateOrConnectWithoutTarifa_ServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutTarifa_ServicioInput | ServicioUpsertWithWhereUniqueWithoutTarifa_ServicioInput[]
    createMany?: ServicioCreateManyTarifa_ServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutTarifa_ServicioInput | ServicioUpdateWithWhereUniqueWithoutTarifa_ServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutTarifa_ServicioInput | ServicioUpdateManyWithWhereWithoutTarifa_ServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type AcuerdoUncheckedUpdateManyWithoutTarifa_AcuerdoNestedInput = {
    create?: XOR<AcuerdoCreateWithoutTarifa_AcuerdoInput, AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput> | AcuerdoCreateWithoutTarifa_AcuerdoInput[] | AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput | AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput[]
    upsert?: AcuerdoUpsertWithWhereUniqueWithoutTarifa_AcuerdoInput | AcuerdoUpsertWithWhereUniqueWithoutTarifa_AcuerdoInput[]
    createMany?: AcuerdoCreateManyTarifa_AcuerdoInputEnvelope
    set?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    disconnect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    delete?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    update?: AcuerdoUpdateWithWhereUniqueWithoutTarifa_AcuerdoInput | AcuerdoUpdateWithWhereUniqueWithoutTarifa_AcuerdoInput[]
    updateMany?: AcuerdoUpdateManyWithWhereWithoutTarifa_AcuerdoInput | AcuerdoUpdateManyWithWhereWithoutTarifa_AcuerdoInput[]
    deleteMany?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
  }

  export type ServicioCreateNestedManyWithoutTarifa_ProtocoloInput = {
    create?: XOR<ServicioCreateWithoutTarifa_ProtocoloInput, ServicioUncheckedCreateWithoutTarifa_ProtocoloInput> | ServicioCreateWithoutTarifa_ProtocoloInput[] | ServicioUncheckedCreateWithoutTarifa_ProtocoloInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifa_ProtocoloInput | ServicioCreateOrConnectWithoutTarifa_ProtocoloInput[]
    createMany?: ServicioCreateManyTarifa_ProtocoloInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ServicioUncheckedCreateNestedManyWithoutTarifa_ProtocoloInput = {
    create?: XOR<ServicioCreateWithoutTarifa_ProtocoloInput, ServicioUncheckedCreateWithoutTarifa_ProtocoloInput> | ServicioCreateWithoutTarifa_ProtocoloInput[] | ServicioUncheckedCreateWithoutTarifa_ProtocoloInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifa_ProtocoloInput | ServicioCreateOrConnectWithoutTarifa_ProtocoloInput[]
    createMany?: ServicioCreateManyTarifa_ProtocoloInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ServicioUpdateManyWithoutTarifa_ProtocoloNestedInput = {
    create?: XOR<ServicioCreateWithoutTarifa_ProtocoloInput, ServicioUncheckedCreateWithoutTarifa_ProtocoloInput> | ServicioCreateWithoutTarifa_ProtocoloInput[] | ServicioUncheckedCreateWithoutTarifa_ProtocoloInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifa_ProtocoloInput | ServicioCreateOrConnectWithoutTarifa_ProtocoloInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutTarifa_ProtocoloInput | ServicioUpsertWithWhereUniqueWithoutTarifa_ProtocoloInput[]
    createMany?: ServicioCreateManyTarifa_ProtocoloInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutTarifa_ProtocoloInput | ServicioUpdateWithWhereUniqueWithoutTarifa_ProtocoloInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutTarifa_ProtocoloInput | ServicioUpdateManyWithWhereWithoutTarifa_ProtocoloInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type ServicioUncheckedUpdateManyWithoutTarifa_ProtocoloNestedInput = {
    create?: XOR<ServicioCreateWithoutTarifa_ProtocoloInput, ServicioUncheckedCreateWithoutTarifa_ProtocoloInput> | ServicioCreateWithoutTarifa_ProtocoloInput[] | ServicioUncheckedCreateWithoutTarifa_ProtocoloInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTarifa_ProtocoloInput | ServicioCreateOrConnectWithoutTarifa_ProtocoloInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutTarifa_ProtocoloInput | ServicioUpsertWithWhereUniqueWithoutTarifa_ProtocoloInput[]
    createMany?: ServicioCreateManyTarifa_ProtocoloInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutTarifa_ProtocoloInput | ServicioUpdateWithWhereUniqueWithoutTarifa_ProtocoloInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutTarifa_ProtocoloInput | ServicioUpdateManyWithWhereWithoutTarifa_ProtocoloInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type ContratoCreateNestedManyWithoutContrato_EmpresaInput = {
    create?: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput> | ContratoCreateWithoutContrato_EmpresaInput[] | ContratoUncheckedCreateWithoutContrato_EmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutContrato_EmpresaInput | ContratoCreateOrConnectWithoutContrato_EmpresaInput[]
    createMany?: ContratoCreateManyContrato_EmpresaInputEnvelope
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
  }

  export type MunicipioCreateNestedOneWithoutEmpresaInput = {
    create?: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutEmpresaInput
    connect?: MunicipioWhereUniqueInput
  }

  export type ContratoUncheckedCreateNestedManyWithoutContrato_EmpresaInput = {
    create?: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput> | ContratoCreateWithoutContrato_EmpresaInput[] | ContratoUncheckedCreateWithoutContrato_EmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutContrato_EmpresaInput | ContratoCreateOrConnectWithoutContrato_EmpresaInput[]
    createMany?: ContratoCreateManyContrato_EmpresaInputEnvelope
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
  }

  export type EnumTipo_EmpresaFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_Empresa
  }

  export type ContratoUpdateManyWithoutContrato_EmpresaNestedInput = {
    create?: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput> | ContratoCreateWithoutContrato_EmpresaInput[] | ContratoUncheckedCreateWithoutContrato_EmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutContrato_EmpresaInput | ContratoCreateOrConnectWithoutContrato_EmpresaInput[]
    upsert?: ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput | ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput[]
    createMany?: ContratoCreateManyContrato_EmpresaInputEnvelope
    set?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    disconnect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    delete?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    update?: ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput | ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput[]
    updateMany?: ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput | ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput[]
    deleteMany?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
  }

  export type MunicipioUpdateOneRequiredWithoutEmpresaNestedInput = {
    create?: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutEmpresaInput
    upsert?: MunicipioUpsertWithoutEmpresaInput
    connect?: MunicipioWhereUniqueInput
    update?: XOR<XOR<MunicipioUpdateToOneWithWhereWithoutEmpresaInput, MunicipioUpdateWithoutEmpresaInput>, MunicipioUncheckedUpdateWithoutEmpresaInput>
  }

  export type ContratoUncheckedUpdateManyWithoutContrato_EmpresaNestedInput = {
    create?: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput> | ContratoCreateWithoutContrato_EmpresaInput[] | ContratoUncheckedCreateWithoutContrato_EmpresaInput[]
    connectOrCreate?: ContratoCreateOrConnectWithoutContrato_EmpresaInput | ContratoCreateOrConnectWithoutContrato_EmpresaInput[]
    upsert?: ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput | ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput[]
    createMany?: ContratoCreateManyContrato_EmpresaInputEnvelope
    set?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    disconnect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    delete?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    connect?: ContratoWhereUniqueInput | ContratoWhereUniqueInput[]
    update?: ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput | ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput[]
    updateMany?: ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput | ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput[]
    deleteMany?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
  }

  export type AcuerdoCreateNestedManyWithoutContrato_AcuerdoInput = {
    create?: XOR<AcuerdoCreateWithoutContrato_AcuerdoInput, AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput> | AcuerdoCreateWithoutContrato_AcuerdoInput[] | AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput | AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput[]
    createMany?: AcuerdoCreateManyContrato_AcuerdoInputEnvelope
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
  }

  export type EmpresaCreateNestedOneWithoutContratoInput = {
    create?: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutContratoInput
    connect?: EmpresaWhereUniqueInput
  }

  export type AcuerdoUncheckedCreateNestedManyWithoutContrato_AcuerdoInput = {
    create?: XOR<AcuerdoCreateWithoutContrato_AcuerdoInput, AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput> | AcuerdoCreateWithoutContrato_AcuerdoInput[] | AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput | AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput[]
    createMany?: AcuerdoCreateManyContrato_AcuerdoInputEnvelope
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
  }

  export type AcuerdoUpdateManyWithoutContrato_AcuerdoNestedInput = {
    create?: XOR<AcuerdoCreateWithoutContrato_AcuerdoInput, AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput> | AcuerdoCreateWithoutContrato_AcuerdoInput[] | AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput | AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput[]
    upsert?: AcuerdoUpsertWithWhereUniqueWithoutContrato_AcuerdoInput | AcuerdoUpsertWithWhereUniqueWithoutContrato_AcuerdoInput[]
    createMany?: AcuerdoCreateManyContrato_AcuerdoInputEnvelope
    set?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    disconnect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    delete?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    update?: AcuerdoUpdateWithWhereUniqueWithoutContrato_AcuerdoInput | AcuerdoUpdateWithWhereUniqueWithoutContrato_AcuerdoInput[]
    updateMany?: AcuerdoUpdateManyWithWhereWithoutContrato_AcuerdoInput | AcuerdoUpdateManyWithWhereWithoutContrato_AcuerdoInput[]
    deleteMany?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
  }

  export type EmpresaUpdateOneRequiredWithoutContratoNestedInput = {
    create?: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutContratoInput
    upsert?: EmpresaUpsertWithoutContratoInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutContratoInput, EmpresaUpdateWithoutContratoInput>, EmpresaUncheckedUpdateWithoutContratoInput>
  }

  export type AcuerdoUncheckedUpdateManyWithoutContrato_AcuerdoNestedInput = {
    create?: XOR<AcuerdoCreateWithoutContrato_AcuerdoInput, AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput> | AcuerdoCreateWithoutContrato_AcuerdoInput[] | AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput[]
    connectOrCreate?: AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput | AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput[]
    upsert?: AcuerdoUpsertWithWhereUniqueWithoutContrato_AcuerdoInput | AcuerdoUpsertWithWhereUniqueWithoutContrato_AcuerdoInput[]
    createMany?: AcuerdoCreateManyContrato_AcuerdoInputEnvelope
    set?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    disconnect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    delete?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    connect?: AcuerdoWhereUniqueInput | AcuerdoWhereUniqueInput[]
    update?: AcuerdoUpdateWithWhereUniqueWithoutContrato_AcuerdoInput | AcuerdoUpdateWithWhereUniqueWithoutContrato_AcuerdoInput[]
    updateMany?: AcuerdoUpdateManyWithWhereWithoutContrato_AcuerdoInput | AcuerdoUpdateManyWithWhereWithoutContrato_AcuerdoInput[]
    deleteMany?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
  }

  export type ProcedimientoCreateNestedManyWithoutProcedimiento_AcuerdoInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_AcuerdoInput, ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput> | ProcedimientoCreateWithoutProcedimiento_AcuerdoInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput | ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_AcuerdoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type ContratoCreateNestedOneWithoutAcuerdoInput = {
    create?: XOR<ContratoCreateWithoutAcuerdoInput, ContratoUncheckedCreateWithoutAcuerdoInput>
    connectOrCreate?: ContratoCreateOrConnectWithoutAcuerdoInput
    connect?: ContratoWhereUniqueInput
  }

  export type TarifaCreateNestedOneWithoutAcuerdoInput = {
    create?: XOR<TarifaCreateWithoutAcuerdoInput, TarifaUncheckedCreateWithoutAcuerdoInput>
    connectOrCreate?: TarifaCreateOrConnectWithoutAcuerdoInput
    connect?: TarifaWhereUniqueInput
  }

  export type ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_AcuerdoInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_AcuerdoInput, ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput> | ProcedimientoCreateWithoutProcedimiento_AcuerdoInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput | ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_AcuerdoInputEnvelope
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
  }

  export type ProcedimientoUpdateManyWithoutProcedimiento_AcuerdoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_AcuerdoInput, ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput> | ProcedimientoCreateWithoutProcedimiento_AcuerdoInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput | ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_AcuerdoInput | ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_AcuerdoInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_AcuerdoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_AcuerdoInput | ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_AcuerdoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutProcedimiento_AcuerdoInput | ProcedimientoUpdateManyWithWhereWithoutProcedimiento_AcuerdoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type ContratoUpdateOneRequiredWithoutAcuerdoNestedInput = {
    create?: XOR<ContratoCreateWithoutAcuerdoInput, ContratoUncheckedCreateWithoutAcuerdoInput>
    connectOrCreate?: ContratoCreateOrConnectWithoutAcuerdoInput
    upsert?: ContratoUpsertWithoutAcuerdoInput
    connect?: ContratoWhereUniqueInput
    update?: XOR<XOR<ContratoUpdateToOneWithWhereWithoutAcuerdoInput, ContratoUpdateWithoutAcuerdoInput>, ContratoUncheckedUpdateWithoutAcuerdoInput>
  }

  export type TarifaUpdateOneRequiredWithoutAcuerdoNestedInput = {
    create?: XOR<TarifaCreateWithoutAcuerdoInput, TarifaUncheckedCreateWithoutAcuerdoInput>
    connectOrCreate?: TarifaCreateOrConnectWithoutAcuerdoInput
    upsert?: TarifaUpsertWithoutAcuerdoInput
    connect?: TarifaWhereUniqueInput
    update?: XOR<XOR<TarifaUpdateToOneWithWhereWithoutAcuerdoInput, TarifaUpdateWithoutAcuerdoInput>, TarifaUncheckedUpdateWithoutAcuerdoInput>
  }

  export type ProcedimientoUncheckedUpdateManyWithoutProcedimiento_AcuerdoNestedInput = {
    create?: XOR<ProcedimientoCreateWithoutProcedimiento_AcuerdoInput, ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput> | ProcedimientoCreateWithoutProcedimiento_AcuerdoInput[] | ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput[]
    connectOrCreate?: ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput | ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput[]
    upsert?: ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_AcuerdoInput | ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_AcuerdoInput[]
    createMany?: ProcedimientoCreateManyProcedimiento_AcuerdoInputEnvelope
    set?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    disconnect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    delete?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    connect?: ProcedimientoWhereUniqueInput | ProcedimientoWhereUniqueInput[]
    update?: ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_AcuerdoInput | ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_AcuerdoInput[]
    updateMany?: ProcedimientoUpdateManyWithWhereWithoutProcedimiento_AcuerdoInput | ProcedimientoUpdateManyWithWhereWithoutProcedimiento_AcuerdoInput[]
    deleteMany?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumTipo_IdentFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentFilter<$PrismaModel> | $Enums.Tipo_Ident
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSexFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexFilter<$PrismaModel> | $Enums.Sex
  }

  export type NestedEnumTipo_UsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Usuario | EnumTipo_UsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Usuario[]
    notIn?: $Enums.Tipo_Usuario[]
    not?: NestedEnumTipo_UsuarioFilter<$PrismaModel> | $Enums.Tipo_Usuario
  }

  export type NestedEnumEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoFilter<$PrismaModel> | $Enums.Estado
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Ident | EnumTipo_IdentFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Ident[]
    notIn?: $Enums.Tipo_Ident[]
    not?: NestedEnumTipo_IdentWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Ident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_IdentFilter<$PrismaModel>
    _max?: NestedEnumTipo_IdentFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexWithAggregatesFilter<$PrismaModel> | $Enums.Sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexFilter<$PrismaModel>
    _max?: NestedEnumSexFilter<$PrismaModel>
  }

  export type NestedEnumTipo_UsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Usuario | EnumTipo_UsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Usuario[]
    notIn?: $Enums.Tipo_Usuario[]
    not?: NestedEnumTipo_UsuarioWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Usuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_UsuarioFilter<$PrismaModel>
    _max?: NestedEnumTipo_UsuarioFilter<$PrismaModel>
  }

  export type NestedEnumEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Estado | EnumEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.Estado[]
    notIn?: $Enums.Estado[]
    not?: NestedEnumEstadoWithAggregatesFilter<$PrismaModel> | $Enums.Estado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFilter<$PrismaModel>
    _max?: NestedEnumEstadoFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedEnumTipo_EmpresaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaFilter<$PrismaModel> | $Enums.Tipo_Empresa
  }

  export type NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_Empresa | EnumTipo_EmpresaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_Empresa[]
    notIn?: $Enums.Tipo_Empresa[]
    not?: NestedEnumTipo_EmpresaWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_Empresa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
    _max?: NestedEnumTipo_EmpresaFilter<$PrismaModel>
  }

  export type ProcedimientoCreateWithoutProcedimiento_UsuarioInput = {
    consecutivo: number
    fecha: Date | string
    factura: number
    Procedimiento_Acuerdo: AcuerdoCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput = {
    id_procedimiento?: number
    consecutivo: number
    fecha: Date | string
    factura: number
    acuerdo: number
  }

  export type ProcedimientoCreateOrConnectWithoutProcedimiento_UsuarioInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput>
  }

  export type ProcedimientoCreateManyProcedimiento_UsuarioInputEnvelope = {
    data: ProcedimientoCreateManyProcedimiento_UsuarioInput | ProcedimientoCreateManyProcedimiento_UsuarioInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioCreateWithoutSuarioInput = {
    nombre: string
    empresa?: EmpresaCreateNestedManyWithoutMuncipio_EmpresaInput
    Departamentos_Municipio: DepartamentoCreateNestedOneWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateWithoutSuarioInput = {
    id_municipio?: number
    nombre: string
    departamento: number
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMuncipio_EmpresaInput
  }

  export type MunicipioCreateOrConnectWithoutSuarioInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutSuarioInput, MunicipioUncheckedCreateWithoutSuarioInput>
  }

  export type EpsCreateWithoutUsuarioInput = {
    codigo: string
    nombre: string
    estado: $Enums.Estado
  }

  export type EpsUncheckedCreateWithoutUsuarioInput = {
    id_eps?: number
    codigo: string
    nombre: string
    estado: $Enums.Estado
  }

  export type EpsCreateOrConnectWithoutUsuarioInput = {
    where: EpsWhereUniqueInput
    create: XOR<EpsCreateWithoutUsuarioInput, EpsUncheckedCreateWithoutUsuarioInput>
  }

  export type ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_UsuarioInput = {
    where: ProcedimientoWhereUniqueInput
    update: XOR<ProcedimientoUpdateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedUpdateWithoutProcedimiento_UsuarioInput>
    create: XOR<ProcedimientoCreateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedCreateWithoutProcedimiento_UsuarioInput>
  }

  export type ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_UsuarioInput = {
    where: ProcedimientoWhereUniqueInput
    data: XOR<ProcedimientoUpdateWithoutProcedimiento_UsuarioInput, ProcedimientoUncheckedUpdateWithoutProcedimiento_UsuarioInput>
  }

  export type ProcedimientoUpdateManyWithWhereWithoutProcedimiento_UsuarioInput = {
    where: ProcedimientoScalarWhereInput
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioInput>
  }

  export type ProcedimientoScalarWhereInput = {
    AND?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
    OR?: ProcedimientoScalarWhereInput[]
    NOT?: ProcedimientoScalarWhereInput | ProcedimientoScalarWhereInput[]
    id_procedimiento?: IntFilter<"Procedimiento"> | number
    consecutivo?: IntFilter<"Procedimiento"> | number
    fecha?: DateTimeFilter<"Procedimiento"> | Date | string
    factura?: IntFilter<"Procedimiento"> | number
    usuario?: IntFilter<"Procedimiento"> | number
    acuerdo?: IntFilter<"Procedimiento"> | number
  }

  export type MunicipioUpsertWithoutSuarioInput = {
    update: XOR<MunicipioUpdateWithoutSuarioInput, MunicipioUncheckedUpdateWithoutSuarioInput>
    create: XOR<MunicipioCreateWithoutSuarioInput, MunicipioUncheckedCreateWithoutSuarioInput>
    where?: MunicipioWhereInput
  }

  export type MunicipioUpdateToOneWithWhereWithoutSuarioInput = {
    where?: MunicipioWhereInput
    data: XOR<MunicipioUpdateWithoutSuarioInput, MunicipioUncheckedUpdateWithoutSuarioInput>
  }

  export type MunicipioUpdateWithoutSuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    empresa?: EmpresaUpdateManyWithoutMuncipio_EmpresaNestedInput
    Departamentos_Municipio?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutSuarioInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: IntFieldUpdateOperationsInput | number
    empresa?: EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaNestedInput
  }

  export type EpsUpsertWithoutUsuarioInput = {
    update: XOR<EpsUpdateWithoutUsuarioInput, EpsUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EpsCreateWithoutUsuarioInput, EpsUncheckedCreateWithoutUsuarioInput>
    where?: EpsWhereInput
  }

  export type EpsUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: EpsWhereInput
    data: XOR<EpsUpdateWithoutUsuarioInput, EpsUncheckedUpdateWithoutUsuarioInput>
  }

  export type EpsUpdateWithoutUsuarioInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type EpsUncheckedUpdateWithoutUsuarioInput = {
    id_eps?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type UsuarioCreateWithoutEps_usuarioInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_UsuarioInput
    Municipio_Usuario: MunicipioCreateNestedOneWithoutSuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEps_usuarioInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_UsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEps_usuarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput>
  }

  export type UsuarioCreateManyEps_usuarioInputEnvelope = {
    data: UsuarioCreateManyEps_usuarioInput | UsuarioCreateManyEps_usuarioInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutEps_usuarioInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutEps_usuarioInput, UsuarioUncheckedUpdateWithoutEps_usuarioInput>
    create: XOR<UsuarioCreateWithoutEps_usuarioInput, UsuarioUncheckedCreateWithoutEps_usuarioInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutEps_usuarioInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutEps_usuarioInput, UsuarioUncheckedUpdateWithoutEps_usuarioInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutEps_usuarioInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutEps_usuarioInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id_usuario?: IntFilter<"Usuario"> | number
    tipo_identificacion?: EnumTipo_IdentFilter<"Usuario"> | $Enums.Tipo_Ident
    identificacion?: StringFilter<"Usuario"> | string
    primer_nombre?: StringFilter<"Usuario"> | string
    segundo_nombre?: StringNullableFilter<"Usuario"> | string | null
    primer_apellido?: StringFilter<"Usuario"> | string
    segundo_apellido?: StringNullableFilter<"Usuario"> | string | null
    fecha_nacimiento?: DateTimeFilter<"Usuario"> | Date | string
    sexo?: EnumSexFilter<"Usuario"> | $Enums.Sex
    email?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    tipo_usuario?: EnumTipo_UsuarioFilter<"Usuario"> | $Enums.Tipo_Usuario
    municipio?: IntFilter<"Usuario"> | number
    estado?: EnumEstadoFilter<"Usuario"> | $Enums.Estado
    createAt?: DateTimeFilter<"Usuario"> | Date | string
    updateAt?: DateTimeFilter<"Usuario"> | Date | string
    eps?: IntFilter<"Usuario"> | number
  }

  export type AcuerdoCreateWithoutProcedimientoInput = {
    estado: $Enums.Estado
    valor: Decimal | DecimalJsLike | number | string
    Contrato_Acuerdo: ContratoCreateNestedOneWithoutAcuerdoInput
    Tarifa_Acuerdo: TarifaCreateNestedOneWithoutAcuerdoInput
  }

  export type AcuerdoUncheckedCreateWithoutProcedimientoInput = {
    id_acuerdo?: number
    estado: $Enums.Estado
    contrato: number
    valor: Decimal | DecimalJsLike | number | string
    tarifa: number
  }

  export type AcuerdoCreateOrConnectWithoutProcedimientoInput = {
    where: AcuerdoWhereUniqueInput
    create: XOR<AcuerdoCreateWithoutProcedimientoInput, AcuerdoUncheckedCreateWithoutProcedimientoInput>
  }

  export type UsuarioCreateWithoutProcedimientoInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    Municipio_Usuario: MunicipioCreateNestedOneWithoutSuarioInput
    Eps_usuario: EpsCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutProcedimientoInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
  }

  export type UsuarioCreateOrConnectWithoutProcedimientoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutProcedimientoInput, UsuarioUncheckedCreateWithoutProcedimientoInput>
  }

  export type AcuerdoUpsertWithoutProcedimientoInput = {
    update: XOR<AcuerdoUpdateWithoutProcedimientoInput, AcuerdoUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<AcuerdoCreateWithoutProcedimientoInput, AcuerdoUncheckedCreateWithoutProcedimientoInput>
    where?: AcuerdoWhereInput
  }

  export type AcuerdoUpdateToOneWithWhereWithoutProcedimientoInput = {
    where?: AcuerdoWhereInput
    data: XOR<AcuerdoUpdateWithoutProcedimientoInput, AcuerdoUncheckedUpdateWithoutProcedimientoInput>
  }

  export type AcuerdoUpdateWithoutProcedimientoInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Contrato_Acuerdo?: ContratoUpdateOneRequiredWithoutAcuerdoNestedInput
    Tarifa_Acuerdo?: TarifaUpdateOneRequiredWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateWithoutProcedimientoInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tarifa?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpsertWithoutProcedimientoInput = {
    update: XOR<UsuarioUpdateWithoutProcedimientoInput, UsuarioUncheckedUpdateWithoutProcedimientoInput>
    create: XOR<UsuarioCreateWithoutProcedimientoInput, UsuarioUncheckedCreateWithoutProcedimientoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutProcedimientoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutProcedimientoInput, UsuarioUncheckedUpdateWithoutProcedimientoInput>
  }

  export type UsuarioUpdateWithoutProcedimientoInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Municipio_Usuario?: MunicipioUpdateOneRequiredWithoutSuarioNestedInput
    Eps_usuario?: EpsUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutProcedimientoInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
  }

  export type MunicipioCreateWithoutDepartamentos_MunicipioInput = {
    nombre: string
    suario?: UsuarioCreateNestedManyWithoutMunicipio_UsuarioInput
    empresa?: EmpresaCreateNestedManyWithoutMuncipio_EmpresaInput
  }

  export type MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput = {
    id_municipio?: number
    nombre: string
    suario?: UsuarioUncheckedCreateNestedManyWithoutMunicipio_UsuarioInput
    empresa?: EmpresaUncheckedCreateNestedManyWithoutMuncipio_EmpresaInput
  }

  export type MunicipioCreateOrConnectWithoutDepartamentos_MunicipioInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput>
  }

  export type MunicipioCreateManyDepartamentos_MunicipioInputEnvelope = {
    data: MunicipioCreateManyDepartamentos_MunicipioInput | MunicipioCreateManyDepartamentos_MunicipioInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioUpsertWithWhereUniqueWithoutDepartamentos_MunicipioInput = {
    where: MunicipioWhereUniqueInput
    update: XOR<MunicipioUpdateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedUpdateWithoutDepartamentos_MunicipioInput>
    create: XOR<MunicipioCreateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedCreateWithoutDepartamentos_MunicipioInput>
  }

  export type MunicipioUpdateWithWhereUniqueWithoutDepartamentos_MunicipioInput = {
    where: MunicipioWhereUniqueInput
    data: XOR<MunicipioUpdateWithoutDepartamentos_MunicipioInput, MunicipioUncheckedUpdateWithoutDepartamentos_MunicipioInput>
  }

  export type MunicipioUpdateManyWithWhereWithoutDepartamentos_MunicipioInput = {
    where: MunicipioScalarWhereInput
    data: XOR<MunicipioUpdateManyMutationInput, MunicipioUncheckedUpdateManyWithoutDepartamentos_MunicipioInput>
  }

  export type MunicipioScalarWhereInput = {
    AND?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
    OR?: MunicipioScalarWhereInput[]
    NOT?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
    id_municipio?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
    departamento?: IntFilter<"Municipio"> | number
  }

  export type UsuarioCreateWithoutMunicipio_UsuarioInput = {
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_UsuarioInput
    Eps_usuario: EpsCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_UsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutMunicipio_UsuarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput>
  }

  export type UsuarioCreateManyMunicipio_UsuarioInputEnvelope = {
    data: UsuarioCreateManyMunicipio_UsuarioInput | UsuarioCreateManyMunicipio_UsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaCreateWithoutMuncipio_EmpresaInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    contrato?: ContratoCreateNestedManyWithoutContrato_EmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    contrato?: ContratoUncheckedCreateNestedManyWithoutContrato_EmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutMuncipio_EmpresaInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput>
  }

  export type EmpresaCreateManyMuncipio_EmpresaInputEnvelope = {
    data: EmpresaCreateManyMuncipio_EmpresaInput | EmpresaCreateManyMuncipio_EmpresaInput[]
    skipDuplicates?: boolean
  }

  export type DepartamentoCreateWithoutMunicipioInput = {
    nombre: string
  }

  export type DepartamentoUncheckedCreateWithoutMunicipioInput = {
    id_departamento?: number
    nombre: string
  }

  export type DepartamentoCreateOrConnectWithoutMunicipioInput = {
    where: DepartamentoWhereUniqueInput
    create: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
  }

  export type UsuarioUpsertWithWhereUniqueWithoutMunicipio_UsuarioInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutMunicipio_UsuarioInput, UsuarioUncheckedUpdateWithoutMunicipio_UsuarioInput>
    create: XOR<UsuarioCreateWithoutMunicipio_UsuarioInput, UsuarioUncheckedCreateWithoutMunicipio_UsuarioInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutMunicipio_UsuarioInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutMunicipio_UsuarioInput, UsuarioUncheckedUpdateWithoutMunicipio_UsuarioInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutMunicipio_UsuarioInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioInput>
  }

  export type EmpresaUpsertWithWhereUniqueWithoutMuncipio_EmpresaInput = {
    where: EmpresaWhereUniqueInput
    update: XOR<EmpresaUpdateWithoutMuncipio_EmpresaInput, EmpresaUncheckedUpdateWithoutMuncipio_EmpresaInput>
    create: XOR<EmpresaCreateWithoutMuncipio_EmpresaInput, EmpresaUncheckedCreateWithoutMuncipio_EmpresaInput>
  }

  export type EmpresaUpdateWithWhereUniqueWithoutMuncipio_EmpresaInput = {
    where: EmpresaWhereUniqueInput
    data: XOR<EmpresaUpdateWithoutMuncipio_EmpresaInput, EmpresaUncheckedUpdateWithoutMuncipio_EmpresaInput>
  }

  export type EmpresaUpdateManyWithWhereWithoutMuncipio_EmpresaInput = {
    where: EmpresaScalarWhereInput
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaInput>
  }

  export type EmpresaScalarWhereInput = {
    AND?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
    OR?: EmpresaScalarWhereInput[]
    NOT?: EmpresaScalarWhereInput | EmpresaScalarWhereInput[]
    id_empresa?: IntFilter<"Empresa"> | number
    nit?: StringFilter<"Empresa"> | string
    codigo?: IntFilter<"Empresa"> | number
    nombre?: StringFilter<"Empresa"> | string
    sigla?: StringFilter<"Empresa"> | string
    tipo?: EnumTipo_EmpresaFilter<"Empresa"> | $Enums.Tipo_Empresa
    estado?: EnumEstadoFilter<"Empresa"> | $Enums.Estado
    municipio?: IntFilter<"Empresa"> | number
  }

  export type DepartamentoUpsertWithoutMunicipioInput = {
    update: XOR<DepartamentoUpdateWithoutMunicipioInput, DepartamentoUncheckedUpdateWithoutMunicipioInput>
    create: XOR<DepartamentoCreateWithoutMunicipioInput, DepartamentoUncheckedCreateWithoutMunicipioInput>
    where?: DepartamentoWhereInput
  }

  export type DepartamentoUpdateToOneWithWhereWithoutMunicipioInput = {
    where?: DepartamentoWhereInput
    data: XOR<DepartamentoUpdateWithoutMunicipioInput, DepartamentoUncheckedUpdateWithoutMunicipioInput>
  }

  export type DepartamentoUpdateWithoutMunicipioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentoUncheckedUpdateWithoutMunicipioInput = {
    id_departamento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TarifaCreateWithoutServicioInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    acuerdo?: AcuerdoCreateNestedManyWithoutTarifa_AcuerdoInput
  }

  export type TarifaUncheckedCreateWithoutServicioInput = {
    id_tarifa?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutTarifa_AcuerdoInput
  }

  export type TarifaCreateOrConnectWithoutServicioInput = {
    where: TarifaWhereUniqueInput
    create: XOR<TarifaCreateWithoutServicioInput, TarifaUncheckedCreateWithoutServicioInput>
  }

  export type ProtocoloCreateWithoutServicioInput = {
    nombre: string
    estado: $Enums.Estado
  }

  export type ProtocoloUncheckedCreateWithoutServicioInput = {
    id_protocolo?: number
    nombre: string
    estado: $Enums.Estado
  }

  export type ProtocoloCreateOrConnectWithoutServicioInput = {
    where: ProtocoloWhereUniqueInput
    create: XOR<ProtocoloCreateWithoutServicioInput, ProtocoloUncheckedCreateWithoutServicioInput>
  }

  export type PrestadorCreateWithoutServicioInput = {
    codigo: bigint | number
    razon_social: string
    consecutivo: number
    empleado?: EmpleadoCreateNestedManyWithoutPretador_EmpleadoInput
  }

  export type PrestadorUncheckedCreateWithoutServicioInput = {
    id_prestador?: number
    codigo: bigint | number
    razon_social: string
    consecutivo: number
    empleado?: EmpleadoUncheckedCreateNestedManyWithoutPretador_EmpleadoInput
  }

  export type PrestadorCreateOrConnectWithoutServicioInput = {
    where: PrestadorWhereUniqueInput
    create: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
  }

  export type TarifaUpsertWithoutServicioInput = {
    update: XOR<TarifaUpdateWithoutServicioInput, TarifaUncheckedUpdateWithoutServicioInput>
    create: XOR<TarifaCreateWithoutServicioInput, TarifaUncheckedCreateWithoutServicioInput>
    where?: TarifaWhereInput
  }

  export type TarifaUpdateToOneWithWhereWithoutServicioInput = {
    where?: TarifaWhereInput
    data: XOR<TarifaUpdateWithoutServicioInput, TarifaUncheckedUpdateWithoutServicioInput>
  }

  export type TarifaUpdateWithoutServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    acuerdo?: AcuerdoUpdateManyWithoutTarifa_AcuerdoNestedInput
  }

  export type TarifaUncheckedUpdateWithoutServicioInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutTarifa_AcuerdoNestedInput
  }

  export type ProtocoloUpsertWithoutServicioInput = {
    update: XOR<ProtocoloUpdateWithoutServicioInput, ProtocoloUncheckedUpdateWithoutServicioInput>
    create: XOR<ProtocoloCreateWithoutServicioInput, ProtocoloUncheckedCreateWithoutServicioInput>
    where?: ProtocoloWhereInput
  }

  export type ProtocoloUpdateToOneWithWhereWithoutServicioInput = {
    where?: ProtocoloWhereInput
    data: XOR<ProtocoloUpdateWithoutServicioInput, ProtocoloUncheckedUpdateWithoutServicioInput>
  }

  export type ProtocoloUpdateWithoutServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ProtocoloUncheckedUpdateWithoutServicioInput = {
    id_protocolo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type PrestadorUpsertWithoutServicioInput = {
    update: XOR<PrestadorUpdateWithoutServicioInput, PrestadorUncheckedUpdateWithoutServicioInput>
    create: XOR<PrestadorCreateWithoutServicioInput, PrestadorUncheckedCreateWithoutServicioInput>
    where?: PrestadorWhereInput
  }

  export type PrestadorUpdateToOneWithWhereWithoutServicioInput = {
    where?: PrestadorWhereInput
    data: XOR<PrestadorUpdateWithoutServicioInput, PrestadorUncheckedUpdateWithoutServicioInput>
  }

  export type PrestadorUpdateWithoutServicioInput = {
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    razon_social?: StringFieldUpdateOperationsInput | string
    consecutivo?: IntFieldUpdateOperationsInput | number
    empleado?: EmpleadoUpdateManyWithoutPretador_EmpleadoNestedInput
  }

  export type PrestadorUncheckedUpdateWithoutServicioInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    razon_social?: StringFieldUpdateOperationsInput | string
    consecutivo?: IntFieldUpdateOperationsInput | number
    empleado?: EmpleadoUncheckedUpdateManyWithoutPretador_EmpleadoNestedInput
  }

  export type ServicioCreateWithoutPrestador_ServicioInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    Tarifa_Servicio: TarifaCreateNestedOneWithoutServicioInput
    Tarifa_Protocolo: ProtocoloCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutPrestador_ServicioInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa: number
    protocolo: number
  }

  export type ServicioCreateOrConnectWithoutPrestador_ServicioInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput>
  }

  export type ServicioCreateManyPrestador_ServicioInputEnvelope = {
    data: ServicioCreateManyPrestador_ServicioInput | ServicioCreateManyPrestador_ServicioInput[]
    skipDuplicates?: boolean
  }

  export type EmpleadoCreateWithoutPretador_EmpleadoInput = {
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    password: string
  }

  export type EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput = {
    id_empleado?: number
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    password: string
  }

  export type EmpleadoCreateOrConnectWithoutPretador_EmpleadoInput = {
    where: EmpleadoWhereUniqueInput
    create: XOR<EmpleadoCreateWithoutPretador_EmpleadoInput, EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput>
  }

  export type EmpleadoCreateManyPretador_EmpleadoInputEnvelope = {
    data: EmpleadoCreateManyPretador_EmpleadoInput | EmpleadoCreateManyPretador_EmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type ServicioUpsertWithWhereUniqueWithoutPrestador_ServicioInput = {
    where: ServicioWhereUniqueInput
    update: XOR<ServicioUpdateWithoutPrestador_ServicioInput, ServicioUncheckedUpdateWithoutPrestador_ServicioInput>
    create: XOR<ServicioCreateWithoutPrestador_ServicioInput, ServicioUncheckedCreateWithoutPrestador_ServicioInput>
  }

  export type ServicioUpdateWithWhereUniqueWithoutPrestador_ServicioInput = {
    where: ServicioWhereUniqueInput
    data: XOR<ServicioUpdateWithoutPrestador_ServicioInput, ServicioUncheckedUpdateWithoutPrestador_ServicioInput>
  }

  export type ServicioUpdateManyWithWhereWithoutPrestador_ServicioInput = {
    where: ServicioScalarWhereInput
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyWithoutPrestador_ServicioInput>
  }

  export type ServicioScalarWhereInput = {
    AND?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
    OR?: ServicioScalarWhereInput[]
    NOT?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
    id_servicio?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    precio?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    iva?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    nivel?: IntFilter<"Servicio"> | number
    tarifa?: IntFilter<"Servicio"> | number
    protocolo?: IntFilter<"Servicio"> | number
    prestador?: IntFilter<"Servicio"> | number
  }

  export type EmpleadoUpsertWithWhereUniqueWithoutPretador_EmpleadoInput = {
    where: EmpleadoWhereUniqueInput
    update: XOR<EmpleadoUpdateWithoutPretador_EmpleadoInput, EmpleadoUncheckedUpdateWithoutPretador_EmpleadoInput>
    create: XOR<EmpleadoCreateWithoutPretador_EmpleadoInput, EmpleadoUncheckedCreateWithoutPretador_EmpleadoInput>
  }

  export type EmpleadoUpdateWithWhereUniqueWithoutPretador_EmpleadoInput = {
    where: EmpleadoWhereUniqueInput
    data: XOR<EmpleadoUpdateWithoutPretador_EmpleadoInput, EmpleadoUncheckedUpdateWithoutPretador_EmpleadoInput>
  }

  export type EmpleadoUpdateManyWithWhereWithoutPretador_EmpleadoInput = {
    where: EmpleadoScalarWhereInput
    data: XOR<EmpleadoUpdateManyMutationInput, EmpleadoUncheckedUpdateManyWithoutPretador_EmpleadoInput>
  }

  export type EmpleadoScalarWhereInput = {
    AND?: EmpleadoScalarWhereInput | EmpleadoScalarWhereInput[]
    OR?: EmpleadoScalarWhereInput[]
    NOT?: EmpleadoScalarWhereInput | EmpleadoScalarWhereInput[]
    id_empleado?: IntFilter<"Empleado"> | number
    identificacion?: BigIntFilter<"Empleado"> | bigint | number
    nombre?: StringFilter<"Empleado"> | string
    cargo?: StringFilter<"Empleado"> | string
    rol?: EnumRolFilter<"Empleado"> | $Enums.Rol
    password?: StringFilter<"Empleado"> | string
    prestador?: IntFilter<"Empleado"> | number
  }

  export type PrestadorCreateWithoutEmpleadoInput = {
    codigo: bigint | number
    razon_social: string
    consecutivo: number
    servicio?: ServicioCreateNestedManyWithoutPrestador_ServicioInput
  }

  export type PrestadorUncheckedCreateWithoutEmpleadoInput = {
    id_prestador?: number
    codigo: bigint | number
    razon_social: string
    consecutivo: number
    servicio?: ServicioUncheckedCreateNestedManyWithoutPrestador_ServicioInput
  }

  export type PrestadorCreateOrConnectWithoutEmpleadoInput = {
    where: PrestadorWhereUniqueInput
    create: XOR<PrestadorCreateWithoutEmpleadoInput, PrestadorUncheckedCreateWithoutEmpleadoInput>
  }

  export type PrestadorUpsertWithoutEmpleadoInput = {
    update: XOR<PrestadorUpdateWithoutEmpleadoInput, PrestadorUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<PrestadorCreateWithoutEmpleadoInput, PrestadorUncheckedCreateWithoutEmpleadoInput>
    where?: PrestadorWhereInput
  }

  export type PrestadorUpdateToOneWithWhereWithoutEmpleadoInput = {
    where?: PrestadorWhereInput
    data: XOR<PrestadorUpdateWithoutEmpleadoInput, PrestadorUncheckedUpdateWithoutEmpleadoInput>
  }

  export type PrestadorUpdateWithoutEmpleadoInput = {
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    razon_social?: StringFieldUpdateOperationsInput | string
    consecutivo?: IntFieldUpdateOperationsInput | number
    servicio?: ServicioUpdateManyWithoutPrestador_ServicioNestedInput
  }

  export type PrestadorUncheckedUpdateWithoutEmpleadoInput = {
    id_prestador?: IntFieldUpdateOperationsInput | number
    codigo?: BigIntFieldUpdateOperationsInput | bigint | number
    razon_social?: StringFieldUpdateOperationsInput | string
    consecutivo?: IntFieldUpdateOperationsInput | number
    servicio?: ServicioUncheckedUpdateManyWithoutPrestador_ServicioNestedInput
  }

  export type ServicioCreateWithoutTarifa_ServicioInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    Tarifa_Protocolo: ProtocoloCreateNestedOneWithoutServicioInput
    Prestador_Servicio: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutTarifa_ServicioInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    protocolo: number
    prestador: number
  }

  export type ServicioCreateOrConnectWithoutTarifa_ServicioInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutTarifa_ServicioInput, ServicioUncheckedCreateWithoutTarifa_ServicioInput>
  }

  export type ServicioCreateManyTarifa_ServicioInputEnvelope = {
    data: ServicioCreateManyTarifa_ServicioInput | ServicioCreateManyTarifa_ServicioInput[]
    skipDuplicates?: boolean
  }

  export type AcuerdoCreateWithoutTarifa_AcuerdoInput = {
    estado: $Enums.Estado
    valor: Decimal | DecimalJsLike | number | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_AcuerdoInput
    Contrato_Acuerdo: ContratoCreateNestedOneWithoutAcuerdoInput
  }

  export type AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput = {
    id_acuerdo?: number
    estado: $Enums.Estado
    contrato: number
    valor: Decimal | DecimalJsLike | number | string
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_AcuerdoInput
  }

  export type AcuerdoCreateOrConnectWithoutTarifa_AcuerdoInput = {
    where: AcuerdoWhereUniqueInput
    create: XOR<AcuerdoCreateWithoutTarifa_AcuerdoInput, AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput>
  }

  export type AcuerdoCreateManyTarifa_AcuerdoInputEnvelope = {
    data: AcuerdoCreateManyTarifa_AcuerdoInput | AcuerdoCreateManyTarifa_AcuerdoInput[]
    skipDuplicates?: boolean
  }

  export type ServicioUpsertWithWhereUniqueWithoutTarifa_ServicioInput = {
    where: ServicioWhereUniqueInput
    update: XOR<ServicioUpdateWithoutTarifa_ServicioInput, ServicioUncheckedUpdateWithoutTarifa_ServicioInput>
    create: XOR<ServicioCreateWithoutTarifa_ServicioInput, ServicioUncheckedCreateWithoutTarifa_ServicioInput>
  }

  export type ServicioUpdateWithWhereUniqueWithoutTarifa_ServicioInput = {
    where: ServicioWhereUniqueInput
    data: XOR<ServicioUpdateWithoutTarifa_ServicioInput, ServicioUncheckedUpdateWithoutTarifa_ServicioInput>
  }

  export type ServicioUpdateManyWithWhereWithoutTarifa_ServicioInput = {
    where: ServicioScalarWhereInput
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyWithoutTarifa_ServicioInput>
  }

  export type AcuerdoUpsertWithWhereUniqueWithoutTarifa_AcuerdoInput = {
    where: AcuerdoWhereUniqueInput
    update: XOR<AcuerdoUpdateWithoutTarifa_AcuerdoInput, AcuerdoUncheckedUpdateWithoutTarifa_AcuerdoInput>
    create: XOR<AcuerdoCreateWithoutTarifa_AcuerdoInput, AcuerdoUncheckedCreateWithoutTarifa_AcuerdoInput>
  }

  export type AcuerdoUpdateWithWhereUniqueWithoutTarifa_AcuerdoInput = {
    where: AcuerdoWhereUniqueInput
    data: XOR<AcuerdoUpdateWithoutTarifa_AcuerdoInput, AcuerdoUncheckedUpdateWithoutTarifa_AcuerdoInput>
  }

  export type AcuerdoUpdateManyWithWhereWithoutTarifa_AcuerdoInput = {
    where: AcuerdoScalarWhereInput
    data: XOR<AcuerdoUpdateManyMutationInput, AcuerdoUncheckedUpdateManyWithoutTarifa_AcuerdoInput>
  }

  export type AcuerdoScalarWhereInput = {
    AND?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
    OR?: AcuerdoScalarWhereInput[]
    NOT?: AcuerdoScalarWhereInput | AcuerdoScalarWhereInput[]
    id_acuerdo?: IntFilter<"Acuerdo"> | number
    estado?: EnumEstadoFilter<"Acuerdo"> | $Enums.Estado
    contrato?: IntFilter<"Acuerdo"> | number
    valor?: DecimalFilter<"Acuerdo"> | Decimal | DecimalJsLike | number | string
    tarifa?: IntFilter<"Acuerdo"> | number
  }

  export type ServicioCreateWithoutTarifa_ProtocoloInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    Tarifa_Servicio: TarifaCreateNestedOneWithoutServicioInput
    Prestador_Servicio: PrestadorCreateNestedOneWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutTarifa_ProtocoloInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa: number
    prestador: number
  }

  export type ServicioCreateOrConnectWithoutTarifa_ProtocoloInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutTarifa_ProtocoloInput, ServicioUncheckedCreateWithoutTarifa_ProtocoloInput>
  }

  export type ServicioCreateManyTarifa_ProtocoloInputEnvelope = {
    data: ServicioCreateManyTarifa_ProtocoloInput | ServicioCreateManyTarifa_ProtocoloInput[]
    skipDuplicates?: boolean
  }

  export type ServicioUpsertWithWhereUniqueWithoutTarifa_ProtocoloInput = {
    where: ServicioWhereUniqueInput
    update: XOR<ServicioUpdateWithoutTarifa_ProtocoloInput, ServicioUncheckedUpdateWithoutTarifa_ProtocoloInput>
    create: XOR<ServicioCreateWithoutTarifa_ProtocoloInput, ServicioUncheckedCreateWithoutTarifa_ProtocoloInput>
  }

  export type ServicioUpdateWithWhereUniqueWithoutTarifa_ProtocoloInput = {
    where: ServicioWhereUniqueInput
    data: XOR<ServicioUpdateWithoutTarifa_ProtocoloInput, ServicioUncheckedUpdateWithoutTarifa_ProtocoloInput>
  }

  export type ServicioUpdateManyWithWhereWithoutTarifa_ProtocoloInput = {
    where: ServicioScalarWhereInput
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyWithoutTarifa_ProtocoloInput>
  }

  export type ContratoCreateWithoutContrato_EmpresaInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    acuerdo?: AcuerdoCreateNestedManyWithoutContrato_AcuerdoInput
  }

  export type ContratoUncheckedCreateWithoutContrato_EmpresaInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    acuerdo?: AcuerdoUncheckedCreateNestedManyWithoutContrato_AcuerdoInput
  }

  export type ContratoCreateOrConnectWithoutContrato_EmpresaInput = {
    where: ContratoWhereUniqueInput
    create: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput>
  }

  export type ContratoCreateManyContrato_EmpresaInputEnvelope = {
    data: ContratoCreateManyContrato_EmpresaInput | ContratoCreateManyContrato_EmpresaInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioCreateWithoutEmpresaInput = {
    nombre: string
    suario?: UsuarioCreateNestedManyWithoutMunicipio_UsuarioInput
    Departamentos_Municipio: DepartamentoCreateNestedOneWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateWithoutEmpresaInput = {
    id_municipio?: number
    nombre: string
    departamento: number
    suario?: UsuarioUncheckedCreateNestedManyWithoutMunicipio_UsuarioInput
  }

  export type MunicipioCreateOrConnectWithoutEmpresaInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
  }

  export type ContratoUpsertWithWhereUniqueWithoutContrato_EmpresaInput = {
    where: ContratoWhereUniqueInput
    update: XOR<ContratoUpdateWithoutContrato_EmpresaInput, ContratoUncheckedUpdateWithoutContrato_EmpresaInput>
    create: XOR<ContratoCreateWithoutContrato_EmpresaInput, ContratoUncheckedCreateWithoutContrato_EmpresaInput>
  }

  export type ContratoUpdateWithWhereUniqueWithoutContrato_EmpresaInput = {
    where: ContratoWhereUniqueInput
    data: XOR<ContratoUpdateWithoutContrato_EmpresaInput, ContratoUncheckedUpdateWithoutContrato_EmpresaInput>
  }

  export type ContratoUpdateManyWithWhereWithoutContrato_EmpresaInput = {
    where: ContratoScalarWhereInput
    data: XOR<ContratoUpdateManyMutationInput, ContratoUncheckedUpdateManyWithoutContrato_EmpresaInput>
  }

  export type ContratoScalarWhereInput = {
    AND?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
    OR?: ContratoScalarWhereInput[]
    NOT?: ContratoScalarWhereInput | ContratoScalarWhereInput[]
    id_contrato?: IntFilter<"Contrato"> | number
    fecha_inicio?: DateTimeFilter<"Contrato"> | Date | string
    fecha_fin?: DateTimeFilter<"Contrato"> | Date | string
    estado?: EnumEstadoFilter<"Contrato"> | $Enums.Estado
    empresa?: IntFilter<"Contrato"> | number
  }

  export type MunicipioUpsertWithoutEmpresaInput = {
    update: XOR<MunicipioUpdateWithoutEmpresaInput, MunicipioUncheckedUpdateWithoutEmpresaInput>
    create: XOR<MunicipioCreateWithoutEmpresaInput, MunicipioUncheckedCreateWithoutEmpresaInput>
    where?: MunicipioWhereInput
  }

  export type MunicipioUpdateToOneWithWhereWithoutEmpresaInput = {
    where?: MunicipioWhereInput
    data: XOR<MunicipioUpdateWithoutEmpresaInput, MunicipioUncheckedUpdateWithoutEmpresaInput>
  }

  export type MunicipioUpdateWithoutEmpresaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    suario?: UsuarioUpdateManyWithoutMunicipio_UsuarioNestedInput
    Departamentos_Municipio?: DepartamentoUpdateOneRequiredWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutEmpresaInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    departamento?: IntFieldUpdateOperationsInput | number
    suario?: UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioNestedInput
  }

  export type AcuerdoCreateWithoutContrato_AcuerdoInput = {
    estado: $Enums.Estado
    valor: Decimal | DecimalJsLike | number | string
    procedimiento?: ProcedimientoCreateNestedManyWithoutProcedimiento_AcuerdoInput
    Tarifa_Acuerdo: TarifaCreateNestedOneWithoutAcuerdoInput
  }

  export type AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput = {
    id_acuerdo?: number
    estado: $Enums.Estado
    valor: Decimal | DecimalJsLike | number | string
    tarifa: number
    procedimiento?: ProcedimientoUncheckedCreateNestedManyWithoutProcedimiento_AcuerdoInput
  }

  export type AcuerdoCreateOrConnectWithoutContrato_AcuerdoInput = {
    where: AcuerdoWhereUniqueInput
    create: XOR<AcuerdoCreateWithoutContrato_AcuerdoInput, AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput>
  }

  export type AcuerdoCreateManyContrato_AcuerdoInputEnvelope = {
    data: AcuerdoCreateManyContrato_AcuerdoInput | AcuerdoCreateManyContrato_AcuerdoInput[]
    skipDuplicates?: boolean
  }

  export type EmpresaCreateWithoutContratoInput = {
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    Muncipio_Empresa: MunicipioCreateNestedOneWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutContratoInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
    municipio: number
  }

  export type EmpresaCreateOrConnectWithoutContratoInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
  }

  export type AcuerdoUpsertWithWhereUniqueWithoutContrato_AcuerdoInput = {
    where: AcuerdoWhereUniqueInput
    update: XOR<AcuerdoUpdateWithoutContrato_AcuerdoInput, AcuerdoUncheckedUpdateWithoutContrato_AcuerdoInput>
    create: XOR<AcuerdoCreateWithoutContrato_AcuerdoInput, AcuerdoUncheckedCreateWithoutContrato_AcuerdoInput>
  }

  export type AcuerdoUpdateWithWhereUniqueWithoutContrato_AcuerdoInput = {
    where: AcuerdoWhereUniqueInput
    data: XOR<AcuerdoUpdateWithoutContrato_AcuerdoInput, AcuerdoUncheckedUpdateWithoutContrato_AcuerdoInput>
  }

  export type AcuerdoUpdateManyWithWhereWithoutContrato_AcuerdoInput = {
    where: AcuerdoScalarWhereInput
    data: XOR<AcuerdoUpdateManyMutationInput, AcuerdoUncheckedUpdateManyWithoutContrato_AcuerdoInput>
  }

  export type EmpresaUpsertWithoutContratoInput = {
    update: XOR<EmpresaUpdateWithoutContratoInput, EmpresaUncheckedUpdateWithoutContratoInput>
    create: XOR<EmpresaCreateWithoutContratoInput, EmpresaUncheckedCreateWithoutContratoInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutContratoInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutContratoInput, EmpresaUncheckedUpdateWithoutContratoInput>
  }

  export type EmpresaUpdateWithoutContratoInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    Muncipio_Empresa?: MunicipioUpdateOneRequiredWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutContratoInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    municipio?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoCreateWithoutProcedimiento_AcuerdoInput = {
    consecutivo: number
    fecha: Date | string
    factura: number
    Procedimiento_Usuario: UsuarioCreateNestedOneWithoutProcedimientoInput
  }

  export type ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput = {
    id_procedimiento?: number
    consecutivo: number
    fecha: Date | string
    factura: number
    usuario: number
  }

  export type ProcedimientoCreateOrConnectWithoutProcedimiento_AcuerdoInput = {
    where: ProcedimientoWhereUniqueInput
    create: XOR<ProcedimientoCreateWithoutProcedimiento_AcuerdoInput, ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput>
  }

  export type ProcedimientoCreateManyProcedimiento_AcuerdoInputEnvelope = {
    data: ProcedimientoCreateManyProcedimiento_AcuerdoInput | ProcedimientoCreateManyProcedimiento_AcuerdoInput[]
    skipDuplicates?: boolean
  }

  export type ContratoCreateWithoutAcuerdoInput = {
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    Contrato_Empresa: EmpresaCreateNestedOneWithoutContratoInput
  }

  export type ContratoUncheckedCreateWithoutAcuerdoInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
    empresa: number
  }

  export type ContratoCreateOrConnectWithoutAcuerdoInput = {
    where: ContratoWhereUniqueInput
    create: XOR<ContratoCreateWithoutAcuerdoInput, ContratoUncheckedCreateWithoutAcuerdoInput>
  }

  export type TarifaCreateWithoutAcuerdoInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    servicio?: ServicioCreateNestedManyWithoutTarifa_ServicioInput
  }

  export type TarifaUncheckedCreateWithoutAcuerdoInput = {
    id_tarifa?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado: $Enums.Estado
    servicio?: ServicioUncheckedCreateNestedManyWithoutTarifa_ServicioInput
  }

  export type TarifaCreateOrConnectWithoutAcuerdoInput = {
    where: TarifaWhereUniqueInput
    create: XOR<TarifaCreateWithoutAcuerdoInput, TarifaUncheckedCreateWithoutAcuerdoInput>
  }

  export type ProcedimientoUpsertWithWhereUniqueWithoutProcedimiento_AcuerdoInput = {
    where: ProcedimientoWhereUniqueInput
    update: XOR<ProcedimientoUpdateWithoutProcedimiento_AcuerdoInput, ProcedimientoUncheckedUpdateWithoutProcedimiento_AcuerdoInput>
    create: XOR<ProcedimientoCreateWithoutProcedimiento_AcuerdoInput, ProcedimientoUncheckedCreateWithoutProcedimiento_AcuerdoInput>
  }

  export type ProcedimientoUpdateWithWhereUniqueWithoutProcedimiento_AcuerdoInput = {
    where: ProcedimientoWhereUniqueInput
    data: XOR<ProcedimientoUpdateWithoutProcedimiento_AcuerdoInput, ProcedimientoUncheckedUpdateWithoutProcedimiento_AcuerdoInput>
  }

  export type ProcedimientoUpdateManyWithWhereWithoutProcedimiento_AcuerdoInput = {
    where: ProcedimientoScalarWhereInput
    data: XOR<ProcedimientoUpdateManyMutationInput, ProcedimientoUncheckedUpdateManyWithoutProcedimiento_AcuerdoInput>
  }

  export type ContratoUpsertWithoutAcuerdoInput = {
    update: XOR<ContratoUpdateWithoutAcuerdoInput, ContratoUncheckedUpdateWithoutAcuerdoInput>
    create: XOR<ContratoCreateWithoutAcuerdoInput, ContratoUncheckedCreateWithoutAcuerdoInput>
    where?: ContratoWhereInput
  }

  export type ContratoUpdateToOneWithWhereWithoutAcuerdoInput = {
    where?: ContratoWhereInput
    data: XOR<ContratoUpdateWithoutAcuerdoInput, ContratoUncheckedUpdateWithoutAcuerdoInput>
  }

  export type ContratoUpdateWithoutAcuerdoInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    Contrato_Empresa?: EmpresaUpdateOneRequiredWithoutContratoNestedInput
  }

  export type ContratoUncheckedUpdateWithoutAcuerdoInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    empresa?: IntFieldUpdateOperationsInput | number
  }

  export type TarifaUpsertWithoutAcuerdoInput = {
    update: XOR<TarifaUpdateWithoutAcuerdoInput, TarifaUncheckedUpdateWithoutAcuerdoInput>
    create: XOR<TarifaCreateWithoutAcuerdoInput, TarifaUncheckedCreateWithoutAcuerdoInput>
    where?: TarifaWhereInput
  }

  export type TarifaUpdateToOneWithWhereWithoutAcuerdoInput = {
    where?: TarifaWhereInput
    data: XOR<TarifaUpdateWithoutAcuerdoInput, TarifaUncheckedUpdateWithoutAcuerdoInput>
  }

  export type TarifaUpdateWithoutAcuerdoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUpdateManyWithoutTarifa_ServicioNestedInput
  }

  export type TarifaUncheckedUpdateWithoutAcuerdoInput = {
    id_tarifa?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    servicio?: ServicioUncheckedUpdateManyWithoutTarifa_ServicioNestedInput
  }

  export type ProcedimientoCreateManyProcedimiento_UsuarioInput = {
    id_procedimiento?: number
    consecutivo: number
    fecha: Date | string
    factura: number
    acuerdo: number
  }

  export type ProcedimientoUpdateWithoutProcedimiento_UsuarioInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    Procedimiento_Acuerdo?: AcuerdoUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutProcedimiento_UsuarioInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    acuerdo?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    acuerdo?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateManyEps_usuarioInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    municipio: number
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UsuarioUpdateWithoutEps_usuarioInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_UsuarioNestedInput
    Municipio_Usuario?: MunicipioUpdateOneRequiredWithoutSuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEps_usuarioInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutEps_usuarioInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    municipio?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipioCreateManyDepartamentos_MunicipioInput = {
    id_municipio?: number
    nombre: string
  }

  export type MunicipioUpdateWithoutDepartamentos_MunicipioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    suario?: UsuarioUpdateManyWithoutMunicipio_UsuarioNestedInput
    empresa?: EmpresaUpdateManyWithoutMuncipio_EmpresaNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutDepartamentos_MunicipioInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    suario?: UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioNestedInput
    empresa?: EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaNestedInput
  }

  export type MunicipioUncheckedUpdateManyWithoutDepartamentos_MunicipioInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateManyMunicipio_UsuarioInput = {
    id_usuario?: number
    tipo_identificacion: $Enums.Tipo_Ident
    identificacion: string
    primer_nombre: string
    segundo_nombre?: string | null
    primer_apellido: string
    segundo_apellido?: string | null
    fecha_nacimiento: Date | string
    sexo: $Enums.Sex
    email: string
    telefono?: string | null
    tipo_usuario: $Enums.Tipo_Usuario
    estado: $Enums.Estado
    createAt?: Date | string
    updateAt?: Date | string
    eps: number
  }

  export type EmpresaCreateManyMuncipio_EmpresaInput = {
    id_empresa?: number
    nit: string
    codigo: number
    nombre: string
    sigla: string
    tipo: $Enums.Tipo_Empresa
    estado: $Enums.Estado
  }

  export type UsuarioUpdateWithoutMunicipio_UsuarioInput = {
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_UsuarioNestedInput
    Eps_usuario?: EpsUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMunicipio_UsuarioInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_UsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutMunicipio_UsuarioInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    tipo_identificacion?: EnumTipo_IdentFieldUpdateOperationsInput | $Enums.Tipo_Ident
    identificacion?: StringFieldUpdateOperationsInput | string
    primer_nombre?: StringFieldUpdateOperationsInput | string
    segundo_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    primer_apellido?: StringFieldUpdateOperationsInput | string
    segundo_apellido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_usuario?: EnumTipo_UsuarioFieldUpdateOperationsInput | $Enums.Tipo_Usuario
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eps?: IntFieldUpdateOperationsInput | number
  }

  export type EmpresaUpdateWithoutMuncipio_EmpresaInput = {
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: ContratoUpdateManyWithoutContrato_EmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutMuncipio_EmpresaInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: ContratoUncheckedUpdateManyWithoutContrato_EmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateManyWithoutMuncipio_EmpresaInput = {
    id_empresa?: IntFieldUpdateOperationsInput | number
    nit?: StringFieldUpdateOperationsInput | string
    codigo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_EmpresaFieldUpdateOperationsInput | $Enums.Tipo_Empresa
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type ServicioCreateManyPrestador_ServicioInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa: number
    protocolo: number
  }

  export type EmpleadoCreateManyPretador_EmpleadoInput = {
    id_empleado?: number
    identificacion: bigint | number
    nombre: string
    cargo: string
    rol: $Enums.Rol
    password: string
  }

  export type ServicioUpdateWithoutPrestador_ServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    Tarifa_Servicio?: TarifaUpdateOneRequiredWithoutServicioNestedInput
    Tarifa_Protocolo?: ProtocoloUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutPrestador_ServicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
    protocolo?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioUncheckedUpdateManyWithoutPrestador_ServicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
    protocolo?: IntFieldUpdateOperationsInput | number
  }

  export type EmpleadoUpdateWithoutPretador_EmpleadoInput = {
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    password?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadoUncheckedUpdateWithoutPretador_EmpleadoInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    password?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadoUncheckedUpdateManyWithoutPretador_EmpleadoInput = {
    id_empleado?: IntFieldUpdateOperationsInput | number
    identificacion?: BigIntFieldUpdateOperationsInput | bigint | number
    nombre?: StringFieldUpdateOperationsInput | string
    cargo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ServicioCreateManyTarifa_ServicioInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    protocolo: number
    prestador: number
  }

  export type AcuerdoCreateManyTarifa_AcuerdoInput = {
    id_acuerdo?: number
    estado: $Enums.Estado
    contrato: number
    valor: Decimal | DecimalJsLike | number | string
  }

  export type ServicioUpdateWithoutTarifa_ServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    Tarifa_Protocolo?: ProtocoloUpdateOneRequiredWithoutServicioNestedInput
    Prestador_Servicio?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutTarifa_ServicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    protocolo?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioUncheckedUpdateManyWithoutTarifa_ServicioInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    protocolo?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type AcuerdoUpdateWithoutTarifa_AcuerdoInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_AcuerdoNestedInput
    Contrato_Acuerdo?: ContratoUpdateOneRequiredWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateWithoutTarifa_AcuerdoInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_AcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateManyWithoutTarifa_AcuerdoInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    contrato?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicioCreateManyTarifa_ProtocoloInput = {
    id_servicio?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    iva: Decimal | DecimalJsLike | number | string
    nivel: number
    tarifa: number
    prestador: number
  }

  export type ServicioUpdateWithoutTarifa_ProtocoloInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    Tarifa_Servicio?: TarifaUpdateOneRequiredWithoutServicioNestedInput
    Prestador_Servicio?: PrestadorUpdateOneRequiredWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutTarifa_ProtocoloInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type ServicioUncheckedUpdateManyWithoutTarifa_ProtocoloInput = {
    id_servicio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    iva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nivel?: IntFieldUpdateOperationsInput | number
    tarifa?: IntFieldUpdateOperationsInput | number
    prestador?: IntFieldUpdateOperationsInput | number
  }

  export type ContratoCreateManyContrato_EmpresaInput = {
    id_contrato?: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    estado: $Enums.Estado
  }

  export type ContratoUpdateWithoutContrato_EmpresaInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    acuerdo?: AcuerdoUpdateManyWithoutContrato_AcuerdoNestedInput
  }

  export type ContratoUncheckedUpdateWithoutContrato_EmpresaInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    acuerdo?: AcuerdoUncheckedUpdateManyWithoutContrato_AcuerdoNestedInput
  }

  export type ContratoUncheckedUpdateManyWithoutContrato_EmpresaInput = {
    id_contrato?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
  }

  export type AcuerdoCreateManyContrato_AcuerdoInput = {
    id_acuerdo?: number
    estado: $Enums.Estado
    valor: Decimal | DecimalJsLike | number | string
    tarifa: number
  }

  export type AcuerdoUpdateWithoutContrato_AcuerdoInput = {
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    procedimiento?: ProcedimientoUpdateManyWithoutProcedimiento_AcuerdoNestedInput
    Tarifa_Acuerdo?: TarifaUpdateOneRequiredWithoutAcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateWithoutContrato_AcuerdoInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tarifa?: IntFieldUpdateOperationsInput | number
    procedimiento?: ProcedimientoUncheckedUpdateManyWithoutProcedimiento_AcuerdoNestedInput
  }

  export type AcuerdoUncheckedUpdateManyWithoutContrato_AcuerdoInput = {
    id_acuerdo?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoFieldUpdateOperationsInput | $Enums.Estado
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tarifa?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoCreateManyProcedimiento_AcuerdoInput = {
    id_procedimiento?: number
    consecutivo: number
    fecha: Date | string
    factura: number
    usuario: number
  }

  export type ProcedimientoUpdateWithoutProcedimiento_AcuerdoInput = {
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    Procedimiento_Usuario?: UsuarioUpdateOneRequiredWithoutProcedimientoNestedInput
  }

  export type ProcedimientoUncheckedUpdateWithoutProcedimiento_AcuerdoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
  }

  export type ProcedimientoUncheckedUpdateManyWithoutProcedimiento_AcuerdoInput = {
    id_procedimiento?: IntFieldUpdateOperationsInput | number
    consecutivo?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    factura?: IntFieldUpdateOperationsInput | number
    usuario?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EpsCountOutputTypeDefaultArgs instead
     */
    export type EpsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EpsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartamentoCountOutputTypeDefaultArgs instead
     */
    export type DepartamentoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioCountOutputTypeDefaultArgs instead
     */
    export type MunicipioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrestadorCountOutputTypeDefaultArgs instead
     */
    export type PrestadorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrestadorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TarifaCountOutputTypeDefaultArgs instead
     */
    export type TarifaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TarifaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocoloCountOutputTypeDefaultArgs instead
     */
    export type ProtocoloCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocoloCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaCountOutputTypeDefaultArgs instead
     */
    export type EmpresaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContratoCountOutputTypeDefaultArgs instead
     */
    export type ContratoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContratoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcuerdoCountOutputTypeDefaultArgs instead
     */
    export type AcuerdoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcuerdoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EpsDefaultArgs instead
     */
    export type EpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EpsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedimientoDefaultArgs instead
     */
    export type ProcedimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartamentoDefaultArgs instead
     */
    export type DepartamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioDefaultArgs instead
     */
    export type MunicipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicioDefaultArgs instead
     */
    export type ServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrestadorDefaultArgs instead
     */
    export type PrestadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrestadorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpleadoDefaultArgs instead
     */
    export type EmpleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpleadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TarifaDefaultArgs instead
     */
    export type TarifaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TarifaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProtocoloDefaultArgs instead
     */
    export type ProtocoloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProtocoloDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaDefaultArgs instead
     */
    export type EmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContratoDefaultArgs instead
     */
    export type ContratoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContratoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcuerdoDefaultArgs instead
     */
    export type AcuerdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcuerdoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}